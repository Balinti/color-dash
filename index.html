<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="theme-color" content="#0b1020">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Lane Prism Dash">
<meta property="og:description" content="Switch lanes, match colors, hit prism windows for combos. A fast hyper-casual HTML5 game with color-blind accessible patterns.">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Lane Prism Dash">
<meta name="twitter:description" content="Switch lanes, match colors, hit prism windows for combos. A fast hyper-casual HTML5 game with color-blind accessible patterns.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og.png">
<link rel="canonical" href="https://balinti.github.io/color-dash/">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0b1020;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;touch-action:none;overscroll-behavior:none;-webkit-tap-highlight-color:transparent;user-select:none}
#app{position:relative;max-width:420px;max-height:750px;width:100%;height:100vh;margin:0 auto;display:flex;flex-direction:column;align-items:center}
canvas{display:block;width:100%;flex:1;border-radius:4px}
#seo{max-width:420px;width:100%;margin:0 auto;padding:6px 12px;color:#556;font-size:11px;line-height:1.5;text-align:center;flex-shrink:0}
#seo summary{cursor:pointer;color:#778;font-size:12px;margin-bottom:4px}
#seo p{margin:3px 0}
</style>
</head>
<body>
<div id="app">
<canvas id="c"></canvas>
<details id="seo">
<summary>About Color Dash</summary>
<p><strong>Color Dash</strong> is a free hyper-casual HTML5 game. Switch between two lanes — Cyan (left, stripes pattern) and Magenta (right, dots pattern) — to pass through matching color gates. Hit the center prism window for combo multipliers!</p>
<p><strong>Controls:</strong> Tap screen, press Space or Enter to switch lanes. Each lane switch costs your combo streak, so time your moves carefully.</p>
<p><strong>Accessibility:</strong> Cyan lane uses diagonal stripe patterns and Magenta lane uses dot patterns for color-blind friendly identification.</p>
<p>Keywords: color dash, HTML5 game, hyper-casual, free browser game, lane switch, prism dash, color matching game, mobile game, canvas game</p>
</details>
</div>
<script>
'use strict';
(()=>{

/* ── Canvas Setup ── */
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let W, H, dpr;

function resize() {
  const rect = cvs.getBoundingClientRect();
  dpr = window.devicePixelRatio || 1;
  W = rect.width;
  H = rect.height;
  cvs.width = W * dpr;
  cvs.height = H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resize);
resize();

/* ── Constants ── */
const CYAN_H = 190, MAG_H = 315;
const CYAN = `hsl(${CYAN_H},90%,55%)`;
const MAGENTA = `hsl(${MAG_H},90%,60%)`;
const DANGER = 'hsl(0,70%,45%)';
const DANGER_DARK = 'hsl(0,50%,25%)';
const PR = 14; // player radius

function laneX(l) { return l === 0 ? W * 0.28 : W * 0.72; }
function playerY() { return H * 0.82; }
function laneCol(l) { return l === 0 ? CYAN : MAGENTA; }

/* ── State Machine ── */
const ST = { START: 0, PLAY: 1, OVER: 2 };
let state = ST.START;

/* ── Game Variables ── */
let score, combo, maxCombo, sessionMaxMult, lane, px, pxTarget;
let gates, particles, elapsed, gateTimer;
let shakeX, shakeY, shakeDur, hitStopTimer, bgHue;

/* ── Persistence ── */
let best = parseInt(localStorage.getItem('cd_best')) || 0;
let bestStreak = parseInt(localStorage.getItem('cd_bstrk')) || 0;
let bestMult = parseInt(localStorage.getItem('cd_bmul')) || 0;

/* ── Tips ── */
let tipIdx = 0;
const tips = [
  'Tip: Switching lanes resets your combo streak!',
  'Tip: Hit the prism center for combo bonus.',
  'Tip: x2 at 3 streak, x3 at 5, x4 at 8.',
  'Tip: Stay in one lane to build combos.',
  'Tip: Shatter gates appear after score 50!',
  'Tip: Cyan = stripes, Magenta = dots.'
];

/* ── Multiplier Logic ── */
function getMult(c) {
  if (c >= 8) return 4;
  if (c >= 5) return 3;
  if (c >= 3) return 2;
  return 1;
}
function nextMultAt(c) {
  if (c < 3) return 3;
  if (c < 5) return 5;
  if (c < 8) return 8;
  return null;
}

/* ── Difficulty ── */
function getSpeed() {
  return 155 + (elapsed / 60) * 45 + score * 1.1;
}
function getSpawnInterval() {
  const base = 1.5;
  const mn = 0.55;
  return Math.max(mn, base - (elapsed / 60) * 0.15 - score * 0.005);
}

/* ── Particles ── */
function emit(x, y, col, n, spd) {
  for (let i = 0; i < n; i++) {
    const a = Math.random() * Math.PI * 2;
    const v = spd * (0.4 + Math.random() * 0.6);
    particles.push({ x, y, vx: Math.cos(a) * v, vy: Math.sin(a) * v, life: 1, col, r: 1.5 + Math.random() * 3 });
  }
}
function emitPrism(x, y) {
  for (let i = 0; i < 28; i++) {
    const a = Math.random() * Math.PI * 2;
    const v = 70 + Math.random() * 130;
    const h = Math.random() * 360;
    particles.push({ x, y, vx: Math.cos(a) * v, vy: Math.sin(a) * v, life: 1, col: `hsl(${h|0},95%,65%)`, r: 2 + Math.random() * 4 });
  }
}
function emitCrash(x, y) {
  for (let i = 0; i < 45; i++) {
    const a = Math.random() * Math.PI * 2;
    const v = 50 + Math.random() * 200;
    const h = Math.random() * 50;
    particles.push({ x, y, vx: Math.cos(a) * v, vy: Math.sin(a) * v, life: 1, col: `hsl(${h|0},80%,55%)`, r: 2 + Math.random() * 6 });
  }
}

/* ── Gate Creation ──
   Each gate is a horizontal bar. It has:
   - safeSide: 0 = left half is safe (cyan pass), 1 = right half is safe (magenta pass)
   - The safe half matches the lane color: left=cyan, right=magenta
   - Center gap = prism window for bonus
   - Danger half has cracks/spikes
   Gate types by score:
     simple: standard split
     feint (10+): safe zone slightly narrower
     offset (25+): prism window shifted from center
     shatter (50+): much narrower safe zone
*/
function makeGate() {
  let type = 'simple';
  if (score >= 50 && Math.random() < 0.22) type = 'shatter';
  else if (score >= 25 && Math.random() < 0.28) type = 'offset';
  else if (score >= 10 && Math.random() < 0.32) type = 'feint';

  const safeSide = Math.random() < 0.5 ? 0 : 1;
  const gapW = type === 'shatter' ? W * 0.06 : W * 0.09;
  const prismOff = type === 'offset' ? (Math.random() < 0.5 ? -W * 0.04 : W * 0.04) : 0;

  // For feint/shatter, safe zone width shrinks
  let safeRatio = 0.46; // fraction of half-width that's safe
  if (type === 'feint') safeRatio = 0.40;
  if (type === 'shatter') safeRatio = 0.32;

  return {
    y: -25,
    safeSide,
    type,
    gapW,
    prismOff,
    safeRatio,
    h: 16,
    passed: false,
    prismHit: false
  };
}

/* ── Gate Geometry Helpers ── */
function getGateRects(g) {
  const cx = W / 2 + g.prismOff;
  const hg = g.gapW / 2;
  // Left rect: 0 to cx - hg
  // Right rect: cx + hg to W
  // Prism gap: cx - hg to cx + hg
  return {
    leftX: 0, leftW: cx - hg,
    rightX: cx + hg, rightW: W - (cx + hg),
    prismX: cx - hg, prismW: g.gapW,
    cx, hg
  };
}

/* ── Init ── */
function init() {
  score = 0; combo = 0; maxCombo = 0; sessionMaxMult = 1;
  lane = 0;
  px = laneX(0); pxTarget = px;
  gates = []; particles = [];
  elapsed = 0; gateTimer = 0.8;
  shakeX = 0; shakeY = 0; shakeDur = 0; hitStopTimer = 0;
  bgHue = 220;
}

/* ── Input ── */
let shareClicked = false;

function handleTap(e) {
  if (e) e.preventDefault();
  if (state === ST.START) {
    state = ST.PLAY;
    init();
    return;
  }
  if (state === ST.OVER) {
    if (shareClicked) { shareClicked = false; return; }
    state = ST.PLAY;
    init();
    return;
  }
  // Switch lane
  lane = 1 - lane;
  pxTarget = laneX(lane);
  combo = 0; // lane switch cost
}

cvs.addEventListener('pointerdown', (e) => {
  // Check share button first in gameover
  if (state === ST.OVER) {
    const r = cvs.getBoundingClientRect();
    const mx = (e.clientX - r.left) * (W / r.width);
    const my = (e.clientY - r.top) * (H / r.height);
    if (mx >= shareBtn.x && mx <= shareBtn.x + shareBtn.w && my >= shareBtn.y && my <= shareBtn.y + shareBtn.h) {
      shareClicked = true;
      doShare();
      e.preventDefault();
      return;
    }
  }
  handleTap(e);
});

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') {
    e.preventDefault();
    handleTap(null);
  }
});

/* ── Share ── */
const shareBtn = { x: 0, y: 0, w: 0, h: 0 };

function doShare() {
  const text = `I scored ${score} in Color Dash! Can you beat me?`;
  const url = 'https://balinti.github.io/color-dash/';
  if (navigator.share) {
    navigator.share({ title: 'Color Dash', text, url }).catch(() => {});
  } else if (navigator.clipboard) {
    navigator.clipboard.writeText(text + ' ' + url).catch(() => {});
  }
}

/* ── Game Over ── */
function gameOver() {
  state = ST.OVER;
  emitCrash(px, playerY());
  shakeDur = 0.45;
  if (score > best) { best = score; localStorage.setItem('cd_best', String(best)); }
  if (maxCombo > bestStreak) { bestStreak = maxCombo; localStorage.setItem('cd_bstrk', String(bestStreak)); }
  if (sessionMaxMult > bestMult) { bestMult = sessionMaxMult; localStorage.setItem('cd_bmul', String(bestMult)); }
  tipIdx = (tipIdx + 1) % tips.length;
}

/* ── Update ── */
function update(dt) {
  if (state !== ST.PLAY) return;

  elapsed += dt;

  // Smooth player slide
  px += (pxTarget - px) * Math.min(1, 14 * dt);

  // Spawn gates
  gateTimer -= dt;
  if (gateTimer <= 0) {
    gates.push(makeGate());
    gateTimer = getSpawnInterval();
  }

  const spd = getSpeed();
  const py = playerY();

  for (let i = gates.length - 1; i >= 0; i--) {
    const g = gates[i];
    g.y += spd * dt;

    // Collision — check when gate overlaps player vertically
    if (!g.passed && g.y + g.h >= py - PR && g.y <= py + PR) {
      const gr = getGateRects(g);

      // Player circle AABB
      const pL = px - PR, pR = px + PR;

      // Determine danger zone
      // safeSide 0 => left half is safe (cyan), right half is danger
      // safeSide 1 => right half is safe (magenta), left half is danger
      let hitDanger = false;

      if (g.safeSide === 0) {
        // Right half is danger. Does player overlap right rect?
        if (pR > gr.rightX + 2 && pL < gr.rightX + gr.rightW) {
          hitDanger = true;
        }
      } else {
        // Left half is danger. Does player overlap left rect?
        if (pL < gr.leftW - 2 && pR > gr.leftX) {
          hitDanger = true;
        }
      }

      if (hitDanger) {
        gameOver();
        break;
      }
    }

    // Passed gate
    if (!g.passed && g.y > py + PR) {
      g.passed = true;
      const mult = getMult(combo);
      score += mult;
      sessionMaxMult = Math.max(sessionMaxMult, mult);
      emit(px, py, laneCol(lane), 8, 70);

      // Prism hit check
      const gr = getGateRects(g);
      const dist = Math.abs(px - gr.cx);
      const prismR = gr.hg + 6; // forgiveness radius
      if (dist < prismR) {
        g.prismHit = true;
        combo++;
        maxCombo = Math.max(maxCombo, combo);
        emitPrism(px, py);
        shakeDur = Math.max(shakeDur, 0.07);
        // Hit-stop on tier milestones
        if (combo === 3 || combo === 5 || combo === 8) hitStopTimer = 0.07;
      } else {
        combo = Math.max(0, combo - 1);
      }
    }

    // Remove off-screen
    if (g.y > H + 40) { gates.splice(i, 1); }
  }
}

/* ── Drawing Helpers ── */

function drawStripes(x, y, w, h, spacing, alpha) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(x, y, w, h);
  ctx.clip();
  ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
  ctx.lineWidth = 1.5;
  for (let i = -h; i <= w + h; i += spacing) {
    ctx.beginPath();
    ctx.moveTo(x + i, y);
    ctx.lineTo(x + i - h, y + h);
    ctx.stroke();
  }
  ctx.restore();
}

function drawDots(x, y, w, h, spacing, alpha) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(x, y, w, h);
  ctx.clip();
  ctx.fillStyle = `rgba(255,255,255,${alpha})`;
  for (let dy = spacing / 2; dy < h; dy += spacing) {
    for (let dx = spacing / 2; dx < w; dx += spacing) {
      ctx.beginPath();
      ctx.arc(x + dx, y + dy, 1.3, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.restore();
}

function drawPlayerAccessibility(cx, cy, r, isLeft) {
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.clip();
  if (isLeft) {
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 2;
    for (let i = -r * 2; i <= r * 2; i += 5) {
      ctx.beginPath();
      ctx.moveTo(cx + i, cy - r);
      ctx.lineTo(cx + i - r * 2, cy + r);
      ctx.stroke();
    }
  } else {
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    for (let dy = -r; dy <= r; dy += 5) {
      for (let dx = -r; dx <= r; dx += 5) {
        if (dx * dx + dy * dy < r * r * 0.85) {
          ctx.beginPath();
          ctx.arc(cx + dx, cy + dy, 1.2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }
  ctx.restore();
}

function drawCracks(x, y, w, h) {
  ctx.save();
  ctx.strokeStyle = 'rgba(255,180,80,0.45)';
  ctx.lineWidth = 1;
  const step = 14;
  for (let i = 0; i < w; i += step) {
    const bx = x + i + step * 0.5;
    ctx.beginPath();
    ctx.moveTo(bx, y);
    ctx.lineTo(bx + 2, y + h * 0.5);
    ctx.lineTo(bx - 1, y + h);
    ctx.stroke();
  }
  ctx.restore();
}

/* ── Draw Frame ── */
function draw() {
  ctx.save();
  ctx.translate(shakeX, shakeY);

  // Background
  const bh = Math.floor(bgHue) % 360;
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, `hsl(${bh},25%,5%)`);
  bg.addColorStop(0.5, `hsl(${(bh + 25) % 360},20%,7%)`);
  bg.addColorStop(1, `hsl(${(bh + 50) % 360},18%,4%)`);
  ctx.fillStyle = bg;
  ctx.fillRect(-20, -20, W + 40, H + 40);

  // Lane divider
  ctx.save();
  ctx.setLineDash([4, 10]);
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(W / 2, 0);
  ctx.lineTo(W / 2, H);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  // Lane tint zones
  ctx.fillStyle = 'rgba(0,200,220,0.03)';
  ctx.fillRect(0, 0, W / 2, H);
  ctx.fillStyle = 'rgba(220,50,180,0.03)';
  ctx.fillRect(W / 2, 0, W / 2, H);

  // Lane labels
  if (state !== ST.OVER) {
    ctx.globalAlpha = 0.1;
    ctx.font = 'bold 10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = CYAN;
    ctx.fillText('CYAN', laneX(0), 22);
    ctx.fillStyle = MAGENTA;
    ctx.fillText('MAGENTA', laneX(1), 22);
    ctx.globalAlpha = 1;
  }

  // Gates
  if (state === ST.PLAY || state === ST.OVER) {
    for (const g of gates) {
      const gr = getGateRects(g);
      const gy = g.y, gh = g.h;

      if (g.safeSide === 0) {
        // Left = safe (cyan), right = danger
        ctx.fillStyle = CYAN;
        ctx.fillRect(gr.leftX, gy, gr.leftW, gh);
        drawStripes(gr.leftX, gy, gr.leftW, gh, 6, 0.3);

        ctx.fillStyle = DANGER;
        ctx.fillRect(gr.rightX, gy, gr.rightW, gh);
        drawCracks(gr.rightX, gy, gr.rightW, gh);
      } else {
        // Right = safe (magenta), left = danger
        ctx.fillStyle = MAGENTA;
        ctx.fillRect(gr.rightX, gy, gr.rightW, gh);
        drawDots(gr.rightX, gy, gr.rightW, gh, 5, 0.25);

        ctx.fillStyle = DANGER;
        ctx.fillRect(gr.leftX, gy, gr.leftW, gh);
        drawCracks(gr.leftX, gy, gr.leftW, gh);
      }

      // Prism window glow
      const pg = ctx.createRadialGradient(gr.cx, gy + gh / 2, 0, gr.cx, gy + gh / 2, gr.hg + 8);
      pg.addColorStop(0, 'rgba(255,255,255,0.4)');
      pg.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = pg;
      ctx.fillRect(gr.cx - gr.hg - 8, gy - 6, g.gapW + 16, gh + 12);

      // Prism diamond
      ctx.save();
      ctx.translate(gr.cx, gy + gh / 2);
      ctx.rotate(Math.PI / 4);
      const ds = g.prismHit ? 6 : 4;
      ctx.fillStyle = g.prismHit ? 'rgba(255,255,200,0.9)' : 'rgba(255,255,255,0.6)';
      ctx.fillRect(-ds, -ds, ds * 2, ds * 2);
      ctx.restore();
    }
  }

  // Player
  if (state === ST.PLAY || state === ST.START) {
    const ppx = state === ST.START ? laneX(0) : px;
    const ppy = playerY();
    const isLeft = state === ST.START ? true : lane === 0;
    const col = isLeft ? CYAN : MAGENTA;

    // Glow
    const glow = ctx.createRadialGradient(ppx, ppy, PR * 0.2, ppx, ppy, PR * 3);
    glow.addColorStop(0, isLeft ? 'rgba(0,200,220,0.22)' : 'rgba(220,50,180,0.22)');
    glow.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(ppx - PR * 3.5, ppy - PR * 3.5, PR * 7, PR * 7);

    // Trail (during play while sliding)
    if (state === ST.PLAY) {
      const trailDelta = (pxTarget - px);
      if (Math.abs(trailDelta) > 1) {
        ctx.save();
        ctx.globalAlpha = 0.12;
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.arc(ppx - trailDelta * 0.3, ppy, PR * 0.65, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 0.05;
        ctx.beginPath();
        ctx.arc(ppx - trailDelta * 0.6, ppy, PR * 0.45, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // Player body
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(ppx, ppy, PR, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.65)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Accessibility pattern overlay
    drawPlayerAccessibility(ppx, ppy, PR, isLeft);
  }

  // Particles
  for (const p of particles) {
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = p.col;
    ctx.beginPath();
    ctx.arc(p.x, p.y, Math.max(0.5, p.r * p.life), 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // UI Overlays
  if (state === ST.PLAY) drawHUD();
  else if (state === ST.START) drawStart();
  else if (state === ST.OVER) drawGameOver();

  ctx.restore();
}

/* ── HUD ── */
function drawHUD() {
  const mult = getMult(combo);
  const nxt = nextMultAt(combo);

  // Score centered top
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 30px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(score, W / 2, 52);

  // Multiplier
  if (mult > 1) {
    ctx.font = 'bold 17px sans-serif';
    ctx.fillStyle = 'hsl(50,100%,72%)';
    ctx.fillText('x' + mult, W / 2, 74);
  }

  // Streak
  ctx.font = '11px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.55)';
  ctx.textAlign = 'left';
  ctx.fillText('Streak: ' + combo, 8, 20);

  // Best
  ctx.textAlign = 'right';
  ctx.fillText('Best: ' + best, W - 8, 20);

  // Next multiplier hint
  if (nxt !== null) {
    ctx.textAlign = 'center';
    ctx.font = '10px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillText('Next x' + (mult + 1) + ' at ' + nxt + ' streak', W / 2, 92);
  }
}

/* ── Start Screen ── */
function drawStart() {
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';

  // Title
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 38px sans-serif';
  ctx.fillText('Color Dash', W / 2, H * 0.28);

  ctx.font = '13px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('Lane Prism Dash', W / 2, H * 0.28 + 28);

  // Instructions
  const iy = H * 0.42;
  ctx.font = '13px sans-serif';
  ctx.fillStyle = CYAN;
  ctx.fillText('Left Lane = Cyan (stripes)', W / 2, iy);
  ctx.fillStyle = MAGENTA;
  ctx.fillText('Right Lane = Magenta (dots)', W / 2, iy + 22);

  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.font = '11px sans-serif';
  ctx.fillText('Hit the prism center for combo multipliers!', W / 2, iy + 50);
  ctx.fillText('Switching lanes resets your combo.', W / 2, iy + 68);

  // High score
  if (best > 0) {
    ctx.fillStyle = 'hsl(50,90%,70%)';
    ctx.font = 'bold 14px sans-serif';
    ctx.fillText('Best: ' + best, W / 2, H * 0.64);
  }

  // Pulse tap
  const pulse = 0.55 + Math.sin(Date.now() / 350) * 0.45;
  ctx.globalAlpha = pulse;
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 20px sans-serif';
  ctx.fillText('Tap to Start', W / 2, H * 0.76);
  ctx.globalAlpha = 1;

  // Small controls hint
  ctx.font = '10px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.25)';
  ctx.fillText('Space / Enter / Tap to switch lanes', W / 2, H * 0.82);
}

/* ── Game Over ── */
function drawGameOver() {
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';

  // Title
  ctx.fillStyle = 'hsl(0,75%,60%)';
  ctx.font = 'bold 32px sans-serif';
  ctx.fillText('Game Over', W / 2, H * 0.22);

  // Score
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 44px sans-serif';
  ctx.fillText(score, W / 2, H * 0.33);

  // Best
  ctx.font = '14px sans-serif';
  ctx.fillStyle = score >= best ? 'hsl(50,100%,70%)' : 'rgba(255,255,255,0.55)';
  ctx.fillText(score >= best ? 'New Best!' : 'Best: ' + best, W / 2, H * 0.33 + 26);

  // Stats
  const sy = H * 0.45;
  ctx.font = '12px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('Max Multiplier: x' + sessionMaxMult, W / 2, sy);
  ctx.fillText('Best Streak: ' + maxCombo, W / 2, sy + 18);

  // Tip
  ctx.font = 'italic 11px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  const tipText = tips[tipIdx];
  ctx.fillText(tipText, W / 2, sy + 48);

  // Retry
  const pulse = 0.55 + Math.sin(Date.now() / 350) * 0.45;
  ctx.globalAlpha = pulse;
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 20px sans-serif';
  ctx.fillText('Tap to Retry', W / 2, H * 0.68);
  ctx.globalAlpha = 1;

  // Share button
  const bw = 90, bh = 30;
  const bx = W / 2 - bw / 2;
  const by = H * 0.74;
  shareBtn.x = bx; shareBtn.y = by; shareBtn.w = bw; shareBtn.h = bh;

  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.beginPath();
  ctx.roundRect(bx, by, bw, bh, 8);
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Share', W / 2, by + 20);
}

/* ── Main Loop ── */
let lastT = 0;

function frame(ts) {
  requestAnimationFrame(frame);

  if (lastT === 0) { lastT = ts; return; }
  const rawDt = Math.min((ts - lastT) / 1000, 0.05);
  lastT = ts;

  // Hit-stop freeze
  if (hitStopTimer > 0) {
    hitStopTimer -= rawDt;
    draw(); // still draw, just freeze movement
    return;
  }

  const dt = rawDt;

  // Update particles always
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 220 * dt;
    p.life -= dt * 2;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Shake
  if (shakeDur > 0) {
    shakeDur -= dt;
    const mag = shakeDur * 35;
    shakeX = (Math.random() - 0.5) * mag;
    shakeY = (Math.random() - 0.5) * mag;
  } else {
    shakeX = 0; shakeY = 0;
  }

  // BG hue
  if (state === ST.PLAY) {
    bgHue += dt * 4 + combo * dt * 1.5;
    if (bgHue > 360) bgHue -= 360;
  }

  update(dt);
  draw();
}

/* ── Boot ── */
init();
requestAnimationFrame(frame);

})();
</script>
</body>
</html>
