<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="theme-color" content="#0a0a1a">
<meta property="og:title" content="Color Dash - Split Decision">
<meta property="og:description" content="Auto-run down a neon track through SUN and MOON gates. Tap to flip your mode. Dodge hazards. Chase combos. How far can you go?">
<meta property="og:type" content="website">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og.png">
<meta name="twitter:card" content="summary_large_image">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#05050f;font-family:'Segoe UI',system-ui,sans-serif;color:#fff;touch-action:none;user-select:none;-webkit-user-select:none}
#app{position:relative;width:100%;max-width:420px;height:100dvh;max-height:750px;margin:0 auto;display:flex;flex-direction:column;overflow:hidden}
@media(min-height:751px){#app{top:50%;transform:translateY(-50%)}}
header{height:44px;display:flex;align-items:center;justify-content:space-between;padding:0 14px;z-index:10;flex-shrink:0}
header .title{font-size:14px;font-weight:700;letter-spacing:1px;opacity:.7}
header .best{font-size:13px;opacity:.6}
header .mute-btn{background:none;border:none;color:#fff;font-size:18px;cursor:pointer;opacity:.6;padding:4px 8px}
header .mute-btn:hover{opacity:1}
#canvasWrap{position:relative;flex:1;min-height:0;overflow:hidden}
#canvasWrap canvas{display:block;width:100%;height:100%}
.overlay{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:20;pointer-events:none;opacity:0;transition:opacity .3s}
.overlay.active{opacity:1;pointer-events:auto}
.overlay h1{font-size:30px;letter-spacing:3px;margin-bottom:6px;text-shadow:0 0 20px rgba(255,200,50,.4)}
.overlay .sub{font-size:14px;opacity:.65;margin-bottom:20px}
.overlay .score-display{font-size:54px;font-weight:800;margin:8px 0}
.overlay .score-label{font-size:13px;opacity:.5;text-transform:uppercase;letter-spacing:2px}
.overlay .best-display{font-size:18px;opacity:.6;margin:4px 0 18px}
.overlay .tap-hint{font-size:14px;opacity:.55;animation:pulse 2s infinite}
.overlay .challenge{font-size:14px;color:#ffd54f;margin-bottom:12px}
.overlay .share-btn{background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.2);color:#fff;padding:8px 20px;border-radius:20px;font-size:13px;cursor:pointer;margin-top:10px;transition:background .2s}
.overlay .share-btn:hover{background:rgba(255,255,255,.22)}
@keyframes pulse{0%,100%{opacity:.55}50%{opacity:.9}}
footer{height:48px;display:flex;align-items:center;justify-content:center;flex-shrink:0;z-index:10}
footer .score{font-size:28px;font-weight:800;letter-spacing:1px;min-width:60px;text-align:center}
footer .combo{font-size:14px;font-weight:700;margin-left:12px;color:#ffd54f;opacity:0;transition:opacity .2s}
footer .combo.active{opacity:1}
</style>
</head>
<body>
<div id="app">
  <header>
    <span class="title">COLOR DASH</span>
    <span class="best" id="hdrBest"></span>
    <button class="mute-btn" id="muteBtn" aria-label="Toggle sound">&#x1f50a;</button>
  </header>
  <div id="canvasWrap">
    <canvas id="gc"></canvas>
    <div class="overlay active" id="startOverlay">
      <h1>SPLIT DECISION</h1>
      <div class="sub">SUN or MOON &mdash; choose wisely</div>
      <div class="challenge" id="challengeText" style="display:none"></div>
      <div class="tap-hint">Tap to Start</div>
    </div>
    <div class="overlay" id="overOverlay">
      <div class="score-label">SCORE</div>
      <div class="score-display" id="finalScore">0</div>
      <div class="best-display" id="finalBest">Best: 0</div>
      <button class="share-btn" id="shareBtn">Share Score</button>
      <div class="tap-hint" style="margin-top:16px">Tap to Retry</div>
    </div>
  </div>
  <footer>
    <span class="score" id="footScore">0</span>
    <span class="combo" id="footCombo">x1</span>
  </footer>
</div>
<script>
(()=>{
'use strict';

/* ===== TUNING KNOBS ===== */
const T = {
  baseSpeed:        180,    // px/s starting speed
  speedGain:        2.8,    // speed added per point
  maxSpeed:         520,    // speed cap
  spawnInterval:    1.6,    // seconds between gate pairs (start)
  minSpawnInterval: 0.7,    // fastest spawn rate
  spawnDecay:       0.006,  // interval shrink per point
  hazardBase:       0.15,   // initial hazard chance
  hazardMax:        0.55,   // max hazard chance
  hazardRampScore:  80,     // score at which hazard chance maxes
  pulseScore:       60,     // threshold for pulse gates
  pulseChance:      0.25,   // chance of pulse gate after threshold
  perfectLeadBase:  0.35,   // seconds for "perfect" lead time
  perfectLeadMin:   0.18,   // minimum lead time at high score
  perfectLeadDecay: 0.002,  // shrink per point
  hitStopPerfect:   0.04,   // freeze on perfect
  hitStopDeath:     0.50,   // slow-mo on death
  comboForMul:      4,      // combos per multiplier tier
  maxComboMul:      4,
  runnerXFrac:      0.20,   // runner X as fraction of canvas W
  gateW:            50,     // gate width
  gateGap:          16,     // gap between top and bottom gate areas
};

/* ===== CANVAS ===== */
const canvas = document.getElementById('gc');
const ctx    = canvas.getContext('2d');
const wrap   = document.getElementById('canvasWrap');
let W, H, dpr;

function resize(){
  const r = wrap.getBoundingClientRect();
  dpr = Math.min(window.devicePixelRatio||1, 2.5);
  W = r.width; H = r.height;
  canvas.width  = Math.round(W*dpr);
  canvas.height = Math.round(H*dpr);
  canvas.style.width  = W+'px';
  canvas.style.height = H+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);
resize();

/* ===== PALETTE ===== */
const SUN_FILL   = '#FFD54F';
const SUN_STROKE = '#FFA726';
const MOON_FILL  = '#90CAF9';
const MOON_STROKE= '#42A5F5';
const HAZARD_COL = '#FF1744';

/* ===== AUDIO ===== */
let actx = null;
let muted = localStorage.getItem('cd_muted')==='true';
const muteBtn = document.getElementById('muteBtn');
const updMute = ()=>{ muteBtn.textContent = muted?'\u{1F507}':'\u{1F50A}'; };
updMute();
muteBtn.addEventListener('click', e=>{
  e.stopPropagation(); muted=!muted;
  localStorage.setItem('cd_muted',muted); updMute();
});

function initAudio(){ if(!actx) actx = new (window.AudioContext||window.webkitAudioContext)(); }

function tone(freq,dur,vol=.1,type='square'){
  if(muted||!actx) return;
  try{
    const o=actx.createOscillator(), g=actx.createGain();
    o.type=type; o.frequency.value=freq;
    g.gain.setValueAtTime(vol,actx.currentTime);
    g.gain.exponentialRampToValueAtTime(.001,actx.currentTime+dur);
    o.connect(g); g.connect(actx.destination);
    o.start(); o.stop(actx.currentTime+dur);
  }catch(e){}
}
function sfxPerfect(){ tone(880,.1,.09,'sine'); setTimeout(()=>tone(1100,.12,.07,'sine'),60); }
function sfxMatch(){ tone(660,.1,.07,'sine'); }
function sfxWrong(){ tone(200,.2,.11,'sawtooth'); }
function sfxDeath(){ tone(120,.4,.14,'sawtooth'); setTimeout(()=>tone(80,.3,.09,'sawtooth'),150); }
function sfxFlip(){ tone(520,.06,.06,'sine'); }

/* ===== STATE ===== */
let state      = 'start';
let score      = 0;
let best       = parseInt(localStorage.getItem('cd_best'))||0;
let combo      = 0;
let comboMul   = 1;
let speed      = T.baseSpeed;
let spawnTimer = 0;
let spawnInt   = T.spawnInterval;
let mode       = 0;           // 0=SUN 1=MOON
let lane       = 0;           // 0=top  1=bottom
let modeSince  = 0;
let gameTime   = 0;
let gates      = [];
let particles  = [];
let pops       = [];
let runner     = {x:0, y:0, r:18};
let shakeX=0, shakeY=0, shakeMag=0, shakeT=0;
let hitStop=0, slowMo=0, deathTimer=0;
let trackScroll = 0;

/* ===== DOM refs ===== */
const startOv    = document.getElementById('startOverlay');
const overOv     = document.getElementById('overOverlay');
const hdrBest    = document.getElementById('hdrBest');
const finalScEl  = document.getElementById('finalScore');
const finalBsEl  = document.getElementById('finalBest');
const footScore  = document.getElementById('footScore');
const footCombo  = document.getElementById('footCombo');
const challengeT = document.getElementById('challengeText');
const shareBtn   = document.getElementById('shareBtn');

function updBestUI(){ hdrBest.textContent='Best: '+best; }
updBestUI();

// Challenge param
const usp = new URLSearchParams(location.search);
let challengeScore = 0;
if(usp.has('challenge')){
  challengeScore = parseInt(usp.get('challenge'))||0;
  if(challengeScore>0){
    challengeT.textContent='Challenge: Beat '+challengeScore+'!';
    challengeT.style.display='';
  }
}

/* ===== HELPERS ===== */
function clamp(v,lo,hi){ return v<lo?lo:v>hi?hi:v; }
function lerp(a,b,t){ return a+(b-a)*t; }

function getComboMul(){ return 1+Math.floor(Math.min(combo,12)/T.comboForMul); }

function addScore(pts){
  score += pts;
  speed = Math.min(T.baseSpeed + score*T.speedGain, T.maxSpeed);
  spawnInt = Math.max(T.spawnInterval - score*T.spawnDecay, T.minSpawnInterval);
  if(score>best){ best=score; localStorage.setItem('cd_best',best); updBestUI(); }
  updScoreUI();
}

function updScoreUI(){
  footScore.textContent = score;
  comboMul = getComboMul();
  if(comboMul>1){
    footCombo.textContent = 'x'+comboMul;
    footCombo.classList.add('active');
  } else {
    footCombo.classList.remove('active');
  }
}

function shake(mag,dur){ shakeMag=mag; shakeT=dur; }

/* ===== PARTICLES ===== */
function burst(x,y,col,n,sp=3,life=.6){
  for(let i=0;i<n;i++){
    particles.push({
      x,y,
      vx:(Math.random()-.5)*sp*100,
      vy:(Math.random()-.5)*sp*100,
      life: life+Math.random()*.3,
      ml:   life+Math.random()*.3,
      r: 2+Math.random()*3,
      col
    });
  }
}
function pop(x,y,txt,col,sz=16){
  pops.push({x,y,txt,col,sz,life:1,ml:1});
}

/* ===== DRAWING ===== */
function drawSunIcon(x,y,r,a=1){
  ctx.save(); ctx.globalAlpha=a;
  ctx.fillStyle=SUN_FILL;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle=SUN_STROKE; ctx.lineWidth=2;
  for(let i=0;i<8;i++){
    const ang=(Math.PI*2/8)*i;
    ctx.beginPath();
    ctx.moveTo(x+Math.cos(ang)*(r+2), y+Math.sin(ang)*(r+2));
    ctx.lineTo(x+Math.cos(ang)*(r+6), y+Math.sin(ang)*(r+6));
    ctx.stroke();
  }
  ctx.restore();
}

function drawMoonIcon(x,y,r,a=1){
  ctx.save(); ctx.globalAlpha=a;
  ctx.fillStyle=MOON_FILL;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation='destination-out';
  ctx.beginPath(); ctx.arc(x+r*.45,y-r*.3,r*.7,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation='source-over';
  ctx.strokeStyle=MOON_STROKE; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();
  ctx.restore();
}

function drawGateRect(x,y,w,h,isSun,alpha){
  ctx.save(); ctx.globalAlpha=alpha;
  if(isSun){
    ctx.fillStyle = SUN_FILL;
    ctx.globalAlpha = alpha*.3;
    ctx.fillRect(x,y,w,h);
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = SUN_FILL;
    ctx.lineWidth=2.5;
    ctx.strokeRect(x+1,y+1,w-2,h-2);
  } else {
    // striped fill for moon
    ctx.fillStyle = MOON_FILL;
    ctx.globalAlpha = alpha*.22;
    ctx.fillRect(x,y,w,h);
    ctx.globalAlpha = alpha*.18;
    ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth=2;
    ctx.beginPath();
    for(let i=-h;i<w+h;i+=7){
      ctx.moveTo(x+i,y); ctx.lineTo(x+i+h,y+h);
    }
    ctx.stroke();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = MOON_FILL;
    ctx.lineWidth=2.5;
    ctx.strokeRect(x+1,y+1,w-2,h-2);
  }
  ctx.restore();
}

function drawHazard(x,y,w,h,alpha){
  ctx.save(); ctx.globalAlpha=alpha;
  // danger fill
  ctx.fillStyle='rgba(255,23,68,0.2)'; ctx.fillRect(x,y,w,h);
  // border
  ctx.strokeStyle=HAZARD_COL; ctx.lineWidth=3; ctx.strokeRect(x,y,w,h);
  // spikes
  ctx.fillStyle=HAZARD_COL;
  const ss=7, sc=Math.floor(h/(ss*2));
  for(let i=0;i<sc;i++){
    const sy=y+(h/sc)*i+(h/sc)/2;
    ctx.beginPath(); ctx.moveTo(x,sy-ss/2); ctx.lineTo(x+ss,sy); ctx.lineTo(x,sy+ss/2); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x+w,sy-ss/2); ctx.lineTo(x+w-ss,sy); ctx.lineTo(x+w,sy+ss/2); ctx.fill();
  }
  // X
  const cx=x+w/2, cy=y+h/2;
  ctx.strokeStyle=HAZARD_COL; ctx.lineWidth=3;
  ctx.beginPath(); ctx.moveTo(cx-7,cy-7); ctx.lineTo(cx+7,cy+7);
  ctx.moveTo(cx+7,cy-7); ctx.lineTo(cx-7,cy+7); ctx.stroke();
  // pulse overlay
  const p=.5+.5*Math.sin(gameTime*8);
  ctx.globalAlpha=alpha*p*.25;
  ctx.fillStyle=HAZARD_COL; ctx.fillRect(x,y,w,h);
  ctx.restore();
}

function drawRunner(x,y,r){
  ctx.save();
  // glow
  const gc=ctx.createRadialGradient(x,y,r*.5,x,y,r*2.5);
  gc.addColorStop(0, mode===0?'rgba(255,213,79,.25)':'rgba(144,202,249,.25)');
  gc.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=gc;
  ctx.beginPath(); ctx.arc(x,y,r*2.5,0,Math.PI*2); ctx.fill();

  if(mode===0){
    // SUN body
    ctx.fillStyle=SUN_FILL;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle=SUN_STROKE; ctx.lineWidth=2.5;
    for(let i=0;i<8;i++){
      const a=(Math.PI*2/8)*i+gameTime*2;
      ctx.beginPath();
      ctx.moveTo(x+Math.cos(a)*(r+2), y+Math.sin(a)*(r+2));
      ctx.lineTo(x+Math.cos(a)*(r+9), y+Math.sin(a)*(r+9));
      ctx.stroke();
    }
    ctx.fillStyle='#5D4037';
    ctx.beginPath(); ctx.arc(x,y,r*.28,0,Math.PI*2); ctx.fill();
  } else {
    // MOON body with stripes
    ctx.fillStyle=MOON_FILL;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.save();
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.clip();
    ctx.strokeStyle='rgba(0,0,0,.13)'; ctx.lineWidth=2;
    for(let i=-r*2;i<r*2;i+=5){
      ctx.beginPath(); ctx.moveTo(x+i,y-r); ctx.lineTo(x+i+r,y+r); ctx.stroke();
    }
    ctx.restore();
    ctx.globalCompositeOperation='destination-out';
    ctx.beginPath(); ctx.arc(x+r*.4,y-r*.25,r*.65,0,Math.PI*2); ctx.fill();
    ctx.globalCompositeOperation='source-over';
    ctx.strokeStyle=MOON_STROKE; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();
  }

  // combo ring
  if(comboMul>1){
    ctx.strokeStyle=mode===0?SUN_FILL:MOON_FILL;
    ctx.lineWidth=1.5;
    ctx.globalAlpha=.45+Math.sin(gameTime*6)*.3;
    ctx.beginPath(); ctx.arc(x,y,r+6+comboMul*2,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha=1;
  }
  ctx.restore();
}

/* ===== LANE GEOMETRY ===== */
function laneYs(){
  const mid=H/2, lh=(H-88)/2;
  return {
    topCenter: mid - T.gateGap/2 - lh/2,
    botCenter: mid + T.gateGap/2 + lh/2,
    laneH: lh
  };
}

/* ===== GATE SPAWNING ===== */
function spawnGate(){
  const {topCenter,botCenter,laneH} = laneYs();
  const gw = T.gateW;
  const gh = laneH*.55;
  const sunOnTop = Math.random()<.5;

  let hazardSide = -1;
  const hc = Math.min(T.hazardBase + (score/T.hazardRampScore)*(T.hazardMax-T.hazardBase), T.hazardMax);
  if(Math.random()<hc){
    hazardSide = Math.random()<.5?0:1;
    if(score>=60 && Math.random()<.3){
      const modeSide = (mode===0)?(sunOnTop?0:1):(sunOnTop?1:0);
      hazardSide = modeSide;
    }
  }

  let isPulse = score>=T.pulseScore && Math.random()<T.pulseChance;

  gates.push({
    x: W+gw+10,
    w: gw,
    topY: topCenter - gh/2,
    botY: botCenter - gh/2,
    gh,
    sunOnTop,
    hazardSide,
    isPulse,
    pPhase: Math.random()*Math.PI*2,
    resolved: false
  });
}

/* ===== RESOLVE GATE ===== */
function resolveGate(g){
  if(g.resolved) return;
  g.resolved = true;

  if(g.hazardSide===lane){ die(); return; }

  const sideIsSun = lane===0 ? g.sunOnTop : !g.sunOnTop;
  const matched = (mode===0&&sideIsSun)||(mode===1&&!sideIsSun);
  const pLead = Math.max(T.perfectLeadBase - score*T.perfectLeadDecay, T.perfectLeadMin);
  const isPerfect = matched && modeSince>=pLead;

  const col = mode===0?SUN_FILL:MOON_FILL;

  if(isPerfect){
    const pts=3*comboMul; combo++;
    addScore(pts);
    hitStop = T.hitStopPerfect;
    sfxPerfect();
    burst(g.x,runner.y,col,18,2.5,.5);
    pop(runner.x+42,runner.y-28,'+'+pts+' PERFECT','#FFD54F',17);
  } else if(matched){
    const pts=2*comboMul; combo++;
    addScore(pts);
    sfxMatch();
    burst(g.x,runner.y,col,10,1.5,.4);
    pop(runner.x+42,runner.y-28,'+'+pts,'#ccc',14);
  } else {
    combo=0; comboMul=1; speed*=.92;
    addScore(1);
    sfxWrong();
    burst(g.x,runner.y,'#FF5252',22,3,.5);
    pop(runner.x+42,runner.y-28,'COMBO BREAK!','#FF5252',15);
    shake(5,.15);
  }
}

/* ===== RESET ===== */
function resetGame(){
  score=0; combo=0; comboMul=1;
  speed=T.baseSpeed; spawnTimer=0; spawnInt=T.spawnInterval;
  mode=0; lane=0; modeSince=0; gameTime=0;
  gates=[]; particles=[]; pops=[];
  shakeX=0;shakeY=0;shakeMag=0;shakeT=0;
  hitStop=0;slowMo=0;deathTimer=0;trackScroll=0;
  runner.x=W*T.runnerXFrac; runner.y=laneYs().topCenter; runner.r=18;
  updScoreUI();
}

/* ===== FLIP ===== */
function flipAll(){
  lane = lane===0?1:0;
  mode = mode===0?1:0;
  modeSince = 0;
  sfxFlip();
  burst(runner.x,runner.y, mode===0?SUN_FILL:MOON_FILL, 8,1.5,.3);
}

/* ===== DIE ===== */
function die(){
  state='gameover'; deathTimer=.8; slowMo=T.hitStopDeath;
  shake(12,.4); sfxDeath();
  burst(runner.x,runner.y,HAZARD_COL,30,4,.8);
  burst(runner.x,runner.y,'#fff',15,3,.6);
  if(score>best){ best=score; localStorage.setItem('cd_best',best); }
  updBestUI();
  finalScEl.textContent=score;
  finalBsEl.textContent='Best: '+best;
  setTimeout(()=>overOv.classList.add('active'),500);
}

/* ===== UPDATE ===== */
function updatePlaying(dt){
  if(hitStop>0){ hitStop-=dt; return; }
  const tm = slowMo>0?.3:1;
  const adt = dt*tm;
  if(slowMo>0) slowMo-=dt;

  gameTime += adt;
  modeSince += adt;

  // runner
  const {topCenter,botCenter} = laneYs();
  const ty = lane===0?topCenter:botCenter;
  runner.x = W*T.runnerXFrac;
  runner.y += (ty-runner.y)*Math.min(adt*16,1);
  runner.y += Math.sin(gameTime*3)*3;

  // gates
  for(let i=gates.length-1;i>=0;i--){
    const g=gates[i];
    g.x -= speed*adt;
    if(g.isPulse) g.pPhase+=adt*4;
    if(!g.resolved && g.x+g.w < runner.x) resolveGate(g);
    if(g.x+g.w < -20) gates.splice(i,1);
  }

  // spawn
  spawnTimer -= adt;
  if(spawnTimer<=0){ spawnGate(); spawnTimer=spawnInt; }

  updateFX(adt, dt);
}

function updateFX(adt, dt){
  // particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx*adt; p.y+=p.vy*adt; p.vy+=200*adt; p.life-=adt;
    if(p.life<=0) particles.splice(i,1);
  }
  // pops
  for(let i=pops.length-1;i>=0;i--){
    const t=pops[i]; t.y-=35*adt; t.life-=adt;
    if(t.life<=0) pops.splice(i,1);
  }
  // shake
  if(shakeT>0){
    shakeT-=dt;
    const p=Math.max(shakeT,0);
    shakeX=(Math.random()-.5)*shakeMag*p*10;
    shakeY=(Math.random()-.5)*shakeMag*p*10;
  } else { shakeX=0;shakeY=0; }

  trackScroll = (trackScroll + speed*adt*.3) % 20;
}

/* ===== DRAW ===== */
function drawFrame(){
  ctx.save();
  ctx.translate(shakeX,shakeY);

  // background
  const bR = mode===0?35:15, bG=mode===0?28:18, bB=mode===0?30:46;
  ctx.fillStyle=`rgb(${bR},${bG},${bB})`;
  ctx.fillRect(-20,-20,W+40,H+40);

  // subtle gradient overlay
  const bgGrad = ctx.createLinearGradient(0,0,0,H);
  bgGrad.addColorStop(0,'rgba(255,255,255,.015)');
  bgGrad.addColorStop(.5,'rgba(0,0,0,0)');
  bgGrad.addColorStop(1,'rgba(255,255,255,.01)');
  ctx.fillStyle=bgGrad; ctx.fillRect(0,0,W,H);

  // track lines
  ctx.strokeStyle='rgba(255,255,255,.035)'; ctx.lineWidth=1;
  for(let y=-20;y<H+20;y+=20){
    ctx.beginPath(); ctx.moveTo(0,y+trackScroll); ctx.lineTo(W,y+trackScroll); ctx.stroke();
  }

  // center divider
  const mid=H/2;
  ctx.strokeStyle='rgba(255,255,255,.1)'; ctx.lineWidth=2;
  ctx.setLineDash([8,8]); ctx.beginPath(); ctx.moveTo(0,mid); ctx.lineTo(W,mid); ctx.stroke();
  ctx.setLineDash([]);

  // lane highlights
  const {topCenter,botCenter,laneH} = laneYs();
  const activeY = lane===0?topCenter:botCenter;
  ctx.fillStyle = mode===0?'rgba(255,213,79,.04)':'rgba(144,202,249,.04)';
  ctx.fillRect(0, activeY-laneH/2, W, laneH);

  // gates
  for(const g of gates){
    const pa = g.isPulse ? .4+.6*Math.abs(Math.sin(g.pPhase)) : 1;
    // top
    if(g.hazardSide===0){ drawHazard(g.x,g.topY,g.w,g.gh,pa); }
    else {
      drawGateRect(g.x,g.topY,g.w,g.gh,g.sunOnTop,pa);
      if(g.sunOnTop) drawSunIcon(g.x+g.w/2,g.topY+g.gh/2,10,pa);
      else drawMoonIcon(g.x+g.w/2,g.topY+g.gh/2,10,pa);
    }
    // bottom
    if(g.hazardSide===1){ drawHazard(g.x,g.botY,g.w,g.gh,pa); }
    else {
      drawGateRect(g.x,g.botY,g.w,g.gh,!g.sunOnTop,pa);
      if(!g.sunOnTop) drawSunIcon(g.x+g.w/2,g.botY+g.gh/2,10,pa);
      else drawMoonIcon(g.x+g.w/2,g.botY+g.gh/2,10,pa);
    }
  }

  // runner
  if(state==='playing'||state==='gameover') drawRunner(runner.x,runner.y,runner.r);

  // particles
  for(const p of particles){
    ctx.globalAlpha=p.life/p.ml;
    ctx.fillStyle=p.col;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r*(p.life/p.ml),0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1;

  // text pops
  for(const t of pops){
    ctx.globalAlpha=t.life/t.ml;
    ctx.fillStyle=t.col;
    ctx.font=`bold ${t.sz}px 'Segoe UI',system-ui,sans-serif`;
    ctx.textAlign='center';
    ctx.fillText(t.txt,t.x,t.y);
  }
  ctx.globalAlpha=1;

  ctx.restore();
}

/* ===== MAIN LOOP ===== */
let lastT = 0;

function loop(ts){
  requestAnimationFrame(loop);
  const rawDt = (ts-lastT)/1000;
  lastT = ts;
  const dt = Math.min(rawDt, 0.033);
  if(isNaN(dt)||dt<=0) return;

  // lightweight resize check (dimensions only)
  const r=wrap.getBoundingClientRect();
  if(Math.abs(r.width-W)>1||Math.abs(r.height-H)>1) resize();

  if(state==='playing'){
    updatePlaying(dt);
  } else if(state==='gameover'){
    // keep FX ticking
    if(shakeT>0){
      shakeT-=dt;
      const p=Math.max(shakeT,0);
      shakeX=(Math.random()-.5)*shakeMag*p*10;
      shakeY=(Math.random()-.5)*shakeMag*p*10;
    } else { shakeX=0;shakeY=0; }
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i]; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy+=200*dt; p.life-=dt;
      if(p.life<=0) particles.splice(i,1);
    }
    for(let i=pops.length-1;i>=0;i--){
      const t=pops[i]; t.y-=30*dt; t.life-=dt; if(t.life<=0) pops.splice(i,1);
    }
    gameTime+=dt; trackScroll=(trackScroll+30*dt)%20;
    if(deathTimer>0) deathTimer-=dt;
  }

  drawFrame();
}

/* ===== INPUT ===== */
function handleInput(){
  initAudio();
  if(state==='start'){
    state='playing';
    startOv.classList.remove('active');
    resetGame();
    spawnTimer=.8;
  } else if(state==='playing'){
    flipAll();
  } else if(state==='gameover'&&deathTimer<=0){
    state='start';
    overOv.classList.remove('active');
    startOv.classList.add('active');
  }
}

document.addEventListener('pointerdown', e=>{
  if(e.target===muteBtn||e.target===shareBtn) return;
  handleInput();
});
document.addEventListener('keydown', e=>{
  if(e.code==='Space'||e.code==='Enter'){ e.preventDefault(); handleInput(); }
});

/* ===== SHARE ===== */
shareBtn.addEventListener('click', e=>{
  e.stopPropagation();
  const url=location.origin+location.pathname+'?challenge='+score;
  const txt=`I scored ${score} in Color Dash: Split Decision! Can you beat me?`;
  if(navigator.share){
    navigator.share({title:'Color Dash',text:txt,url}).catch(()=>{});
  } else {
    navigator.clipboard.writeText(txt+' '+url).then(()=>{
      shareBtn.textContent='Copied!';
      setTimeout(()=>{shareBtn.textContent='Share Score';},1500);
    }).catch(()=>{});
  }
});

/* ===== BOOT ===== */
lastT = performance.now();
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
