<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="theme-color" content="#1a1a2e">
<link rel="canonical" href="https://balinti.github.io/color-dash/">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:system-ui,-apple-system,sans-serif;touch-action:none;user-select:none;-webkit-user-select:none}
#wrap{display:flex;justify-content:center;align-items:center;width:100%;height:100%}
canvas{display:block;max-width:420px;max-height:750px;width:100%;height:100%;border-radius:8px}
</style>
</head>
<body>
<div id="wrap"><canvas id="c"></canvas></div>
<script>
'use strict';
// ─── Constants & Utils ───
const PI=Math.PI,TAU=PI*2;
const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
const lerp=(a,b,t)=>a+(b-a)*t;
const rand=(lo=0,hi=1)=>Math.random()*(hi-lo)+lo;
const randInt=(lo,hi)=>Math.floor(rand(lo,hi+1));
const dist=(x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);

// ─── Color Config ───
const COLORS_NORMAL=[
  {name:'Red',   h:'hsl(0,85%,55%)',   hs:'hsl(0,85%,65%)',   icon:'\u2666', pat:'stripe'},
  {name:'Blue',  h:'hsl(215,85%,55%)', hs:'hsl(215,85%,65%)', icon:'\u25C6', pat:'dots'},
  {name:'Yellow',h:'hsl(50,90%,55%)',  hs:'hsl(50,90%,65%)',  icon:'\u2605', pat:'grid'}
];
const COLORS_SOFT=[
  {name:'Rose',  h:'hsl(340,60%,65%)', hs:'hsl(340,60%,75%)', icon:'\u2666', pat:'stripe'},
  {name:'Teal',  h:'hsl(180,50%,55%)', hs:'hsl(180,50%,65%)', icon:'\u25C6', pat:'dots'},
  {name:'Peach', h:'hsl(30,70%,65%)',  hs:'hsl(30,70%,75%)',  icon:'\u2605', pat:'grid'}
];
let colorSoft=false;
let COLORS=COLORS_NORMAL;

// ─── Game Constants ───
const PLAYER_R=14;
const GATE_W=86, GATE_H=18;
const LANE_OFFSET=110;
const HAZARD_W=260, HAZARD_H=16;
const LOCK_DUR=0.60;
const MAX_PARTICLES=300;
const FREEZE_DUR=0.08;
const DRIFT_CLAMP=160;

// ─── Canvas Setup ───
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
let W,H,dpr,playerY;

function resize(){
  const wrap=document.getElementById('wrap');
  const ww=wrap.clientWidth, wh=wrap.clientHeight;
  let cw=Math.min(420,ww), ch=Math.min(750,wh);
  if(ch/cw>750/420) ch=cw*(750/420);
  else cw=ch*(420/750);
  dpr=window.devicePixelRatio||1;
  canvas.style.width=cw+'px';
  canvas.style.height=ch+'px';
  canvas.width=Math.round(cw*dpr);
  canvas.height=Math.round(ch*dpr);
  W=cw; H=ch;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  playerY=H*0.78;
}
window.addEventListener('resize',resize);
resize();

// ─── Game State ───
let state='start'; // start | playing | gameover
let score=0, bestScore=0, multiplier=1, maxMult=1;
let perfectChain=0, bestPerfectChain=0, nearMissCount=0;
let colorIdx=0;
let playerX=0, playerVX=0;
let driftDir=0; // -1 left, 1 right, 0 none
let locked=false, lockTimer=0;
let forks=[], hazards=[];
let particles=[];
let shakeX=0, shakeY=0, shakeDur=0, shakeInt=0;
let freezeTimer=0;
let hue=0;
let lastTime=0;
let challengeTarget=0;

// ─── Load best score ───
try{ bestScore=parseInt(localStorage.getItem('cd_best'))||0; }catch(e){}

// ─── Challenge param ───
try{
  const u=new URLSearchParams(window.location.search);
  const ct=parseInt(u.get('challenge'));
  if(ct>0) challengeTarget=ct;
}catch(e){}

// ─── Formulas ───
const scrollSpeed=()=>clamp(260+score*2.2,260,520);
const forkSpacing=()=>clamp(260-score*0.9,170,260);
const hazardChance=()=>clamp(0.08+score*0.004,0.08,0.32);
const perfectWindow=()=>clamp(46-score*0.15,28,46);
const driftK=()=>18+score*0.06;
const mixedChance=()=>clamp((score-30)*0.01,0,0.35);

// ─── Particle Pool ───
function spawnParticles(x,y,color,count,speed,life){
  for(let i=0;i<count&&particles.length<MAX_PARTICLES;i++){
    const a=rand(0,TAU), sp=rand(speed*0.3,speed);
    particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life,maxLife:life,color,r:rand(2,5)});
  }
}
function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx*dt; p.y+=p.vy*dt;
    p.vy+=200*dt;
    p.life-=dt;
    if(p.life<=0) particles.splice(i,1);
  }
}
function drawParticles(){
  for(const p of particles){
    const a=clamp(p.life/p.maxLife,0,1);
    ctx.globalAlpha=a;
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.r*a,0,TAU);
    ctx.fill();
  }
  ctx.globalAlpha=1;
}

// ─── Screen Shake ───
function triggerShake(intensity,duration){
  shakeInt=intensity; shakeDur=duration;
}
function updateShake(dt){
  if(shakeDur>0){
    shakeDur-=dt;
    shakeX=rand(-shakeInt,shakeInt);
    shakeY=rand(-shakeInt,shakeInt);
  } else { shakeX=0; shakeY=0; }
}

// ─── Draw Patterns ───
function drawPattern(x,y,w,h,pat,color){
  ctx.save();
  ctx.beginPath();
  ctx.rect(x,y,w,h);
  ctx.clip();
  ctx.globalAlpha=0.25;
  ctx.strokeStyle=color;
  ctx.lineWidth=1.5;
  if(pat==='stripe'){
    for(let i=-h;i<w+h;i+=8){
      ctx.beginPath();
      ctx.moveTo(x+i,y);
      ctx.lineTo(x+i-h,y+h);
      ctx.stroke();
    }
  } else if(pat==='dots'){
    for(let dy=3;dy<h;dy+=7){
      for(let dx=3;dx<w;dx+=7){
        ctx.beginPath();
        ctx.arc(x+dx,y+dy,1.5,0,TAU);
        ctx.fill();
      }
    }
  } else if(pat==='grid'){
    for(let i=0;i<w;i+=8){
      ctx.beginPath(); ctx.moveTo(x+i,y); ctx.lineTo(x+i,y+h); ctx.stroke();
    }
    for(let i=0;i<h;i+=8){
      ctx.beginPath(); ctx.moveTo(x,y+i); ctx.lineTo(x+w,y+i); ctx.stroke();
    }
  }
  ctx.globalAlpha=1;
  ctx.restore();
}

// ─── Draw Gate ───
function drawGate(gx,gy,ci,mixed){
  const c=COLORS[ci];
  const gw=GATE_W, gh=GATE_H;
  const rx=gx-gw/2, ry=gy-gh/2;
  // gate body
  ctx.fillStyle=c.h;
  ctx.beginPath();
  const br=6;
  ctx.moveTo(rx+br,ry);
  ctx.lineTo(rx+gw-br,ry);
  ctx.quadraticCurveTo(rx+gw,ry,rx+gw,ry+br);
  ctx.lineTo(rx+gw,ry+gh-br);
  ctx.quadraticCurveTo(rx+gw,ry+gh,rx+gw-br,ry+gh);
  ctx.lineTo(rx+br,ry+gh);
  ctx.quadraticCurveTo(rx,ry+gh,rx,ry+gh-br);
  ctx.lineTo(rx,ry+br);
  ctx.quadraticCurveTo(rx,ry,rx+br,ry);
  ctx.fill();
  // pattern
  drawPattern(rx,ry,gw,gh,c.pat,c.hs);
  // icon
  ctx.fillStyle='rgba(255,255,255,0.9)';
  ctx.font='bold 12px system-ui';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(c.icon,gx,gy+1);
  // mixed indicator
  if(mixed){
    ctx.strokeStyle='rgba(255,255,255,0.6)';
    ctx.lineWidth=1.5;
    ctx.strokeRect(rx+2,ry+2,gw-4,gh-4);
  }
}

// ─── Draw Hazard ───
function drawHazard(hx,hy){
  const hw=HAZARD_W, hh=HAZARD_H;
  const rx=hx-hw/2, ry=hy-hh/2;
  ctx.fillStyle='hsl(0,0%,30%)';
  ctx.fillRect(rx,ry,hw,hh);
  // stripes
  ctx.save();
  ctx.beginPath(); ctx.rect(rx,ry,hw,hh); ctx.clip();
  ctx.strokeStyle='hsl(0,0%,45%)';
  ctx.lineWidth=2;
  for(let i=-hh;i<hw+hh;i+=10){
    ctx.beginPath();
    ctx.moveTo(rx+i,ry);
    ctx.lineTo(rx+i-hh,ry+hh);
    ctx.stroke();
  }
  ctx.restore();
  // warning
  ctx.fillStyle='hsl(45,90%,60%)';
  ctx.font='bold 10px system-ui';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('!',hx,hy+1);
}

// ─── Draw Player ───
function drawPlayer(px,py){
  const c=COLORS[colorIdx];
  // glow
  const grd=ctx.createRadialGradient(px,py,PLAYER_R*0.3,px,py,PLAYER_R*2.5);
  grd.addColorStop(0,c.h.replace(')',',0.4)').replace('hsl','hsla'));
  grd.addColorStop(1,'transparent');
  ctx.fillStyle=grd;
  ctx.beginPath(); ctx.arc(px,py,PLAYER_R*2.5,0,TAU); ctx.fill();
  // orb
  ctx.fillStyle=c.h;
  ctx.beginPath(); ctx.arc(px,py,PLAYER_R,0,TAU); ctx.fill();
  // lighter top
  ctx.fillStyle=c.hs;
  ctx.beginPath(); ctx.arc(px,py-2,PLAYER_R*0.7,0,TAU); ctx.fill();
  // icon
  ctx.fillStyle='rgba(255,255,255,0.95)';
  ctx.font='bold 14px system-ui';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(c.icon,px,py+1);
  // lock ring
  if(locked){
    ctx.strokeStyle='rgba(255,255,255,0.8)';
    ctx.lineWidth=2.5;
    ctx.beginPath(); ctx.arc(px,py,PLAYER_R+4,0,TAU*(lockTimer/LOCK_DUR)); ctx.stroke();
  }
}

// ─── Circle vs Rect Collision ───
function circleRect(cx,cy,cr,rx,ry,rw,rh){
  const nearX=clamp(cx,rx,rx+rw);
  const nearY=clamp(cy,ry,ry+rh);
  return dist(cx,cy,nearX,nearY)<cr;
}

// ─── Spawn Forks ───
function spawnFork(y){
  const cx=W/2;
  let c1=randInt(0,2), c2=randInt(0,2);
  while(c2===c1) c2=randInt(0,2);
  const mixed=Math.random()<mixedChance();
  // Randomize left/right assignment
  const leftC=Math.random()<0.5?c1:c2;
  const rightC=leftC===c1?c2:c1;
  forks.push({
    y, leftC, rightC, mixed,
    leftX:cx-LANE_OFFSET, rightX:cx+LANE_OFFSET,
    passed:false
  });
}

function spawnHazard(y){
  hazards.push({y, x:W/2, passed:false});
}

// ─── Init / Reset ───
function initGame(){
  score=0; multiplier=1; maxMult=1;
  perfectChain=0; bestPerfectChain=0; nearMissCount=0;
  colorIdx=0;
  playerX=W/2; playerVX=0;
  driftDir=0;
  locked=false; lockTimer=0;
  forks=[]; hazards=[]; particles=[];
  shakeX=0; shakeY=0; shakeDur=0;
  freezeTimer=0;
  // Pre-spawn some forks
  let y=playerY-forkSpacing();
  for(let i=0;i<6;i++){
    spawnFork(y);
    if(Math.random()<hazardChance()){
      spawnHazard(y-forkSpacing()*0.5);
    }
    y-=forkSpacing();
  }
}

// ─── Determine Drift Direction ───
function updateDrift(){
  // Find next fork ahead of player
  let nextFork=null, minDist=Infinity;
  for(const f of forks){
    if(!f.passed && f.y<playerY){
      const d=playerY-f.y;
      if(d<minDist){ minDist=d; nextFork=f; }
    }
  }
  if(!nextFork){
    driftDir=0;
    return;
  }
  // Which gate matches current color?
  if(nextFork.leftC===colorIdx){
    driftDir=-1; // drift left
  } else if(nextFork.rightC===colorIdx){
    driftDir=1; // drift right
  } else {
    driftDir=0; // neither matches, neutral
  }
}

// ─── Input ───
function handleTap(){
  if(state==='start'){
    state='playing';
    initGame();
    lastTime=performance.now();
    return;
  }
  if(state==='gameover'){
    state='start';
    return;
  }
  if(state==='playing'){
    if(locked) return; // can't switch during lock
    // Cycle color
    colorIdx=(colorIdx+1)%3;
    // Check for perfect window
    let isPerfect=false;
    for(const f of forks){
      if(!f.passed){
        const d=Math.abs(f.y-playerY);
        if(d<perfectWindow()){
          isPerfect=true;
          break;
        }
      }
    }
    if(isPerfect){
      locked=true;
      lockTimer=LOCK_DUR;
      perfectChain++;
      if(perfectChain>bestPerfectChain) bestPerfectChain=perfectChain;
      multiplier=clamp(1+Math.floor(perfectChain/2),1,4);
      if(multiplier>maxMult) maxMult=multiplier;
      spawnParticles(playerX,playerY,'hsl(50,100%,70%)',15,180,0.6);
      triggerShake(3,0.15);
    }
  }
}

// ─── Color-Soft Toggle (start screen) ───
let softBtnRect={x:0,y:0,w:0,h:0};

function pointerToCanvas(e){
  const rect=canvas.getBoundingClientRect();
  return {x:(e.clientX-rect.left)*(W/rect.width), y:(e.clientY-rect.top)*(H/rect.height)};
}

canvas.addEventListener('pointerdown',e=>{
  e.preventDefault();
  // Check soft toggle first on start screen
  if(state==='start'){
    const m=pointerToCanvas(e);
    if(m.x>=softBtnRect.x&&m.x<=softBtnRect.x+softBtnRect.w&&m.y>=softBtnRect.y&&m.y<=softBtnRect.y+softBtnRect.h){
      colorSoft=!colorSoft;
      COLORS=colorSoft?COLORS_SOFT:COLORS_NORMAL;
      return;
    }
  }
  handleTap();
});
window.addEventListener('keydown',e=>{
  if(e.code==='Space'||e.code==='Enter'){
    e.preventDefault();
    handleTap();
  }
});

// ─── Game Over ───
function gameOver(){
  state='gameover';
  freezeTimer=FREEZE_DUR;
  triggerShake(8,0.4);
  spawnParticles(playerX,playerY,'hsl(0,80%,60%)',40,250,0.8);
  if(score>bestScore){
    bestScore=score;
    try{ localStorage.setItem('cd_best',bestScore); }catch(e){}
  }
}

// ─── Share ───
let shareBtnRect={x:0,y:0,w:0,h:0};
let challengeBtnRect={x:0,y:0,w:0,h:0};
function tryShare(){
  const text=`I scored ${score} in Color Dash! Can you beat me?\nhttps://balinti.github.io/color-dash/?challenge=${score}`;
  if(navigator.share){
    navigator.share({title:'Color Dash',text}).catch(()=>{});
  } else {
    navigator.clipboard.writeText(text).catch(()=>{});
  }
}
function tryChallenge(){
  const url=`https://balinti.github.io/color-dash/?challenge=${score}`;
  if(navigator.share){
    navigator.share({title:'Color Dash Challenge',text:`Beat my score of ${score}!`,url}).catch(()=>{});
  } else {
    navigator.clipboard.writeText(url).catch(()=>{});
  }
}

canvas.addEventListener('pointerup',e=>{
  if(state!=='gameover') return;
  const m=pointerToCanvas(e);
  if(m.x>=shareBtnRect.x&&m.x<=shareBtnRect.x+shareBtnRect.w&&m.y>=shareBtnRect.y&&m.y<=shareBtnRect.y+shareBtnRect.h){
    tryShare();
    return;
  }
  if(m.x>=challengeBtnRect.x&&m.x<=challengeBtnRect.x+challengeBtnRect.w&&m.y>=challengeBtnRect.y&&m.y<=challengeBtnRect.y+challengeBtnRect.h){
    tryChallenge();
    e.stopPropagation();
  }
});

// ─── Update ───
function update(dt){
  if(freezeTimer>0){ freezeTimer-=dt; return; }
  hue=(hue+30*dt)%360;
  updateShake(dt);
  updateParticles(dt);
  if(state!=='playing') return;

  const spd=scrollSpeed();
  const dk=driftK();

  // Lock timer
  if(locked){
    lockTimer-=dt;
    if(lockTimer<=0){ locked=false; lockTimer=0; perfectChain=0; multiplier=1; }
  }

  // Update drift direction
  updateDrift();

  // Drift physics
  const targetX=W/2+driftDir*LANE_OFFSET;
  const accel=(targetX-playerX)*dk;
  playerVX=lerp(playerVX,accel,1-Math.exp(-10*dt));
  playerX+=playerVX*dt;
  playerX=clamp(playerX,W/2-DRIFT_CLAMP,W/2+DRIFT_CLAMP);

  // Scroll forks & hazards
  for(const f of forks) f.y+=spd*dt;
  for(const h of hazards) h.y+=spd*dt;

  // Fork pass resolution
  for(const f of forks){
    if(f.passed) continue;
    if(f.y>=playerY){
      f.passed=true;
      // Determine which gate player is near
      const dLeft=Math.abs(playerX-f.leftX);
      const dRight=Math.abs(playerX-f.rightX);
      const nearGate=dLeft<dRight?'left':'right';
      const gateC=nearGate==='left'?f.leftC:f.rightC;
      const otherC=nearGate==='left'?f.rightC:f.leftC;
      const nearDist=Math.min(dLeft,dRight);
      const farDist=Math.max(dLeft,dRight);

      // Check if between gates (missed both)
      if(dLeft>GATE_W*0.8&&dRight>GATE_W*0.8){
        if(!locked){
          gameOver();
          return;
        }
      }

      // Check if matching color
      if(gateC===colorIdx||locked){
        // Pass through - score!
        score+=multiplier;
        const gateX=nearGate==='left'?f.leftX:f.rightX;
        spawnParticles(gateX,f.y,COLORS[gateC].h,8,120,0.4);

        // Near-miss bonus: close to wrong gate
        const wrongDist=nearGate==='left'?dRight:dLeft;
        if(wrongDist<GATE_W*0.7){
          nearMissCount++;
          score+=1;
          triggerShake(4,0.12);
          spawnParticles(playerX,playerY,'hsl(180,80%,70%)',6,100,0.3);
        }
      } else {
        // Wrong color
        if(f.mixed&&!locked){
          gameOver();
          return;
        }
        // Non-mixed wrong color: still pass but no score for matching
        score+=1; // base pass
      }
    }
  }

  // Hazard collision
  for(const h of hazards){
    if(h.passed) continue;
    if(h.y>=playerY-PLAYER_R&&h.y<=playerY+PLAYER_R){
      if(circleRect(playerX,playerY,PLAYER_R,h.x-HAZARD_W/2,h.y-HAZARD_H/2,HAZARD_W,HAZARD_H)){
        h.passed=true;
        gameOver();
        return;
      }
    }
    if(h.y>playerY+PLAYER_R) h.passed=true;
  }

  // Remove off-screen
  forks=forks.filter(f=>f.y<H+50);
  hazards=hazards.filter(h=>h.y<H+50);

  // Spawn new forks
  let topForkY=Infinity;
  for(const f of forks) if(f.y<topForkY) topForkY=f.y;
  while(topForkY>-100){
    topForkY-=forkSpacing();
    spawnFork(topForkY);
    if(Math.random()<hazardChance()){
      spawnHazard(topForkY+forkSpacing()*0.4);
    }
  }
}

// ─── Render ───
function render(){
  ctx.save();
  ctx.translate(shakeX,shakeY);

  // Background gradient
  const bg=ctx.createLinearGradient(0,0,0,H);
  bg.addColorStop(0,`hsl(${240+hue*0.1},30%,8%)`);
  bg.addColorStop(1,`hsl(${260+hue*0.1},25%,12%)`);
  ctx.fillStyle=bg;
  ctx.fillRect(-10,-10,W+20,H+20);

  // Lane guide lines
  ctx.strokeStyle='rgba(255,255,255,0.04)';
  ctx.lineWidth=1;
  ctx.setLineDash([4,8]);
  ctx.beginPath();
  ctx.moveTo(W/2-LANE_OFFSET,0); ctx.lineTo(W/2-LANE_OFFSET,H);
  ctx.moveTo(W/2+LANE_OFFSET,0); ctx.lineTo(W/2+LANE_OFFSET,H);
  ctx.moveTo(W/2,0); ctx.lineTo(W/2,H);
  ctx.stroke();
  ctx.setLineDash([]);

  if(state==='playing'||state==='gameover'){
    // Hazards
    for(const h of hazards) drawHazard(h.x,h.y);
    // Forks (gates)
    for(const f of forks){
      drawGate(f.leftX,f.y,f.leftC,f.mixed);
      drawGate(f.rightX,f.y,f.rightC,f.mixed);
      // Connector line
      ctx.strokeStyle='rgba(255,255,255,0.08)';
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(f.leftX+GATE_W/2,f.y);
      ctx.lineTo(f.rightX-GATE_W/2,f.y);
      ctx.stroke();
    }
    // Player
    drawPlayer(playerX,playerY);
    // Particles
    drawParticles();
    // HUD
    drawHUD();
  }

  if(state==='start') drawStartScreen();
  if(state==='gameover') drawGameOver();

  ctx.restore();
}

// ─── HUD ───
function drawHUD(){
  // Score
  ctx.fillStyle='rgba(255,255,255,0.9)';
  ctx.font='bold 28px system-ui';
  ctx.textAlign='center'; ctx.textBaseline='top';
  ctx.fillText(score,W/2,16);
  // Multiplier
  if(multiplier>1){
    ctx.fillStyle='hsl(50,100%,70%)';
    ctx.font='bold 16px system-ui';
    ctx.fillText(`x${multiplier}`,W/2,48);
  }
  // Lock indicator
  if(locked){
    ctx.fillStyle='rgba(255,255,255,0.6)';
    ctx.font='12px system-ui';
    ctx.fillText('LOCKED',W/2,68);
  }
  // Color indicator (top-right)
  const c=COLORS[colorIdx];
  ctx.fillStyle=c.h;
  ctx.beginPath(); ctx.arc(W-24,24,10,0,TAU); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.9)';
  ctx.font='10px system-ui';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(c.icon,W-24,25);
}

// ─── Start Screen ───
function drawStartScreen(){
  // Overlay
  ctx.fillStyle='rgba(0,0,0,0.3)';
  ctx.fillRect(0,0,W,H);

  const cx=W/2;

  // Title
  ctx.fillStyle=`hsl(${hue},70%,65%)`;
  ctx.font='bold 38px system-ui';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('Color Dash',cx,H*0.22);

  // Subtitle
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.font='14px system-ui';
  ctx.fillText('Drift & Lock',cx,H*0.28);

  // Color previews
  const previewY=H*0.36;
  for(let i=0;i<3;i++){
    const px=cx+(i-1)*50;
    ctx.fillStyle=COLORS[i].h;
    ctx.beginPath(); ctx.arc(px,previewY,14,0,TAU); ctx.fill();
    ctx.fillStyle='rgba(255,255,255,0.9)';
    ctx.font='bold 12px system-ui';
    ctx.fillText(COLORS[i].icon,px,previewY+1);
  }

  // How to play
  ctx.fillStyle='rgba(255,255,255,0.6)';
  ctx.font='13px system-ui';
  ctx.fillText('Tap to cycle color & flip drift',cx,H*0.46);
  ctx.fillText('Match gate colors to pass through',cx,H*0.50);
  ctx.fillText('Time taps perfectly to LOCK & chain!',cx,H*0.54);

  // Best score
  if(bestScore>0){
    ctx.fillStyle='rgba(255,255,255,0.4)';
    ctx.font='13px system-ui';
    ctx.fillText(`Best: ${bestScore}`,cx,H*0.61);
  }

  // Challenge target
  if(challengeTarget>0){
    ctx.fillStyle='hsl(50,100%,65%)';
    ctx.font='bold 15px system-ui';
    ctx.fillText(`Challenge: Beat ${challengeTarget}!`,cx,H*0.66);
  }

  // Tap to start
  const pulse=0.7+0.3*Math.sin(performance.now()*0.004);
  ctx.fillStyle=`rgba(255,255,255,${pulse})`;
  ctx.font='bold 18px system-ui';
  ctx.fillText('Tap to Start',cx,H*0.75);

  // Color-Soft toggle
  const bw=130, bh=30;
  const bx=cx-bw/2, by=H*0.85;
  softBtnRect={x:bx,y:by,w:bw,h:bh};
  ctx.fillStyle=colorSoft?'rgba(100,200,180,0.3)':'rgba(255,255,255,0.1)';
  ctx.beginPath();
  const br=8;
  ctx.moveTo(bx+br,by);
  ctx.lineTo(bx+bw-br,by);
  ctx.quadraticCurveTo(bx+bw,by,bx+bw,by+br);
  ctx.lineTo(bx+bw,by+bh-br);
  ctx.quadraticCurveTo(bx+bw,by+bh,bx+bw-br,by+bh);
  ctx.lineTo(bx+br,by+bh);
  ctx.quadraticCurveTo(bx,by+bh,bx,by+bh-br);
  ctx.lineTo(bx,by+br);
  ctx.quadraticCurveTo(bx,by,bx+br,by);
  ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.7)';
  ctx.font='12px system-ui';
  ctx.fillText(colorSoft?'Color-Soft: ON':'Color-Soft: OFF',cx,by+bh/2+1);
}

// ─── Game Over Screen ───
function drawGameOver(){
  ctx.fillStyle='rgba(0,0,0,0.5)';
  ctx.fillRect(0,0,W,H);

  const cx=W/2;

  ctx.fillStyle='hsl(0,70%,60%)';
  ctx.font='bold 32px system-ui';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('Game Over',cx,H*0.18);

  // Score
  ctx.fillStyle='rgba(255,255,255,0.9)';
  ctx.font='bold 48px system-ui';
  ctx.fillText(score,cx,H*0.28);

  ctx.font='14px system-ui';
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.fillText('SCORE',cx,H*0.34);

  // Best
  ctx.fillStyle=score>=bestScore?'hsl(50,100%,65%)':'rgba(255,255,255,0.7)';
  ctx.font='bold 18px system-ui';
  ctx.fillText(`Best: ${bestScore}`,cx,H*0.40);

  // Stats
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.font='13px system-ui';
  ctx.fillText(`Max Multiplier: x${maxMult}`,cx,H*0.48);
  ctx.fillText(`Perfect Chain: ${bestPerfectChain}`,cx,H*0.52);
  ctx.fillText(`Near-Miss Bonus: ${nearMissCount}`,cx,H*0.56);

  // Challenge result
  if(challengeTarget>0){
    if(score>=challengeTarget){
      ctx.fillStyle='hsl(120,70%,60%)';
      ctx.font='bold 16px system-ui';
      ctx.fillText('Challenge Beaten!',cx,H*0.62);
    } else {
      ctx.fillStyle='hsl(0,70%,60%)';
      ctx.font='bold 16px system-ui';
      ctx.fillText(`Need ${challengeTarget-score} more to beat challenge`,cx,H*0.62);
    }
  }

  // Share button
  const sbw=110, sbh=34;
  const sbx=cx-sbw-8, sby=H*0.70;
  shareBtnRect={x:sbx,y:sby,w:sbw,h:sbh};
  ctx.fillStyle='rgba(60,130,240,0.7)';
  roundRect(ctx,sbx,sby,sbw,sbh,8);
  ctx.fill();
  ctx.fillStyle='#fff';
  ctx.font='bold 13px system-ui';
  ctx.fillText('Share Score',sbx+sbw/2,sby+sbh/2+1);

  // Challenge button
  const cbx=cx+8, cby=H*0.70;
  challengeBtnRect={x:cbx,y:cby,w:sbw,h:sbh};
  ctx.fillStyle='rgba(240,160,40,0.7)';
  roundRect(ctx,cbx,cby,sbw,sbh,8);
  ctx.fill();
  ctx.fillStyle='#fff';
  ctx.font='bold 13px system-ui';
  ctx.fillText('Challenge',cbx+sbw/2,cby+sbh/2+1);

  // Tap to retry
  const pulse=0.6+0.4*Math.sin(performance.now()*0.004);
  ctx.fillStyle=`rgba(255,255,255,${pulse})`;
  ctx.font='bold 16px system-ui';
  ctx.fillText('Tap to Retry',cx,H*0.84);
}

function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

// ─── Main Loop ───
function loop(ts){
  const dt=Math.min((ts-(lastTime||ts))/1000,0.05);
  lastTime=ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
