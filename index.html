<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#1a1a2e">

<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Run through color gates matching your current color. Tap to switch colors and dash between lanes. How far can you streak?">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og-image.jpg">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Run through color gates matching your current color. Tap to switch colors and dash between lanes.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og-image.jpg">

<link rel="canonical" href="https://balinti.github.io/color-dash/">
<link rel="preconnect" href="https://pagead2.googlesyndication.com">
<link rel="preconnect" href="https://googleads.g.doubleclick.net">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>

<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow-x:hidden;background:#0a0a1a;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#ccc}
#game-wrap{width:100%;max-width:420px;margin:0 auto;display:flex;flex-direction:column;align-items:center;padding:0}
canvas{display:block;width:100%;max-width:420px;aspect-ratio:420/750;touch-action:none;border-radius:4px}
.about{max-width:420px;margin:24px auto;padding:0 16px;font-size:14px;line-height:1.6;color:#888}
.about h2{color:#aaa;font-size:16px;margin-bottom:8px}
.about p{margin-bottom:10px}
.footer{max-width:420px;margin:0 auto 32px;padding:0 16px;display:flex;gap:16px;font-size:13px}
.footer a,.footer button{color:#668;background:none;border:none;cursor:pointer;text-decoration:underline;font-size:13px;font-family:inherit;padding:0}
.footer a:hover,.footer button:hover{color:#99b}
#privacy-modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:100;justify-content:center;align-items:center}
#privacy-modal.show{display:flex}
#privacy-modal .inner{background:#1a1a2e;padding:24px;border-radius:8px;max-width:400px;width:90%;max-height:80vh;overflow-y:auto;color:#aaa;font-size:13px;line-height:1.6}
#privacy-modal .inner h3{color:#ccc;margin-bottom:12px}
#privacy-modal .close-btn{margin-top:16px;background:#333;color:#ccc;border:none;padding:8px 20px;border-radius:4px;cursor:pointer;font-size:13px}
</style>
</head>
<body>
<div id="game-wrap">
<canvas id="gc"></canvas>
</div>

<section class="about">
<h2>About Color Dash</h2>
<p>Color Dash is a fast-paced <strong>endless runner</strong> browser game built entirely in HTML5 Canvas. With simple <strong>one tap</strong> controls, you dash between two lanes while cycling through colors to match incoming gates. It is a true <strong>color matching</strong> challenge that tests your reflexes and timing.</p>
<p>Each tap performs <strong>lane switching</strong> and a color change simultaneously, creating a satisfying rhythm as you streak through gate after gate. Build up your streak multiplier for massive scores, trigger Overdrive mode for bonus points, and chase the elusive gold gates for huge rewards. The difficulty ramps smoothly as your score grows.</p>
<p>Play this free <strong>browser game</strong> on any device with no downloads or installs. Just tap and dash. Challenge your friends by sharing your high score directly from the game over screen. How long can you keep your streak alive?</p>
</section>

<div class="footer">
<button id="privacy-btn">Privacy</button>
<a href="https://github.com/Balinti/color-dash" target="_blank" rel="noopener">GitHub</a>
</div>

<div id="privacy-modal">
<div class="inner">
<h3>Privacy Policy</h3>
<p>Color Dash is a client-side browser game. We do not collect, store, or transmit any personal data. Your high score is saved locally in your browser using localStorage and never leaves your device.</p>
<p>This site uses Google AdSense, which may use cookies and collect anonymized usage data according to Google's privacy policy. No other third-party tracking or analytics services are used.</p>
<p>By playing this game, you consent to the use of localStorage for saving game progress and to Google AdSense's standard data practices.</p>
<button class="close-btn" id="close-privacy">Close</button>
</div>
</div>

<script>
'use strict';
// Privacy modal
document.getElementById('privacy-btn').onclick=()=>document.getElementById('privacy-modal').classList.add('show');
document.getElementById('close-privacy').onclick=()=>document.getElementById('privacy-modal').classList.remove('show');
document.getElementById('privacy-modal').onclick=e=>{if(e.target===e.currentTarget)e.currentTarget.classList.remove('show')};

// ==================== GAME ====================
const canvas=document.getElementById('gc');
const ctx=canvas.getContext('2d');

// Base coordinate system
const BASE_W=420, BASE_H=750;
const CX=210, LANE_DX=78;
const LEFT_X=132, RIGHT_X=288;
const RUNNER_Y=610, RUNNER_R=16;
const CHECK_Y=560;
const GATE_H=64, GATE_W=132;

// High-DPI canvas scaling (cap DPR at 3 for perf)
const DPR=Math.min(window.devicePixelRatio||1, 3);
canvas.width=BASE_W*DPR;
canvas.height=BASE_H*DPR;
ctx.scale(DPR,DPR);

// ==================== COLORS ====================
const COLORS=[
  {h:205, s:92, l:58, icon:0},  // blue - dot
  {h:320, s:90, l:60, icon:1},  // pink - stripes
  {h:120, s:85, l:52, icon:2}   // green - triangle
];
const GOLD={h:48, s:95, l:60};

function hsl(c, a){ return `hsla(${c.h},${c.s}%,${c.l}%,${a===undefined?1:a})` }
function hslShift(c, lOff, a){ return `hsla(${c.h},${c.s}%,${Math.max(0,Math.min(100,c.l+lOff))}%,${a===undefined?1:a})` }

// ==================== AUDIO ====================
let audioCtx=null, muted=false;
function initAudio(){
  if(!audioCtx) audioCtx=new(window.AudioContext||window.webkitAudioContext)();
  if(audioCtx.state==='suspended') audioCtx.resume();
}
function beep(freq, dur, vol){
  if(muted||!audioCtx) return;
  try{
    const o=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    o.frequency.value=freq; o.type='sine';
    g.gain.setValueAtTime(vol||0.08, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime+(dur||0.1));
    o.start(); o.stop(audioCtx.currentTime+(dur||0.1));
  }catch(e){}
}

// ==================== PERSISTENCE ====================
const LS_HIGH='cdss_highScore', LS_STREAK='cdss_bestStreak';
function getHigh(){ return parseInt(localStorage.getItem(LS_HIGH))||0 }
function setHigh(v){ localStorage.setItem(LS_HIGH, String(v)) }
function getBestStreak(){ return parseInt(localStorage.getItem(LS_STREAK))||0 }
function setBestStreak(v){ localStorage.setItem(LS_STREAK, String(v)) }

// ==================== CHALLENGE PARAM ====================
let challengeScore=0;
try{
  const u=new URL(window.location.href);
  const c=u.searchParams.get('challenge');
  if(c) challengeScore=parseInt(c)||0;
}catch(e){}

// ==================== GAME STATE ====================
let state='start';
let score=0, streak=0, bestStreak=0, nearMisses=0;
let highScore=getHigh(), savedBestStreak=getBestStreak();
let paletteCount=2;
let overdriveTimer=0;
let shakeMag=0;
let gameTime=0;
let spawnTimer=0;
let doubleBeatNext=false;
let shareFlash=0; // feedback timer for clipboard copy

// Runner object
const runner={
  x: LEFT_X, vx: 0, lane: 0,
  colorIndex: 0,
  bufferedTapAt: 0,
  trailAcc: 0
};

// Gate & particle arrays
let gates=[];
let particles=[];

// ==================== HELPERS ====================
function rng(a,b){ return a+Math.random()*(b-a) }
function clamp(v,lo,hi){ return v<lo?lo:v>hi?hi:v }

function getSpeed(){ return 320+2.2*score+38*Math.log2(1+score/12) }
function getSpawnDt(){ return clamp(0.95-0.0045*score, 0.42, 0.95) }
function getGoldChance(){ return clamp(0.06+0.002*score, 0.06, 0.18) }
function getDoubleBeatChance(){ return clamp((score-60)/80, 0, 0.35) }
function getRepeatChance(){ return clamp((score-30)/60, 0, 0.25) }

// ==================== GATE SPAWNING ====================
function spawnGate(){
  paletteCount = (score<10) ? 2 : 3;
  let lc = Math.floor(Math.random()*paletteCount);
  let rc = Math.floor(Math.random()*paletteCount);
  // Repeat chance: same color both lanes
  if(Math.random() < getRepeatChance()) rc = lc;
  let lg=false, rg=false;
  const canGold = streak>=4 && score>=12;
  if(canGold){
    if(Math.random() < getGoldChance()){
      if(Math.random()<0.5) lg=true; else rg=true;
    }
  }
  gates.push({
    y: -GATE_H-20,
    leftColor: lc, rightColor: rc,
    leftGold: lg, rightGold: rg,
    scored: false, pulse: 0
  });
}

// ==================== PARTICLES ====================
function spawnParticle(x, y, vx, vy, life, color, size, grav){
  if(particles.length > 700) return;
  particles.push({x, y, vx, vy, life, maxLife:life, color, size:size||3, grav:grav||0});
}

function burstPerfect(x, y, col){
  for(let i=0; i<18; i++){
    const a=rng(0, Math.PI*2);
    const sp=rng(140, 400);
    spawnParticle(x, y, Math.cos(a)*sp, Math.sin(a)*sp - 80, rng(0.3,0.6), col, rng(2,5));
  }
}

function burstGold(x, y){
  for(let i=0; i<30; i++){
    const a=rng(0, Math.PI*2);
    const sp=rng(200, 500);
    spawnParticle(x, y, Math.cos(a)*sp, Math.sin(a)*sp - 100, rng(0.4,0.8), hsl(GOLD), rng(3,7));
  }
  // Shockwave ring particles
  for(let i=0; i<24; i++){
    const a=i/24*Math.PI*2;
    spawnParticle(x, y, Math.cos(a)*350, Math.sin(a)*350, 0.35, 'rgba(255,240,100,0.7)', rng(2,4));
  }
}

function burstCrash(x, y, col){
  for(let i=0; i<46; i++){
    const a=rng(0, Math.PI*2);
    const sp=rng(220, 520);
    spawnParticle(x, y, Math.cos(a)*sp, Math.sin(a)*sp, 0.7, col, rng(2,6), 900);
  }
}

function spawnTrail(x, y, col){
  spawnParticle(x+rng(-6,6), y+rng(-2,4), rng(-20,20), rng(30,80), rng(0.2,0.5), col, rng(1.5,3.5));
}

// ==================== GAME ACTIONS ====================
function doAction(){
  if(state==='start'){
    startGame(); return;
  }
  if(state==='gameover'){
    startGame(); return;
  }
  // Playing: switch color + dash to other lane
  runner.colorIndex = (runner.colorIndex+1) % paletteCount;
  runner.lane = runner.lane===0 ? 1 : 0;
  runner.bufferedTapAt = performance.now();
  beep(440+runner.colorIndex*120, 0.06, 0.06);
}

function startGame(){
  initAudio();
  state='playing';
  score=0; streak=0; bestStreak=0; nearMisses=0;
  overdriveTimer=0; shakeMag=0; gameTime=0; spawnTimer=0;
  paletteCount=2; doubleBeatNext=false; shareFlash=0;
  runner.x=LEFT_X; runner.vx=0; runner.lane=0;
  runner.colorIndex=0; runner.bufferedTapAt=0; runner.trailAcc=0;
  gates=[]; particles=[];
  highScore=getHigh(); savedBestStreak=getBestStreak();
}

function endGame(){
  state='gameover';
  shakeMag=12;
  burstCrash(runner.x, RUNNER_Y, hsl(COLORS[runner.colorIndex]));
  beep(120, 0.3, 0.1);
  if(score > highScore){ highScore=Math.floor(score); setHigh(highScore) }
  if(bestStreak > savedBestStreak){ savedBestStreak=bestStreak; setBestStreak(savedBestStreak) }
}

// ==================== UPDATE ====================
function update(dt){
  if(state!=='playing') return;
  gameTime += dt;

  // Runner spring physics
  const tx = runner.lane===0 ? LEFT_X : RIGHT_X;
  const ax = (tx - runner.x)*90 - runner.vx*18;
  runner.vx += ax*dt;
  runner.vx = clamp(runner.vx, -1600, 1600);
  runner.x += runner.vx*dt;

  // Overdrive timer + score drip
  if(overdriveTimer > 0){
    overdriveTimer -= dt;
    score += dt*2.5;
    if(overdriveTimer <= 0) overdriveTimer=0;
  }

  // Spawn gates
  const spDt = doubleBeatNext ? getSpawnDt()*0.55 : getSpawnDt();
  spawnTimer -= dt;
  if(spawnTimer <= 0){
    spawnGate();
    spawnTimer = spDt;
    if(doubleBeatNext) doubleBeatNext=false;
    else if(Math.random() < getDoubleBeatChance()) doubleBeatNext=true;
  }

  // Move and evaluate gates
  const speed = getSpeed();
  for(let i=gates.length-1; i>=0; i--){
    const g = gates[i];
    g.y += speed*dt;
    g.pulse += dt*4;

    // Evaluate when gate bottom crosses check line (exactly once)
    if(!g.scored && g.y+GATE_H >= CHECK_Y){
      g.scored = true;
      const panel = runner.lane===0 ? 'left' : 'right';
      const isGold = panel==='left' ? g.leftGold : g.rightGold;
      const gateColor = panel==='left' ? g.leftColor : g.rightColor;
      const pass = isGold || (gateColor === runner.colorIndex);

      const dy = Math.abs((g.y+GATE_H) - CHECK_Y);
      const nowMs = performance.now();
      const buffered = (nowMs - runner.bufferedTapAt) <= 120;

      if(!pass){
        endGame();
        return;
      }

      const perfect = dy <= 6;
      const lateCorrect = !perfect && dy <= 18;

      if(perfect){
        const mult = 1 + Math.floor(streak/3);
        streak++;
        if(streak > bestStreak) bestStreak=streak;
        score += 1*mult;
        shakeMag += 2.5;
        burstPerfect(runner.x, CHECK_Y, hsl(COLORS[runner.colorIndex]));
        beep(660, 0.08, 0.05);
        // Gold bonus
        if(isGold && buffered){
          score += 5*mult;
          shakeMag += 6;
          burstGold(runner.x, CHECK_Y);
          beep(880, 0.12, 0.07);
        }
        // Overdrive check
        if(streak > 0 && streak%3 === 0){
          overdriveTimer = 2.0;
          beep(990, 0.15, 0.06);
        }
      } else if(lateCorrect){
        nearMisses++;
        streak=0;
        score+=1;
        beep(330, 0.06, 0.04);
      } else {
        // Normal pass (not close enough for perfect or late-correct)
        const mult = 1 + Math.floor(streak/3);
        streak++;
        if(streak > bestStreak) bestStreak=streak;
        score += 1*mult;
        burstPerfect(runner.x, CHECK_Y, hsl(COLORS[runner.colorIndex]));
        if(isGold && buffered){
          score += 5*mult;
          shakeMag += 6;
          burstGold(runner.x, CHECK_Y);
        }
        if(streak > 0 && streak%3 === 0) overdriveTimer = 2.0;
        beep(550, 0.06, 0.04);
      }
    }

    // Remove off-screen gates
    if(g.y > BASE_H+100) gates.splice(i, 1);
  }

  // Trail particles
  const trailRate = overdriveTimer>0 ? 70 : 28;
  runner.trailAcc += dt*trailRate;
  while(runner.trailAcc >= 1){
    runner.trailAcc--;
    spawnTrail(runner.x, RUNNER_Y+RUNNER_R, hsl(COLORS[runner.colorIndex], 0.6));
  }

  // Update particles
  for(let i=particles.length-1; i>=0; i--){
    const p = particles[i];
    p.life -= dt;
    if(p.life <= 0){ particles.splice(i, 1); continue }
    p.x += p.vx*dt;
    p.y += p.vy*dt;
    if(p.grav) p.vy += p.grav*dt;
    p.vx *= Math.pow(0.3, dt); // drag
    p.vy *= Math.pow(0.3, dt);
  }

  // Shake decay
  if(shakeMag > 0){
    shakeMag *= Math.pow(0.02, dt);
    if(shakeMag < 0.3) shakeMag=0;
  }
}

// ==================== DRAWING ====================
function drawIcon(cx, cy, type, size, color){
  ctx.fillStyle=color;
  ctx.strokeStyle=color;
  ctx.lineWidth=2;
  if(type===0){
    // Dot
    ctx.beginPath();
    ctx.arc(cx, cy, size*0.35, 0, Math.PI*2);
    ctx.fill();
  } else if(type===1){
    // Stripes
    const w=size*0.5;
    for(let i=-1; i<=1; i++){
      ctx.fillRect(cx + i*w*0.4 - 1.5, cy - size*0.35, 3, size*0.7);
    }
  } else {
    // Triangle
    const s=size*0.4;
    ctx.beginPath();
    ctx.moveTo(cx, cy-s);
    ctx.lineTo(cx-s*0.9, cy+s*0.6);
    ctx.lineTo(cx+s*0.9, cy+s*0.6);
    ctx.closePath();
    ctx.stroke();
  }
}

function drawGate(g, side, x){
  const isGold = side==='left' ? g.leftGold : g.rightGold;
  const colorIdx = side==='left' ? g.leftColor : g.rightColor;
  const col = isGold ? GOLD : COLORS[colorIdx];

  const gx = x - GATE_W/2;
  const gy = g.y;
  const pulseA = 0.12 + 0.05*Math.sin(g.pulse);

  // Outer glow
  ctx.fillStyle = hslShift(col, 10, pulseA);
  ctx.fillRect(gx-4, gy-4, GATE_W+8, GATE_H+8);

  // Body
  ctx.fillStyle = hslShift(col, -10, 0.85);
  ctx.fillRect(gx, gy, GATE_W, GATE_H);

  // Inner gradient
  const grd = ctx.createLinearGradient(gx, gy, gx, gy+GATE_H);
  grd.addColorStop(0, hslShift(col, 15, 0.3));
  grd.addColorStop(1, hslShift(col, -5, 0.1));
  ctx.fillStyle = grd;
  ctx.fillRect(gx+3, gy+3, GATE_W-6, GATE_H-6);

  // Gold diagonal stripes
  if(isGold){
    ctx.save();
    ctx.globalAlpha=0.25;
    ctx.fillStyle='#fff';
    for(let i=0; i<7; i++){
      const sx = gx + 4 + i*20;
      ctx.beginPath();
      ctx.moveTo(sx, gy);
      ctx.lineTo(sx+10, gy);
      ctx.lineTo(sx-6, gy+GATE_H);
      ctx.lineTo(sx-16, gy+GATE_H);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  // Border
  ctx.strokeStyle = hsl(col, 0.9);
  ctx.lineWidth=2;
  ctx.strokeRect(gx+1, gy+1, GATE_W-2, GATE_H-2);

  // Colorblind icon
  if(!isGold){
    drawIcon(x, gy+GATE_H/2, COLORS[colorIdx].icon, GATE_H*0.55, 'rgba(255,255,255,0.55)');
  } else {
    ctx.fillStyle='rgba(255,255,255,0.5)';
    ctx.font='bold 22px sans-serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('\u2605', x, gy+GATE_H/2);
  }
}

// Mute button
const MUTE_X=BASE_W-38, MUTE_Y=34, MUTE_R=16;
function drawMuteBtn(){
  ctx.fillStyle = muted ? 'rgba(255,80,80,0.35)' : 'rgba(255,255,255,0.12)';
  ctx.beginPath(); ctx.arc(MUTE_X, MUTE_Y, MUTE_R, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = muted ? 'rgba(255,100,100,0.9)' : 'rgba(255,255,255,0.55)';
  ctx.font='12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  // Draw speaker icon with lines
  if(muted){
    ctx.fillText('OFF', MUTE_X, MUTE_Y);
  } else {
    ctx.fillText('SND', MUTE_X, MUTE_Y);
  }
}

// Share button
const SHARE_X=CX, SHARE_Y=530, SHARE_W=120, SHARE_H=38;

function roundRect(x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+r);
  ctx.lineTo(x+w, y+h-r);
  ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  ctx.lineTo(x+r, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-r);
  ctx.lineTo(x, y+r);
  ctx.quadraticCurveTo(x, y, x+r, y);
  ctx.closePath();
}

function drawShareBtn(){
  const bx=SHARE_X-SHARE_W/2, by=SHARE_Y-SHARE_H/2;
  if(shareFlash > 0){
    ctx.fillStyle='rgba(80,220,120,0.7)';
  } else {
    ctx.fillStyle='rgba(80,140,255,0.65)';
  }
  roundRect(bx, by, SHARE_W, SHARE_H, 8);
  ctx.fill();

  ctx.fillStyle='#fff'; ctx.font='bold 15px sans-serif';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(shareFlash>0 ? 'Copied!' : 'Share', SHARE_X, SHARE_Y);
}

function isInShareBtn(cx, cy){
  return cx>=SHARE_X-SHARE_W/2 && cx<=SHARE_X+SHARE_W/2 &&
         cy>=SHARE_Y-SHARE_H/2 && cy<=SHARE_Y+SHARE_H/2;
}

function doShare(){
  const s=Math.floor(score);
  const text=`I scored ${s} in Color Dash! Streak: ${bestStreak}. Can you beat me?`;
  const url=`https://balinti.github.io/color-dash/?challenge=${s}`;
  if(navigator.share){
    navigator.share({title:'Color Dash', text, url}).catch(()=>{});
  } else {
    try{
      navigator.clipboard.writeText(`${text}\n${url}`);
      shareFlash=1.5;
    }catch(e){}
  }
}

// ==================== MAIN DRAW ====================
function draw(t){
  const bgHue = (t*8 + score*1.2) % 360;
  ctx.save();

  // Screen shake offset
  let sx=0, sy=0;
  if(shakeMag > 0){
    sx = (Math.random()-0.5)*shakeMag*2;
    sy = (Math.random()-0.5)*shakeMag*2;
    ctx.translate(sx, sy);
  }

  // Background gradient
  const bgGrd = ctx.createLinearGradient(0,0,0,BASE_H);
  bgGrd.addColorStop(0, `hsl(${bgHue},30%,8%)`);
  bgGrd.addColorStop(0.5, `hsl(${(bgHue+20)%360},25%,12%)`);
  bgGrd.addColorStop(1, `hsl(${(bgHue+40)%360},20%,6%)`);
  ctx.fillStyle=bgGrd;
  ctx.fillRect(-20, -20, BASE_W+40, BASE_H+40);

  // Subtle moving stripes
  ctx.save();
  ctx.globalAlpha=0.035;
  const stripeOff=(t*40)%60;
  ctx.fillStyle=`hsl(${bgHue},50%,50%)`;
  for(let i=-1; i<BASE_H/60+2; i++){
    ctx.fillRect(0, i*60+stripeOff, BASE_W, 3);
  }
  ctx.restore();

  // Track background
  const trackLeft = CX - LANE_DX - GATE_W/2 - 8;
  const trackRight = CX + LANE_DX + GATE_W/2 + 8;
  ctx.fillStyle='rgba(255,255,255,0.035)';
  ctx.fillRect(trackLeft, 0, trackRight-trackLeft, BASE_H);

  // Lane separator (dashed)
  ctx.setLineDash([12, 16]);
  ctx.strokeStyle='rgba(255,255,255,0.08)';
  ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(CX, 0); ctx.lineTo(CX, BASE_H); ctx.stroke();
  ctx.setLineDash([]);

  // Check line
  ctx.strokeStyle='rgba(255,255,200,0.15)';
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(trackLeft, CHECK_Y);
  ctx.lineTo(trackRight, CHECK_Y);
  ctx.stroke();
  ctx.fillStyle='rgba(255,255,200,0.07)';
  ctx.font='9px sans-serif'; ctx.textAlign='center';
  ctx.fillText('CHECK', CX, CHECK_Y-5);

  // Draw gates
  for(const g of gates){
    drawGate(g, 'left', LEFT_X);
    drawGate(g, 'right', RIGHT_X);
  }

  // Runner
  if(state==='playing' || state==='start'){
    const col=COLORS[runner.colorIndex];

    // Glow
    const glowR=RUNNER_R*2.2;
    const rgrd=ctx.createRadialGradient(runner.x, RUNNER_Y, RUNNER_R*0.3, runner.x, RUNNER_Y, glowR);
    rgrd.addColorStop(0, hsl(col, 0.35));
    rgrd.addColorStop(1, hsl(col, 0));
    ctx.fillStyle=rgrd;
    ctx.beginPath(); ctx.arc(runner.x, RUNNER_Y, glowR, 0, Math.PI*2); ctx.fill();

    // Overdrive chromatic aberration (fake RGB split)
    if(overdriveTimer > 0){
      ctx.globalAlpha=0.3;
      ctx.fillStyle=`hsl(${col.h+30},${col.s}%,${col.l}%)`;
      ctx.beginPath(); ctx.arc(runner.x-3, RUNNER_Y-1, RUNNER_R, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle=`hsl(${col.h-30},${col.s}%,${col.l}%)`;
      ctx.beginPath(); ctx.arc(runner.x+3, RUNNER_Y+1, RUNNER_R, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;
    }

    // Body
    ctx.fillStyle=hsl(col);
    ctx.beginPath(); ctx.arc(runner.x, RUNNER_Y, RUNNER_R, 0, Math.PI*2); ctx.fill();
    // Rim
    ctx.strokeStyle=hslShift(col, 20, 0.9);
    ctx.lineWidth=2.5;
    ctx.beginPath(); ctx.arc(runner.x, RUNNER_Y, RUNNER_R-1, 0, Math.PI*2); ctx.stroke();

    // Inner icon
    drawIcon(runner.x, RUNNER_Y, col.icon, RUNNER_R*1.6, 'rgba(255,255,255,0.7)');
  }

  // Particles
  for(const p of particles){
    const alpha=clamp(p.life/p.maxLife, 0, 1);
    ctx.globalAlpha=alpha*0.8;
    ctx.fillStyle=p.color;
    const hs=p.size/2;
    ctx.fillRect(p.x-hs, p.y-hs, p.size, p.size);
  }
  ctx.globalAlpha=1;

  // ===== HUD (in-canvas) =====
  if(state==='playing'){
    // Score
    ctx.fillStyle='#fff';
    ctx.font='bold 36px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='top';
    ctx.shadowColor='rgba(0,0,0,0.5)'; ctx.shadowBlur=4;
    ctx.fillText(Math.floor(score), CX, 22);
    ctx.shadowBlur=0;

    // Streak + multiplier
    if(streak > 0){
      const mult=1+Math.floor(streak/3);
      ctx.font='bold 15px sans-serif';
      ctx.fillStyle='rgba(255,220,80,0.9)';
      ctx.fillText(`streak ${streak}  x${mult}`, CX, 65);
    }

    // Overdrive bar
    if(overdriveTimer > 0){
      const bw=160, bx=CX-bw/2, by=88;
      ctx.fillStyle='rgba(0,0,0,0.3)';
      roundRect(bx, by, bw, 8, 4); ctx.fill();
      const pct=clamp(overdriveTimer/2, 0, 1);
      const oGrd=ctx.createLinearGradient(bx, by, bx+bw*pct, by);
      oGrd.addColorStop(0, '#ff0');
      oGrd.addColorStop(1, '#f80');
      ctx.fillStyle=oGrd;
      roundRect(bx, by, bw*pct, 8, 4); ctx.fill();
      ctx.font='10px sans-serif'; ctx.fillStyle='rgba(255,255,255,0.55)';
      ctx.fillText('OVERDRIVE', CX, by+18);
    }

    // Color badge (top-left)
    const bc=COLORS[runner.colorIndex];
    ctx.fillStyle=hsl(bc);
    ctx.beginPath(); ctx.arc(36, 40, 14, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.4)'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.arc(36, 40, 14, 0, Math.PI*2); ctx.stroke();
    drawIcon(36, 40, bc.icon, 22, 'rgba(255,255,255,0.7)');

    // Mute toggle (top-right)
    drawMuteBtn();
  }

  // ===== START SCREEN =====
  if(state==='start'){
    ctx.fillStyle='rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, BASE_W, BASE_H);

    ctx.fillStyle='#fff'; ctx.font='bold 42px sans-serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.shadowColor='rgba(100,180,255,0.4)'; ctx.shadowBlur=12;
    ctx.fillText('COLOR DASH', CX, 195);
    ctx.shadowBlur=0;

    ctx.font='15px sans-serif'; ctx.fillStyle='rgba(255,255,255,0.5)';
    ctx.fillText('Split & Streak', CX, 235);

    // Animated tap prompt
    const tapPulse = 0.7 + 0.3*Math.sin(t*4);
    ctx.globalAlpha=tapPulse;
    ctx.font='20px sans-serif'; ctx.fillStyle='rgba(255,255,200,0.95)';
    ctx.fillText('Tap to Start', CX, 320);
    ctx.globalAlpha=1;

    // How-to
    ctx.font='13px sans-serif'; ctx.fillStyle='rgba(255,255,255,0.4)';
    ctx.fillText('One tap = switch color + dash lane', CX, 370);
    ctx.fillText('Match gate colors to pass through', CX, 392);
    ctx.fillText('Build streaks for multipliers!', CX, 414);

    // High score
    if(highScore > 0){
      ctx.font='14px sans-serif'; ctx.fillStyle='rgba(255,220,80,0.65)';
      ctx.fillText(`Best: ${highScore}  |  Best Streak: ${savedBestStreak}`, CX, 470);
    }

    // Challenge
    if(challengeScore > 0){
      ctx.font='bold 18px sans-serif'; ctx.fillStyle='#ff6';
      ctx.fillText(`Beat ${challengeScore}!`, CX, 510);
    }

    ctx.font='11px sans-serif'; ctx.fillStyle='rgba(255,255,255,0.25)';
    ctx.fillText('Space / Enter / Tap', CX, 560);
  }

  // ===== GAME OVER SCREEN =====
  if(state==='gameover'){
    ctx.fillStyle='rgba(0,0,0,0.65)';
    ctx.fillRect(0, 0, BASE_W, BASE_H);

    ctx.fillStyle='#f55'; ctx.font='bold 38px sans-serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.shadowColor='rgba(255,50,50,0.5)'; ctx.shadowBlur=10;
    ctx.fillText('GAME OVER', CX, 195);
    ctx.shadowBlur=0;

    // Score
    ctx.font='bold 48px sans-serif'; ctx.fillStyle='#fff';
    ctx.fillText(Math.floor(score), CX, 265);
    ctx.font='13px sans-serif'; ctx.fillStyle='rgba(255,255,255,0.45)';
    ctx.fillText('SCORE', CX, 298);

    // Best
    ctx.font='15px sans-serif'; ctx.fillStyle='rgba(255,220,80,0.8)';
    ctx.fillText(`Best: ${highScore}`, CX, 332);

    // Streak info
    ctx.fillStyle='rgba(255,255,255,0.55)';
    ctx.fillText(`Streak: ${bestStreak}  |  Best Streak: ${savedBestStreak}`, CX, 358);

    // Near misses
    if(nearMisses > 0){
      ctx.fillStyle='rgba(255,180,80,0.55)'; ctx.font='13px sans-serif';
      ctx.fillText(`Near misses: ${nearMisses}`, CX, 386);
    }

    // Challenge result
    if(challengeScore > 0){
      if(Math.floor(score) >= challengeScore){
        ctx.fillStyle='#4f4'; ctx.font='bold 16px sans-serif';
        ctx.fillText('Challenge beaten!', CX, 418);
      } else {
        ctx.fillStyle='#f88'; ctx.font='14px sans-serif';
        ctx.fillText(`Challenge: ${challengeScore} \u2014 try again!`, CX, 418);
      }
    }

    // Retry prompt
    const retryPulse = 0.6 + 0.4*Math.sin(t*3.5);
    ctx.globalAlpha=retryPulse;
    ctx.font='18px sans-serif'; ctx.fillStyle='rgba(255,255,200,0.9)';
    ctx.fillText('Tap to Retry', CX, 472);
    ctx.globalAlpha=1;

    // Share button
    drawShareBtn();

    // Share flash timer
    if(shareFlash > 0) shareFlash -= 1/60;
  }

  ctx.restore();
}

// ==================== INPUT ====================
function getCanvasCoords(e){
  const rect=canvas.getBoundingClientRect();
  const scaleX=BASE_W/rect.width;
  const scaleY=BASE_H/rect.height;
  return {
    cx: (e.clientX-rect.left)*scaleX,
    cy: (e.clientY-rect.top)*scaleY
  };
}

canvas.addEventListener('pointerdown', e => {
  e.preventDefault();
  const {cx, cy} = getCanvasCoords(e);

  // Mute toggle (playing state)
  if(state==='playing'){
    const dx=cx-MUTE_X, dy=cy-MUTE_Y;
    if(dx*dx+dy*dy <= (MUTE_R+8)*(MUTE_R+8)){
      muted=!muted;
      return;
    }
  }

  // Share button (gameover state)
  if(state==='gameover' && isInShareBtn(cx, cy)){
    doShare();
    return;
  }

  doAction();
}, {passive: false});

document.addEventListener('keydown', e => {
  if(e.repeat) return;
  if(e.code==='Space' || e.code==='Enter'){
    e.preventDefault();
    doAction();
  }
});

// ==================== MAIN LOOP ====================
let lastTime=0;
function loop(ts){
  const t=ts/1000;
  const dt=Math.min(t-(lastTime||t), 0.05);
  lastTime=t;

  update(dt);
  draw(t);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
