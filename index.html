<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0a1a">
<meta name="robots" content="index, follow">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100dvh;overflow:hidden;background:#0a0a1a;font-family:'Segoe UI',system-ui,sans-serif;display:flex;flex-direction:column;align-items:center;justify-content:center;}
#wrap{position:relative;width:100%;max-width:420px;height:100dvh;max-height:750px;display:flex;flex-direction:column;align-items:center;justify-content:center;}
canvas{display:block;width:100%;height:100%;border-radius:8px;touch-action:none;}
details{max-width:420px;width:90%;color:#aab;font-size:13px;margin:8px auto;position:fixed;bottom:4px;left:50%;transform:translateX(-50%);z-index:10;}
details summary{cursor:pointer;color:#88a;font-weight:600;text-align:center;}
details p{margin:6px 0;line-height:1.5;}
details .key{background:#222;padding:1px 5px;border-radius:3px;font-size:12px;}
</style>
</head>
<body>
<div id="wrap"><canvas id="c"></canvas></div>
<details>
<summary>How to Play</summary>
<p><strong>Color Dash: Flip + Match</strong> &mdash; a hyper-casual reflex game.</p>
<p><strong>Goal:</strong> Pass through color gates that match your current color.</p>
<p><strong>Controls:</strong> <span class="key">Tap</span>, <span class="key">Space</span>, or <span class="key">Enter</span> to flip your lane <em>and</em> swap your color (Cyan &#9650; &harr; Magenta &#9679;).</p>
<p><strong>Shield:</strong> You start each run with a shield. The first wrong gate cracks it; the second ends your run. Shields refresh less often as difficulty rises.</p>
<p><strong>Combo:</strong> Pass 5 perfect gates in a row to activate a x2 combo multiplier for 2.5&thinsp;s. Keep passing perfectly to refresh it!</p>
<p><strong>Feint Gates:</strong> Dashed-outline gates don&rsquo;t score but can break your combo if you hit the wrong lane/color.</p>
<p><strong>Color-Lock Gates:</strong> Passing one locks your color for 1.5&thinsp;s &mdash; you can still flip lanes but your color won&rsquo;t change.</p>
<p>Speed increases over time. How far can you dash?</p>
</details>
<script>
'use strict';
/* ========== HELPERS ========== */
const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
const lerp=(a,b,t)=>a+(b-a)*t;
const rand=(lo,hi)=>lo+Math.random()*(hi-lo);
const randInt=(lo,hi)=>Math.floor(rand(lo,hi+1));
const hsl=(h,s,l,a)=>a!==undefined?`hsla(${h},${s}%,${l}%,${a})`:`hsl(${h},${s}%,${l}%)`;

/* ========== CANVAS INIT ========== */
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
let W,H,dpr;
function resize(){
  const wrap=document.getElementById('wrap');
  const r=wrap.getBoundingClientRect();
  dpr=Math.min(window.devicePixelRatio||1,2);
  W=r.width; H=r.height;
  canvas.width=W*dpr; canvas.height=H*dpr;
  canvas.style.width=W+'px'; canvas.style.height=H+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize',resize);
resize();

/* ========== COLORS ========== */
const CYAN='#00e5ff';
const MAGENTA='#ff2ec4';
const COLORS=[CYAN,MAGENTA];

/* ========== GLOBAL STATE ========== */
let state='start';
let score=0, best=parseInt(localStorage.getItem('cd_best'))||0;
let bestStreak=parseInt(localStorage.getItem('cd_bestStreak'))||0;
let gameTime=0, speed=0, baseSpeed=0;
let gates=[], particles=[], bgDots=[];
let shakeX=0, shakeY=0, shakeMag=0;
const shakeDecay=0.88;
let hueShift=0;
let comboActive=false, comboTimer=0, comboMultiplier=1;
let perfectStreak=0;
let retryTimer=0;
let deathFreeze=0;
let spawnTimer=0;

/* ========== PLAYER ========== */
const player={
  lane:0, targetLane:0,
  x:0, y:0,
  radius:18,
  colorId:0,
  shield:1,
  lockTimer:0,
  flipCooldown:0,
  trail:[]
};

/* ========== BACKGROUND DOTS ========== */
function initBgDots(){
  bgDots=[];
  for(let i=0;i<40;i++){
    bgDots.push({x:rand(0,W),y:rand(0,H),r:rand(1,2.5),spd:rand(0.3,1.2),alpha:rand(0.08,0.25)});
  }
}

/* ========== GATE FACTORY ========== */
function makeGate(lane,colorId,isFeint,isColorLock){
  const gapH=clamp(92-score*0.35,48,92);
  return{x:W+60,w:16,lane,colorId,gapH,isFeint:!!isFeint,isColorLock:!!isColorLock,scored:false,passed:false};
}

/* ========== SPAWN SYSTEM ========== */
function getSpawnInterval(){
  return clamp(1.55-gameTime*0.009,0.5,1.55);
}
function spawnGate(){
  const s=score;
  const lane=randInt(0,1);
  const colorId=randInt(0,1);
  let isFeint=false,isColorLock=false;
  if(s>=8&&Math.random()<clamp(0.12+s*0.003,0.12,0.28)) isFeint=true;
  if(!isFeint&&s>=15&&Math.random()<clamp(0.1+s*0.002,0.1,0.22)) isColorLock=true;
  gates.push(makeGate(lane,colorId,isFeint,isColorLock));
  if(s>=20&&Math.random()<0.18){
    gates.push(makeGate(1-lane,randInt(0,1),false,false));
  }
}

/* ========== PARTICLES ========== */
function spawnParticles(x,y,color,count,spread,life){
  for(let i=0;i<count&&particles.length<300;i++){
    const a=rand(0,Math.PI*2);
    const sp=rand(1,spread);
    const l=life||rand(0.4,0.9);
    particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:l,maxLife:l,color,r:rand(2,5)});
  }
}

/* ========== SHAKE ========== */
function triggerShake(mag){ shakeMag=Math.max(shakeMag,mag); }

/* ========== INPUT ========== */
function doFlip(){
  if(state==='start'){ startGame(); return; }
  if(state==='gameover'){ if(retryTimer>0.45) startGame(); return; }
  if(player.flipCooldown>0) return;
  player.targetLane=1-player.lane;
  if(player.lockTimer<=0) player.colorId=1-player.colorId;
  player.flipCooldown=0.08;
}
canvas.addEventListener('pointerdown',e=>{e.preventDefault();doFlip();});
document.addEventListener('keydown',e=>{
  if(e.code==='Space'||e.code==='Enter'){e.preventDefault();doFlip();}
});

/* ========== GAME LIFECYCLE ========== */
function startGame(){
  state='playing';
  score=0;gameTime=0;speed=3;baseSpeed=3;
  gates=[];particles=[];
  player.lane=0;player.targetLane=0;player.colorId=0;
  player.shield=1;player.lockTimer=0;player.flipCooldown=0;player.trail=[];
  player.x=W*0.22;player.y=H*0.35;
  comboActive=false;comboTimer=0;comboMultiplier=1;
  perfectStreak=0;spawnTimer=0;retryTimer=0;deathFreeze=0;shakeMag=0;
  initBgDots();
}

function die(){
  state='gameover';
  if(score>best){best=score;localStorage.setItem('cd_best',''+best);}
  if(perfectStreak>bestStreak){bestStreak=perfectStreak;localStorage.setItem('cd_bestStreak',''+bestStreak);}
  triggerShake(16);
  spawnParticles(player.x,player.y,COLORS[player.colorId],45,7,1);
  spawnParticles(player.x,player.y,'#fff',18,5,0.7);
  deathFreeze=0.3;retryTimer=0;
}

/* ========== UPDATE ========== */
function update(dt){
  hueShift+=dt*8;

  // Shake
  if(shakeMag>0.15){
    shakeMag*=shakeDecay;
    shakeX=rand(-shakeMag,shakeMag);
    shakeY=rand(-shakeMag,shakeMag);
  } else { shakeMag=0;shakeX=0;shakeY=0; }

  if(state==='gameover'){
    retryTimer+=dt;
    if(deathFreeze>0) deathFreeze-=dt;
    updateParticles(dt);
    updateBgDots(dt);
    return;
  }
  if(state==='start'){
    updateBgDots(dt);
    updateParticles(dt);
    return;
  }

  /* --- Playing --- */
  gameTime+=dt;
  baseSpeed=3+gameTime*0.12;
  speed=clamp(baseSpeed,3,12);

  // Player y interpolation
  const laneY0=H*0.35,laneY1=H*0.65;
  const targetY=player.targetLane===0?laneY0:laneY1;
  player.y=lerp(player.y,targetY,clamp(dt*18,0,1));
  player.lane=player.targetLane;
  player.x=W*0.22;

  // Cooldowns
  if(player.flipCooldown>0) player.flipCooldown-=dt;
  if(player.lockTimer>0) player.lockTimer-=dt;

  // Combo
  if(comboActive){
    comboTimer-=dt;
    if(comboTimer<=0){comboActive=false;comboMultiplier=1;}
  }

  // Trail
  player.trail.unshift({x:player.x,y:player.y,a:1});
  const maxTrail=comboActive?16:8;
  while(player.trail.length>maxTrail) player.trail.pop();
  for(const t of player.trail) t.a*=0.86;

  // Spawn
  spawnTimer-=dt;
  if(spawnTimer<=0){ spawnGate(); spawnTimer=getSpawnInterval(); }

  // Move gates
  const px=speed*100*dt;
  for(const g of gates) g.x-=px;

  // Collision
  for(const g of gates){
    if(g.passed) continue;
    const gRight=g.x+g.w;
    const pLeft=player.x-player.radius;
    const pRight=player.x+player.radius;

    if(pRight>g.x&&pLeft<gRight){
      const laneCY=g.lane===0?laneY0:laneY1;
      const halfGap=g.gapH/2;
      const margin=player.radius*0.4;
      const inGap=player.y>laneCY-halfGap+margin&&player.y<laneCY+halfGap-margin;
      const sameLane=player.lane===g.lane;
      const colorMatch=player.colorId===g.colorId;

      if(sameLane){
        if(!g.scored){
          if(inGap&&colorMatch){
            /* --- Perfect pass --- */
            g.scored=true;
            if(!g.isFeint){
              score+=comboActive?2:1;
              perfectStreak++;
              if(perfectStreak>=5&&!comboActive){
                comboActive=true;comboTimer=2.5;comboMultiplier=2;
                spawnParticles(player.x,player.y,'#ffeb3b',22,5,0.6);
              } else if(comboActive){ comboTimer=2.5; }
              triggerShake(2.5);
              spawnParticles(player.x,player.y,COLORS[g.colorId],14,4,0.5);
              if(g.isColorLock){
                player.lockTimer=1.5;
                spawnParticles(player.x,player.y,'#fff',10,3,0.4);
              }
            }
            /* Feint passed correctly â€” no score, no penalty */
          } else {
            /* --- Hit / wrong color --- */
            g.scored=true;
            if(g.isFeint){
              perfectStreak=0;comboActive=false;comboMultiplier=1;comboTimer=0;
              triggerShake(3);
              spawnParticles(player.x,player.y,'#888',10,3,0.4);
            } else {
              if(player.shield===1){
                player.shield=0;
                perfectStreak=0;comboActive=false;comboMultiplier=1;comboTimer=0;
                triggerShake(7);
                spawnParticles(player.x,player.y,'#ff6600',20,5,0.6);
              } else { die(); return; }
            }
          }
        }
      }
    }

    if(gRight<pLeft&&!g.passed){ g.passed=true; }
  }

  // Shield refresh
  if(player.shield===0){
    const chance=clamp(0.0018-score*0.00003,0.0002,0.0018);
    if(Math.random()<chance){ player.shield=1; spawnParticles(player.x,player.y,'rgba(255,255,255,0.8)',8,3,0.4); }
  }

  // Cleanup
  gates=gates.filter(g=>g.x+g.w>-60);
  updateParticles(dt);
  updateBgDots(dt);
}

function updateParticles(dt){
  for(const p of particles){
    p.x+=p.vx;p.y+=p.vy;
    p.vy+=30*dt;
    p.vx*=0.98;
    p.life-=dt;
    p.r*=0.996;
  }
  particles=particles.filter(p=>p.life>0&&p.r>0.3);
}

function updateBgDots(dt){
  const s=state==='playing'?speed:1.5;
  for(const d of bgDots){
    d.x-=d.spd*s;
    if(d.x<-5){d.x=W+5;d.y=rand(0,H);}
  }
}

/* ========== DRAW ========== */
function draw(){
  ctx.save();
  ctx.translate(shakeX,shakeY);

  // Background gradient with subtle hue cycling
  const bgH=hueShift%360;
  const grad=ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,hsl(230+bgH*0.05,30,8));
  grad.addColorStop(1,hsl(260+bgH*0.05,25,5));
  ctx.fillStyle=grad;
  ctx.fillRect(-20,-20,W+40,H+40);

  // BG dots
  for(const d of bgDots){
    ctx.beginPath();
    ctx.arc(d.x,d.y,d.r,0,Math.PI*2);
    ctx.fillStyle=`rgba(255,255,255,${d.alpha})`;
    ctx.fill();
  }

  // Lane divider
  ctx.save();
  ctx.setLineDash([6,8]);
  ctx.strokeStyle='rgba(255,255,255,0.06)';
  ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(0,H*0.5);ctx.lineTo(W,H*0.5);ctx.stroke();
  ctx.restore();

  // Upper lane tint
  ctx.fillStyle='rgba(255,255,255,0.012)';
  ctx.fillRect(0,0,W,H*0.5);

  if(state==='start'){ drawStartScreen(); drawParticles(); ctx.restore(); return; }

  // Gates
  for(const g of gates) drawGate(g);

  // Player trail
  for(let i=player.trail.length-1;i>=0;i--){
    const t=player.trail[i];
    const a=t.a*(comboActive?0.45:0.22);
    if(a<0.01) continue;
    ctx.beginPath();
    ctx.arc(t.x,t.y,player.radius*(0.4+t.a*0.6),0,Math.PI*2);
    ctx.fillStyle=player.colorId===0?`rgba(0,229,255,${a})`:`rgba(255,46,196,${a})`;
    ctx.fill();
  }

  drawPlayer();
  drawParticles();
  drawHUD();

  if(state==='gameover') drawGameOver();

  ctx.restore();
}

function drawPlayer(){
  const px=player.x,py=player.y,r=player.radius;
  const col=COLORS[player.colorId];

  // Glow
  ctx.save();
  ctx.shadowColor=col;
  ctx.shadowBlur=comboActive?28:16;
  ctx.beginPath();ctx.arc(px,py,r,0,Math.PI*2);
  ctx.fillStyle=col;ctx.fill();
  ctx.restore();

  // Disc
  ctx.beginPath();ctx.arc(px,py,r*0.88,0,Math.PI*2);
  ctx.fillStyle=col;ctx.fill();

  // Accessibility icon
  ctx.strokeStyle='#fff';ctx.lineWidth=2;
  if(player.colorId===0){
    ctx.beginPath();
    ctx.moveTo(px,py-r*0.42);
    ctx.lineTo(px-r*0.38,py+r*0.28);
    ctx.lineTo(px+r*0.38,py+r*0.28);
    ctx.closePath();ctx.stroke();
  } else {
    ctx.beginPath();ctx.arc(px,py,r*0.33,0,Math.PI*2);ctx.stroke();
  }

  // Shield ring
  if(player.shield===1){
    ctx.save();
    ctx.strokeStyle='rgba(255,255,255,0.65)';
    ctx.lineWidth=2.5;ctx.setLineDash([]);
    ctx.beginPath();ctx.arc(px,py,r+6,0,Math.PI*2);ctx.stroke();
    ctx.restore();
  } else if(player.shield===0){
    ctx.save();
    ctx.strokeStyle='rgba(255,150,0,0.45)';
    ctx.lineWidth=2;ctx.setLineDash([4,4]);
    ctx.beginPath();ctx.arc(px,py,r+6,0,Math.PI*2);ctx.stroke();
    ctx.restore();
  }

  // Lock indicator
  if(player.lockTimer>0){
    ctx.save();
    ctx.fillStyle='rgba(255,255,255,0.85)';
    ctx.font='bold 10px sans-serif';ctx.textAlign='center';
    ctx.fillText('LOCK',px,py-r-11);
    ctx.restore();
  }

  // Combo ring
  if(comboActive){
    const ca=0.3+0.3*Math.sin(gameTime*10);
    ctx.save();
    ctx.strokeStyle=`rgba(255,235,59,${ca})`;
    ctx.lineWidth=3;
    ctx.beginPath();ctx.arc(px,py,r+11+Math.sin(gameTime*8)*2,0,Math.PI*2);ctx.stroke();
    ctx.restore();
  }
}

function drawGate(g){
  const laneY=g.lane===0?H*0.35:H*0.65;
  const half=g.gapH/2;
  const col=COLORS[g.colorId];

  ctx.save();
  if(g.isFeint){ ctx.setLineDash([6,6]);ctx.globalAlpha=0.45; }

  // Glow bloom layers
  for(let i=3;i>=1;i--){
    ctx.strokeStyle=player.colorId===g.colorId?`rgba(${g.colorId===0?'0,229,255':'255,46,196'},${0.04*i})`:`rgba(${g.colorId===0?'0,229,255':'255,46,196'},${0.03*i})`;
    ctx.lineWidth=g.w+i*7;
    ctx.beginPath();ctx.moveTo(g.x+g.w/2,laneY-half-45);ctx.lineTo(g.x+g.w/2,laneY-half);ctx.stroke();
    ctx.beginPath();ctx.moveTo(g.x+g.w/2,laneY+half);ctx.lineTo(g.x+g.w/2,laneY+half+45);ctx.stroke();
  }

  // Main bars
  ctx.strokeStyle=col;ctx.lineWidth=g.w;
  ctx.beginPath();ctx.moveTo(g.x+g.w/2,laneY-half-45);ctx.lineTo(g.x+g.w/2,laneY-half);ctx.stroke();
  ctx.beginPath();ctx.moveTo(g.x+g.w/2,laneY+half);ctx.lineTo(g.x+g.w/2,laneY+half+45);ctx.stroke();

  // Gap edge markers
  ctx.fillStyle=`rgba(${g.colorId===0?'0,229,255':'255,46,196'},0.3)`;
  ctx.fillRect(g.x,laneY-half,g.w,2);
  ctx.fillRect(g.x,laneY+half-2,g.w,2);

  // Accessibility icon in gap
  const ix=g.x+g.w/2,iy=laneY;
  ctx.strokeStyle='rgba(255,255,255,0.55)';ctx.lineWidth=1.5;
  if(g.colorId===0){
    ctx.beginPath();ctx.moveTo(ix,iy-8);ctx.lineTo(ix-7,iy+5);ctx.lineTo(ix+7,iy+5);ctx.closePath();ctx.stroke();
  } else {
    ctx.beginPath();ctx.arc(ix,iy,6,0,Math.PI*2);ctx.stroke();
  }

  // Color-lock badge
  if(g.isColorLock){
    ctx.fillStyle='rgba(255,255,255,0.75)';
    ctx.font='bold 9px sans-serif';ctx.textAlign='center';
    ctx.fillText('CL',g.x+g.w/2,laneY-half-48);
  }

  ctx.restore();
}

function drawParticles(){
  for(const p of particles){
    const a=clamp(p.life/p.maxLife,0,1);
    ctx.globalAlpha=a;
    ctx.beginPath();ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
    ctx.fillStyle=p.color;ctx.fill();
  }
  ctx.globalAlpha=1;
}

function drawHUD(){
  ctx.save();ctx.textAlign='center';

  // Score
  ctx.fillStyle='#fff';
  ctx.font='bold 28px sans-serif';
  ctx.fillText(score,W/2,40);

  // Combo
  if(comboActive){
    const fl=0.65+0.35*Math.sin(gameTime*12);
    ctx.fillStyle=`rgba(255,235,59,${fl})`;
    ctx.font='bold 16px sans-serif';
    ctx.fillText('x2 COMBO',W/2,62);
    const bw=80,remain=comboTimer/2.5;
    ctx.fillStyle='rgba(255,235,59,0.25)';ctx.fillRect(W/2-bw/2,67,bw,4);
    ctx.fillStyle='rgba(255,235,59,0.8)';ctx.fillRect(W/2-bw/2,67,bw*remain,4);
  }

  // Streak
  if(perfectStreak>=2){
    ctx.fillStyle='rgba(255,255,255,0.35)';
    ctx.font='12px sans-serif';
    ctx.fillText('streak '+perfectStreak,W/2,H-14);
  }

  ctx.restore();
}

function drawStartScreen(){
  ctx.save();ctx.textAlign='center';

  ctx.fillStyle='#fff';
  ctx.font='bold 38px sans-serif';
  ctx.fillText('Color Dash',W/2,H*0.28);

  ctx.fillStyle='rgba(255,255,255,0.45)';
  ctx.font='16px sans-serif';
  ctx.fillText('Flip + Match',W/2,H*0.28+32);

  // Preview player
  const py=H*0.48;
  ctx.beginPath();ctx.arc(W/2,py,24,0,Math.PI*2);ctx.fillStyle=CYAN;ctx.fill();
  ctx.strokeStyle='#fff';ctx.lineWidth=2;
  ctx.beginPath();ctx.moveTo(W/2,py-11);ctx.lineTo(W/2-10,py+7);ctx.lineTo(W/2+10,py+7);ctx.closePath();ctx.stroke();

  if(best>0){
    ctx.fillStyle='rgba(255,255,255,0.4)';ctx.font='14px sans-serif';
    ctx.fillText('Best: '+best,W/2,H*0.6);
  }

  const pulse=0.5+0.5*Math.sin(Date.now()*0.004);
  ctx.fillStyle=`rgba(255,255,255,${0.35+pulse*0.45})`;
  ctx.font='18px sans-serif';
  ctx.fillText('Tap to Start',W/2,H*0.73);

  ctx.restore();
}

function drawGameOver(){
  if(deathFreeze>0) return;
  ctx.save();

  ctx.fillStyle='rgba(0,0,0,0.6)';
  ctx.fillRect(-20,-20,W+40,H+40);

  ctx.textAlign='center';

  ctx.fillStyle='rgba(255,255,255,0.5)';ctx.font='16px sans-serif';
  ctx.fillText('Score',W/2,H*0.28);

  ctx.fillStyle='#fff';ctx.font='bold 52px sans-serif';
  ctx.fillText(score,W/2,H*0.38);

  ctx.fillStyle='rgba(255,255,255,0.55)';ctx.font='18px sans-serif';
  ctx.fillText('Best: '+best,W/2,H*0.48);

  if(bestStreak>0){
    ctx.fillStyle='rgba(255,255,255,0.35)';ctx.font='14px sans-serif';
    ctx.fillText('Best Streak: '+bestStreak,W/2,H*0.54);
  }

  if(retryTimer>0.45){
    const p2=0.5+0.5*Math.sin(Date.now()*0.005);
    ctx.fillStyle=`rgba(255,255,255,${0.35+p2*0.45})`;
    ctx.font='18px sans-serif';
    ctx.fillText('Tap to Retry',W/2,H*0.7);
  }

  ctx.restore();
}

/* ========== MAIN LOOP ========== */
let lastTime=0;
function loop(ts){
  requestAnimationFrame(loop);
  const dt=Math.min((ts-lastTime)/1000,0.05);
  lastTime=ts;
  update(dt);
  draw();
}
requestAnimationFrame(ts=>{lastTime=ts;loop(ts);});
initBgDots();
</script>
</body>
</html>
