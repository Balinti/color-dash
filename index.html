<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="theme-color" content="#1a1a2e">
<link rel="canonical" href="https://balinti.github.io/color-dash/">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow-x:hidden;background:#0f0f23;font-family:'Segoe UI',system-ui,sans-serif;color:#e0e0e0}
#wrap{max-width:420px;margin:0 auto;display:flex;flex-direction:column;align-items:center;min-height:100vh;min-height:100dvh;position:relative}
canvas{display:block;width:100%;max-width:420px;border-radius:8px;touch-action:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}
#seo-toggle{background:none;border:1px solid #333;color:#888;padding:6px 14px;border-radius:4px;cursor:pointer;font-size:12px;margin:12px 0 4px}
#seo-toggle:hover{color:#aaa;border-color:#555}
#seo-block{max-width:400px;padding:10px 16px;font-size:11px;line-height:1.5;color:#555;display:none;text-align:left}
#seo-block.open{display:block}
#seo-block h2{font-size:13px;color:#666;margin-bottom:4px}
#seo-block p{margin-bottom:6px}
</style>
</head>
<body>
<div id="wrap">
<canvas id="c"></canvas>
<button id="seo-toggle" aria-label="Toggle game information">Game Info ▼</button>
<div id="seo-block">
<h2>Color Dash – Free Hyper-Casual HTML5 Game</h2>
<p>Color Dash is a fast-paced lane-switching runner game you can play in your browser. Tap or press Space to switch lanes and match your color and symbol to the incoming gates. Build combos by hitting safe lanes perfectly, collect bonus shards for big points, and manage your Heat meter to survive. The game gets faster as you progress, with new patterns and double gates appearing at higher scores.</p>
<p>Features: 3-lane runner gameplay, combo multiplier system, heat management mechanic, particle effects, colorblind-friendly symbols, high score persistence, mobile-optimized with touch controls. No download required – play instantly!</p>
<p>Keywords: color dash, HTML5 game, browser game, hyper-casual game, free online game, lane runner, color matching game, tap game, mobile game</p>
</div>
</div>
<script>
'use strict';
(()=>{

/* ── CONSTANTS ── */
const CANVAS_W = 420, CANVAS_H = 750;
const LANE_COUNT = 3;
const PLAYER_SIZE = 28;
const GATE_HEIGHT = 52;
const GATE_GAP = 6;
const HEAT_MAX = 100;
const COMBO_MAX = 4;
const NEAR_MISS_WINDOW = 0.18;
const RETRY_LOCK_MS = 450;
const MAX_PARTICLES = 200;
const DPR = Math.min(window.devicePixelRatio || 1, 3);

/* ── COLORS & SYMBOLS ── */
const PALETTE = [
  {h:0,   s:75, l:55, name:'red'},
  {h:130, s:65, l:45, name:'green'},
  {h:220, s:75, l:55, name:'blue'},
  {h:45,  s:85, l:55, name:'yellow'},
];
const SYMBOLS = ['★','▲','●','◆'];
const SYMBOL_LABELS = {
  '★':'star','▲':'triangle','●':'circle','◆':'diamond'
};

function hsl(c, a){return `hsla(${c.h},${c.s}%,${c.l}%,${a??1})`}
function hslStr(h,s,l,a){return `hsla(${h},${s}%,${l}%,${a??1})`}

/* ── CANVAS SETUP ── */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let cW, cH, scale;

function resize(){
  const wrap = document.getElementById('wrap');
  const vw = Math.min(window.innerWidth, 420);
  const vh = window.innerHeight;
  const aspect = CANVAS_W / CANVAS_H;
  let w = vw, h = w / aspect;
  if(h > vh * 0.92){ h = vh * 0.92; w = h * aspect; }
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.round(w * DPR);
  canvas.height = Math.round(h * DPR);
  cW = CANVAS_W;
  cH = CANVAS_H;
  scale = canvas.width / CANVAS_W;
  ctx.setTransform(scale, 0, 0, scale, 0, 0);
}
window.addEventListener('resize', resize);
resize();

/* ── GAME STATE ── */
const ROAD_LEFT = 30, ROAD_RIGHT = CANVAS_W - 30;
const ROAD_W = ROAD_RIGHT - ROAD_LEFT;
const LANE_W = ROAD_W / LANE_COUNT;

let state = 'start'; // start | playing | gameover
let score, best, bestCombo, bestShards;
let combo, comboMult, heat, shards;
let playerLane, playerColor, playerSymbol;
let gates, particles, pops, rings;
let speed, spawnTimer, spawnInterval;
let gameTime, lastTime, shakeX, shakeY, shakeDur;
let overReason, retryLockTime;
let lastLaneSwitchTime;
let nearMissFlash;

/* ── LOAD BEST ── */
function loadBest(){
  best = parseInt(localStorage.getItem('dd_best')) || 0;
  bestCombo = parseInt(localStorage.getItem('dd_bestCombo')) || 0;
  bestShards = parseInt(localStorage.getItem('dd_bestShards')) || 0;
}
function saveBest(){
  if(score > best){ best = score; localStorage.setItem('dd_best', best); }
  if(combo > bestCombo){ bestCombo = combo; localStorage.setItem('dd_bestCombo', bestCombo); }
  if(shards > bestShards){ bestShards = shards; localStorage.setItem('dd_bestShards', bestShards); }
}
loadBest();

/* ── LANE GEOMETRY ── */
function laneX(lane){ return ROAD_LEFT + lane * LANE_W + LANE_W / 2; }
function laneLeft(lane){ return ROAD_LEFT + lane * LANE_W; }

/* ── PARTICLES ── */
function spawnParticle(x, y, col, count, spdMul){
  for(let i = 0; i < count && particles.length < MAX_PARTICLES; i++){
    const a = Math.random() * Math.PI * 2;
    const s = (1 + Math.random() * 3) * (spdMul || 1);
    particles.push({
      x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s,
      life: 0.4 + Math.random()*0.4,
      maxLife: 0.4 + Math.random()*0.4,
      r: 2 + Math.random()*3,
      col
    });
  }
}
function spawnRing(x, y, col){
  rings.push({x, y, r: 10, maxR: 60, life: 0.35, maxLife: 0.35, col});
}
function spawnPop(x, y, text, col){
  pops.push({x, y, text, col, life: 0.7, maxLife: 0.7, vy: -80});
}

/* ── SHAKE ── */
function triggerShake(dur, mag){
  shakeDur = dur;
  shakeX = (Math.random()-0.5) * mag;
  shakeY = (Math.random()-0.5) * mag;
}

/* ── GATE CREATION ── */
function randomColor(exclude){
  let c;
  do { c = PALETTE[Math.floor(Math.random()*PALETTE.length)]; } while(c === exclude);
  return c;
}
function randomSymbol(exclude){
  let s;
  do { s = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)]; } while(s === exclude);
  return s;
}

function createGate(){
  const gateColor = PALETTE[Math.floor(Math.random()*PALETTE.length)];
  const gateSymbol = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)];

  // Decide lane types: one SAFE, one RISK, one BONUS (shuffled)
  const types = ['safe','risk','bonus'];
  // Shuffle
  for(let i = types.length - 1; i > 0; i--){
    const j = Math.floor(Math.random()*(i+1));
    [types[i], types[j]] = [types[j], types[i]];
  }

  const lanes = [];
  for(let i = 0; i < 3; i++){
    const t = types[i];
    let laneColor = gateColor, laneSymbol = gateSymbol;
    if(t === 'risk'){
      // match only color OR only symbol
      if(Math.random() < 0.5){
        laneSymbol = randomSymbol(gateSymbol); // color match only
      } else {
        laneColor = randomColor(gateColor); // symbol match only
      }
    } else if(t === 'bonus'){
      laneColor = randomColor(gateColor);
      laneSymbol = randomSymbol(gateSymbol);
    }
    lanes.push({type: t, color: laneColor, symbol: laneSymbol});
  }

  return {
    y: -GATE_HEIGHT,
    gateColor, gateSymbol,
    lanes,
    crossed: false,
    prevY: -GATE_HEIGHT
  };
}

/* ── DIFFICULTY ── */
function getSpeed(){ return Math.min(420, 240 + 1.6 * score); }
function getInterval(){ return Math.max(0.62, Math.min(1.25, 1.25 - 0.0065 * score)); }
function doubleGateChance(){ return score >= 30 ? Math.min(0.35, (score - 30) * 0.008) : 0; }

/* ── INIT GAME ── */
function initGame(){
  score = 0; combo = 0; comboMult = 1; heat = 0; shards = 0;
  playerLane = 1;
  playerColor = PALETTE[0];
  playerSymbol = SYMBOLS[0];
  gates = []; particles = []; pops = []; rings = [];
  speed = getSpeed();
  spawnInterval = getInterval();
  spawnTimer = 0.6;
  gameTime = 0;
  shakeX = 0; shakeY = 0; shakeDur = 0;
  overReason = '';
  lastLaneSwitchTime = -1;
  nearMissFlash = 0;
}

/* ── CROSSING LOGIC ── */
function processGateCross(gate){
  const playerY = cH - 90;
  const lane = gate.lanes[playerLane];
  const t = lane.type;
  const lc = lane.color;
  const ls = lane.symbol;
  const colorMatch = (playerColor === lc);
  const symbolMatch = (playerSymbol === ls);

  const px = laneX(playerLane);
  const py = playerY;

  // Near-miss check
  const timeSinceSwitch = gameTime - lastLaneSwitchTime;
  const isNearMiss = timeSinceSwitch >= 0 && timeSinceSwitch < NEAR_MISS_WINDOW;

  if(t === 'safe'){
    if(colorMatch && symbolMatch){
      // Perfect SAFE
      const pts = 1 * comboMult;
      score += pts;
      combo++;
      comboMult = Math.min(COMBO_MAX, 1 + Math.floor(combo / 3));
      heat = Math.max(0, heat - 12);
      playerColor = gate.gateColor;
      playerSymbol = gate.gateSymbol;
      spawnParticle(px, py, hsl(playerColor), 12, 1.5);
      spawnRing(px, py, hsl(playerColor, 0.6));
      spawnPop(px, py - 30, `+${pts} SAFE`, hsl(playerColor));
      if(isNearMiss){
        score += 1;
        nearMissFlash = 0.4;
        spawnPop(px + 30, py - 50, 'SLIP!', '#fff');
      }
    } else {
      // Wrong on SAFE lane — heat penalty
      heat += 20;
      combo = 0; comboMult = 1;
      triggerShake(0.15, 4);
      spawnPop(px, py - 30, 'WRONG!', '#ff4444');
      spawnParticle(px, py, '#ff4444', 8, 1);
    }
  } else if(t === 'risk'){
    if(colorMatch || symbolMatch){
      // Partial match on RISK
      const pts = 1 * comboMult;
      score += pts;
      heat += 8;
      combo = 0; comboMult = 1;
      if(colorMatch) playerColor = lc;
      if(symbolMatch) playerSymbol = ls;
      spawnParticle(px, py, hsl(lc), 8, 1);
      spawnPop(px, py - 30, `+${pts} RISK`, hslStr(40,90,60));
      triggerShake(0.08, 2);
    } else {
      // No match at all on RISK
      heat += 18;
      combo = 0; comboMult = 1;
      triggerShake(0.15, 4);
      spawnPop(px, py - 30, 'MISS!', '#ff4444');
      spawnParticle(px, py, '#ff6644', 6, 1);
    }
  } else if(t === 'bonus'){
    // Bonus: mismatch allowed, shard pickup
    const bonusHeat = 12 + Math.min(8, score * 0.1);
    heat += bonusHeat;
    const pts = 3 * comboMult;
    score += pts;
    shards++;
    combo = 0; comboMult = 1;
    playerColor = lc;
    playerSymbol = ls;
    spawnParticle(px, py, '#ffdd44', 18, 2);
    spawnRing(px, py, 'rgba(255,220,60,0.5)');
    spawnPop(px, py - 30, `+${pts} SHARD!`, '#ffdd44');
    triggerShake(0.1, 3);
  }

  // Passive heat decay applied elsewhere; clamp
  heat = Math.min(HEAT_MAX, Math.max(0, heat));

  // Check overheat
  if(heat >= HEAT_MAX){
    gameOver('Overloaded!');
  }

  // Update difficulty
  speed = getSpeed();
  spawnInterval = getInterval();
}

/* ── GAME OVER ── */
function gameOver(reason){
  state = 'gameover';
  overReason = reason || 'Game Over';
  saveBest();
  triggerShake(0.5, 12);
  const px = laneX(playerLane);
  const py = cH - 90;
  spawnParticle(px, py, hsl(playerColor), 30, 3);
  spawnParticle(px, py, '#ff4444', 20, 2.5);
  retryLockTime = performance.now();
}

/* ── INPUT ── */
function handleInput(){
  if(state === 'start'){
    state = 'playing';
    initGame();
  } else if(state === 'playing'){
    playerLane = (playerLane + 1) % LANE_COUNT;
    lastLaneSwitchTime = gameTime;
    triggerShake(0.04, 1.5);
  } else if(state === 'gameover'){
    if(performance.now() - retryLockTime > RETRY_LOCK_MS){
      state = 'playing';
      initGame();
    }
  }
}

canvas.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  handleInput();
});
document.addEventListener('keydown', (e)=>{
  if(e.code === 'Space' || e.code === 'Enter'){
    e.preventDefault();
    handleInput();
  }
});

/* ── SEO TOGGLE ── */
document.getElementById('seo-toggle').addEventListener('click', ()=>{
  const block = document.getElementById('seo-block');
  const btn = document.getElementById('seo-toggle');
  block.classList.toggle('open');
  btn.textContent = block.classList.contains('open') ? 'Game Info ▲' : 'Game Info ▼';
});

/* ── UPDATE ── */
function update(dt){
  if(state !== 'playing') {
    // Still update particles in non-playing states
    updateParticles(dt);
    return;
  }

  gameTime += dt;

  // Passive heat decay
  heat = Math.max(0, heat - 0.8 * dt);

  // Spawn gates
  spawnTimer -= dt;
  if(spawnTimer <= 0){
    gates.push(createGate());
    // Double gate chance
    if(Math.random() < doubleGateChance()){
      const g2 = createGate();
      g2.y = -GATE_HEIGHT * 2.2;
      gates.push(g2);
    }
    spawnTimer = spawnInterval;
  }

  // Move gates
  const playerBottomY = cH - 90 + PLAYER_SIZE;
  const playerTopY = cH - 90 - PLAYER_SIZE;

  for(let i = gates.length - 1; i >= 0; i--){
    const g = gates[i];
    g.prevY = g.y;
    g.y += speed * dt;

    // Crossing detection: gate bottom edge crosses player center
    const gateBottom = g.y + GATE_HEIGHT;
    const prevBottom = g.prevY + GATE_HEIGHT;
    const crossY = cH - 90;

    if(!g.crossed && prevBottom <= crossY && gateBottom > crossY){
      g.crossed = true;
      processGateCross(g);
    }

    // Remove off-screen
    if(g.y > cH + 20){
      gates.splice(i, 1);
    }
  }

  // Near miss flash decay
  if(nearMissFlash > 0) nearMissFlash -= dt;

  // Shake decay
  if(shakeDur > 0){
    shakeDur -= dt;
    shakeX *= 0.85;
    shakeY *= 0.85;
    if(shakeDur <= 0){ shakeX = 0; shakeY = 0; }
  }

  updateParticles(dt);
}

function updateParticles(dt){
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx * 60 * dt;
    p.y += p.vy * 60 * dt;
    p.vy += 120 * dt; // gravity
    p.life -= dt;
    if(p.life <= 0) particles.splice(i, 1);
  }
  for(let i = rings.length - 1; i >= 0; i--){
    const r = rings[i];
    r.r += (r.maxR - 10) / r.maxLife * dt;
    r.life -= dt;
    if(r.life <= 0) rings.splice(i, 1);
  }
  for(let i = pops.length - 1; i >= 0; i--){
    const p = pops[i];
    p.y += p.vy * dt;
    p.life -= dt;
    if(p.life <= 0) pops.splice(i, 1);
  }
}

/* ── DRAW ── */
function draw(){
  ctx.save();
  ctx.translate(shakeX, shakeY);

  // Background gradient
  const bgGrad = ctx.createLinearGradient(0, 0, 0, cH);
  bgGrad.addColorStop(0, '#0f0f23');
  bgGrad.addColorStop(0.5, '#1a1a2e');
  bgGrad.addColorStop(1, '#16213e');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(-20, -20, cW + 40, cH + 40);

  // Vignette
  const vigGrad = ctx.createRadialGradient(cW/2, cH/2, cW*0.3, cW/2, cH/2, cW*0.9);
  vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
  vigGrad.addColorStop(1, 'rgba(0,0,0,0.4)');
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, cW, cH);

  // Road
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.fillRect(ROAD_LEFT, 0, ROAD_W, cH);

  // Lane separators
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  ctx.setLineDash([8, 12]);
  for(let i = 1; i < LANE_COUNT; i++){
    const x = ROAD_LEFT + i * LANE_W;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, cH);
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // Road edges
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(ROAD_LEFT, 0); ctx.lineTo(ROAD_LEFT, cH);
  ctx.moveTo(ROAD_RIGHT, 0); ctx.lineTo(ROAD_RIGHT, cH);
  ctx.stroke();

  if(state === 'playing' || state === 'gameover'){
    drawGates();
    drawPlayer();
    drawRings();
    drawParticles();
    drawPops();
    drawUI();

    // Heat edge tint
    if(heat > 40){
      const a = (heat - 40) / 60 * 0.25;
      ctx.fillStyle = `rgba(255,50,30,${a})`;
      ctx.fillRect(0, 0, 8, cH);
      ctx.fillRect(cW - 8, 0, 8, cH);
      ctx.fillRect(0, 0, cW, 6);
      ctx.fillRect(0, cH - 6, cW, 6);
    }

    // Near miss flash
    if(nearMissFlash > 0){
      ctx.fillStyle = `rgba(255,255,255,${nearMissFlash * 0.15})`;
      ctx.fillRect(0, 0, cW, cH);
    }
  }

  if(state === 'start') drawStartScreen();
  if(state === 'gameover') drawGameOverScreen();

  ctx.restore();
}

/* ── DRAW GATES ── */
function drawGates(){
  for(const g of gates){
    for(let i = 0; i < 3; i++){
      const lane = g.lanes[i];
      const lx = laneLeft(i);
      const ly = g.y;
      const lw = LANE_W;
      const lh = GATE_HEIGHT;

      // Panel background
      ctx.fillStyle = hsl(lane.color, 0.25);
      ctx.fillRect(lx + 2, ly, lw - 4, lh);

      // Lane type framing
      if(lane.type === 'safe'){
        // Clear solid border
        ctx.strokeStyle = hsl(lane.color, 0.8);
        ctx.lineWidth = 3;
        ctx.strokeRect(lx + 2, ly, lw - 4, lh);
      } else if(lane.type === 'risk'){
        // Hatch/diagonal pattern border
        ctx.strokeStyle = hslStr(40, 90, 60, 0.7);
        ctx.lineWidth = 2.5;
        ctx.strokeRect(lx + 2, ly, lw - 4, lh);
        // Diagonal lines
        ctx.save();
        ctx.beginPath();
        ctx.rect(lx + 2, ly, lw - 4, lh);
        ctx.clip();
        ctx.strokeStyle = hslStr(40, 90, 60, 0.2);
        ctx.lineWidth = 1.5;
        for(let d = -lh; d < lw + lh; d += 10){
          ctx.beginPath();
          ctx.moveTo(lx + 2 + d, ly);
          ctx.lineTo(lx + 2 + d - lh, ly + lh);
          ctx.stroke();
        }
        ctx.restore();
      } else if(lane.type === 'bonus'){
        // Shard icon border – golden glow
        ctx.strokeStyle = 'rgba(255,220,60,0.8)';
        ctx.lineWidth = 3;
        ctx.strokeRect(lx + 2, ly, lw - 4, lh);
        // Small shard icon in corner
        ctx.fillStyle = 'rgba(255,220,60,0.9)';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('◇', lx + 6, ly + 14);
      }

      // Symbol in center
      ctx.fillStyle = hsl(lane.color, 0.9);
      ctx.font = 'bold 22px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(lane.symbol, lx + lw/2, ly + lh/2);

      // Accessibility: small label under symbol
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.font = '8px sans-serif';
      ctx.fillText(SYMBOL_LABELS[lane.symbol] || '', lx + lw/2, ly + lh/2 + 16);

      // Lane type label at top
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.font = 'bold 7px sans-serif';
      const label = lane.type === 'safe' ? 'SAFE' : lane.type === 'risk' ? 'RISK' : 'BONUS';
      ctx.fillText(label, lx + lw/2, ly + 9);
    }
  }
}

/* ── DRAW PLAYER ── */
function drawPlayer(){
  const px = laneX(playerLane);
  const py = cH - 90;

  // Pulse when heat > 60
  let pulseR = 0;
  if(heat > 60){
    pulseR = Math.sin(gameTime * 10) * 4 * ((heat - 60) / 40);
  }

  const r = PLAYER_SIZE + pulseR;

  // Outline thickness scales with heat
  const outlineW = 2 + heat / 20;

  // Glow
  ctx.shadowColor = hsl(playerColor, 0.6);
  ctx.shadowBlur = 12 + heat * 0.15;

  // Body
  ctx.beginPath();
  ctx.arc(px, py, r, 0, Math.PI * 2);
  ctx.fillStyle = hsl(playerColor, 0.85);
  ctx.fill();

  // Outline
  ctx.lineWidth = outlineW;
  ctx.strokeStyle = hsl(playerColor, 1);
  ctx.stroke();

  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;

  // Symbol inside
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.round(r * 0.9)}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(playerSymbol, px, py + 1);
}

/* ── DRAW EFFECTS ── */
function drawRings(){
  for(const r of rings){
    const a = r.life / r.maxLife;
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);
    ctx.strokeStyle = typeof r.col === 'string' && r.col.startsWith('rgba') ? r.col : r.col;
    ctx.globalAlpha = a * 0.6;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
}

function drawParticles(){
  for(const p of particles){
    const a = p.life / p.maxLife;
    ctx.globalAlpha = a;
    ctx.fillStyle = p.col;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * a, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawPops(){
  for(const p of pops){
    const a = p.life / p.maxLife;
    ctx.globalAlpha = a;
    ctx.fillStyle = p.col;
    ctx.font = `bold 14px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.text, p.x, p.y);
  }
  ctx.globalAlpha = 1;
}

/* ── DRAW UI ── */
function drawUI(){
  // Score – top center
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 28px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(score, cW / 2, 16);

  // Best – under score
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.font = '12px sans-serif';
  ctx.fillText(`BEST: ${best}`, cW / 2, 48);

  // Combo – top left
  if(combo > 0){
    ctx.fillStyle = comboMult >= 4 ? '#ffdd44' : comboMult >= 3 ? '#ff8844' : comboMult >= 2 ? '#66ddff' : '#aaa';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`x${comboMult}`, 12, 18);
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.font = '10px sans-serif';
    ctx.fillText(`${combo} streak`, 12, 38);
  }

  // Shards – under combo
  if(shards > 0){
    ctx.fillStyle = '#ffdd44';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`◇ ${shards}`, 12, 56);
  }

  // Heat bar – top right
  const barW = 80, barH = 10;
  const barX = cW - barW - 12;
  const barY = 18;
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.fillRect(barX, barY, barW, barH);

  const heatFrac = heat / HEAT_MAX;
  const heatColor = heatFrac > 0.7 ? '#ff3333' : heatFrac > 0.4 ? '#ff8833' : '#44cc44';
  ctx.fillStyle = heatColor;
  ctx.fillRect(barX, barY, barW * heatFrac, barH);

  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1;
  ctx.strokeRect(barX, barY, barW, barH);

  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.font = '8px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText('HEAT', barX + barW, barY + barH + 10);

  // Heat percentage
  ctx.fillStyle = heatColor;
  ctx.font = 'bold 10px sans-serif';
  ctx.fillText(`${Math.round(heat)}%`, barX - 4, barY + barH - 1);
}

/* ── SCREENS ── */
function drawStartScreen(){
  // Dim overlay
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(0, 0, cW, cH);

  // Title
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 42px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Color Dash', cW/2, cH * 0.3);

  // Subtitle
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.font = '15px sans-serif';
  ctx.fillText('Match colors & symbols through gates', cW/2, cH * 0.3 + 40);

  // Symbols decoration
  ctx.font = '28px sans-serif';
  const deco = SYMBOLS.join('  ');
  for(let i = 0; i < PALETTE.length; i++){
    ctx.fillStyle = hsl(PALETTE[i], 0.7);
    ctx.fillText(SYMBOLS[i], cW/2 - 60 + i * 40, cH * 0.3 + 80);
  }

  // Instructions
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.font = '13px sans-serif';
  ctx.fillText('SAFE = match both (cools heat, builds combo)', cW/2, cH * 0.55);
  ctx.fillText('RISK = partial match (adds heat)', cW/2, cH * 0.55 + 22);
  ctx.fillText('BONUS = any lane (shard + big heat)', cW/2, cH * 0.55 + 44);

  // Tap to start
  const pulse = 0.6 + Math.sin(performance.now() * 0.004) * 0.4;
  ctx.globalAlpha = pulse;
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 20px sans-serif';
  ctx.fillText('Tap to Start', cW/2, cH * 0.78);
  ctx.globalAlpha = 1;

  // Best score
  if(best > 0){
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.font = '14px sans-serif';
    ctx.fillText(`Best: ${best}`, cW/2, cH * 0.85);
  }

  // Controls hint
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.font = '11px sans-serif';
  ctx.fillText('Tap / Space / Enter to switch lanes', cW/2, cH * 0.92);
}

function drawGameOverScreen(){
  // Overlay
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(0, 0, cW, cH);

  // Reason
  ctx.fillStyle = '#ff5555';
  ctx.font = 'bold 32px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(overReason, cW/2, cH * 0.28);

  // Score
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 48px sans-serif';
  ctx.fillText(score, cW/2, cH * 0.4);

  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.font = '14px sans-serif';
  ctx.fillText('SCORE', cW/2, cH * 0.4 - 35);

  // Best
  ctx.fillStyle = score >= best ? '#ffdd44' : 'rgba(255,255,255,0.6)';
  ctx.font = 'bold 20px sans-serif';
  ctx.fillText(`Best: ${best}`, cW/2, cH * 0.5);
  if(score >= best && score > 0){
    ctx.fillStyle = '#ffdd44';
    ctx.font = '13px sans-serif';
    ctx.fillText('★ NEW BEST! ★', cW/2, cH * 0.5 + 24);
  }

  // Stats
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.font = '13px sans-serif';
  ctx.fillText(`Shards: ${shards}  |  Max Combo: x${comboMult}`, cW/2, cH * 0.6);

  // Retry
  const elapsed = performance.now() - retryLockTime;
  if(elapsed > RETRY_LOCK_MS){
    const pulse = 0.6 + Math.sin(performance.now() * 0.004) * 0.4;
    ctx.globalAlpha = pulse;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px sans-serif';
    ctx.fillText('Tap to Retry', cW/2, cH * 0.75);
    ctx.globalAlpha = 1;
  } else {
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.font = '16px sans-serif';
    ctx.fillText('...', cW/2, cH * 0.75);
  }
}

/* ── GAME LOOP ── */
let lastFrame = performance.now();
function loop(now){
  const dt = Math.min((now - lastFrame) / 1000, 0.05);
  lastFrame = now;

  update(dt);
  draw();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
