<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="theme-color" content="#0b1020">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0b1020;font-family:'Segoe UI',system-ui,sans-serif}
body{display:flex;flex-direction:column;align-items:center;justify-content:center}
#wrap{position:relative;width:100%;max-width:420px;height:100vh;max-height:750px;display:flex;flex-direction:column;align-items:center;padding-bottom:60px}
canvas{display:block;width:100%;height:100%;touch-action:manipulation;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}
#seo{color:#445;font-size:11px;text-align:center;padding:6px 12px;line-height:1.4;max-width:400px;position:absolute;bottom:2px;left:50%;transform:translateX(-50%)}
#seo a{color:#556}
</style>
</head>
<body>
<div id="wrap">
<canvas id="c"></canvas>
<div id="seo">How to play: Tap or press Space to switch lanes and cycle colors. Match the gate color to pass through. <a href="https://balinti.github.io/color-dash/">Color Dash</a></div>
</div>
<script>
"use strict";
(()=>{
/* ===== SEEDED RNG ===== */
const urlP=new URLSearchParams(location.search);
const SEED=urlP.get('seed')||'';
const IS_CHALLENGE=urlP.get('challenge')==='1'&&SEED.length>0;
let challengeScore=parseInt(urlP.get('score'))||0;

function mulberry32(a){return()=>{a|=0;a=a+0x6D2B79F5|0;let t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296}}
function hashStr(s){let h=0;for(let i=0;i<s.length;i++){h=Math.imul(31,h)+s.charCodeAt(i)|0}return h>>>0}
const seededRng=SEED?mulberry32(hashStr(SEED)):null;
function sRng(){return seededRng?seededRng():Math.random()}

/* ===== CANVAS SETUP ===== */
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
const W=420,H=750;
const dpr=Math.min(window.devicePixelRatio||1,2);

function resize(){
  const wrap=document.getElementById('wrap');
  const rect=wrap.getBoundingClientRect();
  canvas.width=W*dpr;
  canvas.height=H*dpr;
  canvas.style.width=rect.width+'px';
  canvas.style.height=rect.height+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
resize();
window.addEventListener('resize',resize);

/* ===== CONSTANTS ===== */
const SUITS=['R','B','Y'];
const SUIT_COLORS={R:'hsl(0,80%,55%)',B:'hsl(220,80%,55%)',Y:'hsl(50,90%,55%)'};
const SUIT_DARK={R:'hsl(0,60%,35%)',B:'hsl(220,60%,35%)',Y:'hsl(50,70%,35%)'};
const SUIT_NAMES={R:'Red',B:'Blue',Y:'Yellow'};
const LANE_X=[W*0.25, W*0.75];
const LANE_W=140;
const GATE_H=56;
const PLAYER_Y=H-110;
const PLAYER_R=22;
const SCRAPE_THRESHOLD=12;
const GAMEOVER_LOCK=800;

/* ===== GAME STATE ===== */
let state='start'; // start | playing | gameover
let score=0, bestScore=0, combo=0, maxCombo=0, multiplier=1;
let playerLane=0, playerSuit=0;
let gates=[], particles=[];
let speed=2.2, baseSpeed=2.2;
let shakeX=0, shakeY=0, shakeMag=0, shakeDecay=0;
let slowmoTimer=0, slowmoFactor=1;
let gameoverTime=0;
let hueShift=0;
let gateSpawnTimer=0;
let laneOffset=0; // offset between lanes
let splitGateNext=false, lockGateNext=false, comboGateNext=false;
let tick=0;
let dailyLabel='';

/* ===== LOAD BEST ===== */
try{bestScore=parseInt(localStorage.getItem('colorDashBest'))||0}catch(e){}

/* ===== SUIT DRAWING HELPERS ===== */
function drawSuitIcon(cx,cy,suit,size,alpha){
  ctx.globalAlpha=alpha||1;
  const s=size||16;
  if(suit==='R'){
    // Triangle + stripes
    ctx.beginPath();
    ctx.moveTo(cx,cy-s);
    ctx.lineTo(cx+s*0.9,cy+s*0.7);
    ctx.lineTo(cx-s*0.9,cy+s*0.7);
    ctx.closePath();
    ctx.fillStyle=SUIT_COLORS.R;
    ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.7)';
    ctx.lineWidth=1.5;
    ctx.stroke();
    // Stripes
    ctx.save();
    ctx.clip();
    ctx.strokeStyle='rgba(255,255,255,0.4)';
    ctx.lineWidth=2;
    for(let i=-3;i<=3;i++){
      ctx.beginPath();
      ctx.moveTo(cx+i*6-s,cy-s);
      ctx.lineTo(cx+i*6+s,cy+s);
      ctx.stroke();
    }
    ctx.restore();
  } else if(suit==='B'){
    // Circle + dots
    ctx.beginPath();
    ctx.arc(cx,cy,s*0.85,0,Math.PI*2);
    ctx.fillStyle=SUIT_COLORS.B;
    ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.7)';
    ctx.lineWidth=1.5;
    ctx.stroke();
    // Dots
    ctx.fillStyle='rgba(255,255,255,0.45)';
    const dotR=s*0.14;
    for(let dy=-1;dy<=1;dy++){
      for(let dx=-1;dx<=1;dx++){
        if(dx===0&&dy===0)continue;
        ctx.beginPath();
        ctx.arc(cx+dx*s*0.4,cy+dy*s*0.4,dotR,0,Math.PI*2);
        ctx.fill();
      }
    }
  } else {
    // Square + checker
    const hs=s*0.8;
    ctx.fillStyle=SUIT_COLORS.Y;
    ctx.fillRect(cx-hs,cy-hs,hs*2,hs*2);
    ctx.strokeStyle='rgba(255,255,255,0.7)';
    ctx.lineWidth=1.5;
    ctx.strokeRect(cx-hs,cy-hs,hs*2,hs*2);
    // Checker
    ctx.fillStyle='rgba(255,255,255,0.3)';
    const cs=hs*0.5;
    for(let r=0;r<4;r++){
      for(let c=0;c<4;c++){
        if((r+c)%2===0){
          ctx.fillRect(cx-hs+c*cs,cy-hs+r*cs,cs,cs);
        }
      }
    }
  }
  ctx.globalAlpha=1;
}

function drawPattern(x,y,w,h,suit,alpha){
  ctx.globalAlpha=alpha||0.18;
  ctx.strokeStyle='#fff';
  ctx.lineWidth=1.2;
  if(suit==='R'){
    for(let i=-8;i<=8;i++){
      ctx.beginPath();
      ctx.moveTo(x+i*10,y);
      ctx.lineTo(x+i*10+h,y+h);
      ctx.stroke();
    }
  } else if(suit==='B'){
    for(let dy=0;dy<h;dy+=10){
      for(let dx=0;dx<w;dx+=10){
        ctx.beginPath();
        ctx.arc(x+dx+5,y+dy+5,2,0,Math.PI*2);
        ctx.stroke();
      }
    }
  } else {
    for(let dy=0;dy<h;dy+=8){
      for(let dx=0;dx<w;dx+=8){
        if(((dx/8|0)+(dy/8|0))%2===0){
          ctx.fillStyle='rgba(255,255,255,0.15)';
          ctx.fillRect(x+dx,y+dy,8,8);
        }
      }
    }
  }
  ctx.globalAlpha=1;
}

/* ===== GATE SYSTEM ===== */
function createGate(lane, suit, special){
  return{
    lane, suit:SUITS[suit],
    y:-GATE_H,
    special:special||'normal',
    passed:false,
    scraped:false,
    w:LANE_W, h:GATE_H
  };
}

function spawnGates(){
  const s0=Math.floor(sRng()*3);
  let s1=Math.floor(sRng()*3);
  // Ensure not always same
  if(sRng()<0.6) s1=(s0+1+Math.floor(sRng()*2))%3;

  let special='normal';
  if(score>=30&&splitGateNext){special='split';splitGateNext=false;}
  else if(score>=20&&lockGateNext){special='lock';lockGateNext=false;}
  else if(score>=15&&comboGateNext){special='combo';comboGateNext=false;}

  if(special==='split'){
    // Both lanes same y, forces commitment
    const s=Math.floor(sRng()*3);
    gates.push(createGate(0,s,'split'));
    gates.push(createGate(1,(s+1+Math.floor(sRng()*2))%3,'split'));
  } else if(special==='combo'){
    // Same suit twice on one lane
    const lane=Math.floor(sRng()*2);
    const s=Math.floor(sRng()*3);
    gates.push(createGate(lane,s,'combo'));
    gates.push(createGate(1-lane,s1,'normal'));
    // Queue another same-suit gate soon
    setTimeout(()=>{
      if(state==='playing'){
        gates.push(createGate(lane,s,'combo'));
      }
    },300);
  } else {
    gates.push(createGate(0,s0,special));
    // Offset for lane 1
    const offset=laneOffset;
    const g1=createGate(1,s1,special);
    g1.y=-GATE_H-offset;
    gates.push(g1);
  }
}

/* ===== PARTICLES ===== */
function emitParticles(x,y,color,count,spread,life){
  for(let i=0;i<count;i++){
    const angle=Math.random()*Math.PI*2;
    const spd=Math.random()*spread+1;
    particles.push({
      x,y,
      vx:Math.cos(angle)*spd,
      vy:Math.sin(angle)*spd-1,
      life:life||40+Math.random()*30,
      maxLife:life||40+Math.random()*30,
      color,
      size:3+Math.random()*4
    });
  }
}

/* ===== SCREEN SHAKE ===== */
function startShake(mag,decay){
  shakeMag=mag;
  shakeDecay=decay||0.9;
}

/* ===== DIFFICULTY ===== */
function updateDifficulty(){
  baseSpeed=2.2+score*0.04;
  if(baseSpeed>7)baseSpeed=7;
  speed=baseSpeed;
  laneOffset=Math.min(score*1.5,60);
  // Milestone specials
  if(score>0&&score%12===0)splitGateNext=true;
  if(score>0&&score%8===0)lockGateNext=true;
  if(score>0&&score%10===0)comboGateNext=true;
}

/* ===== INPUT ===== */
function doAction(){
  if(state==='start'){
    startGame();
  } else if(state==='playing'){
    playerLane=1-playerLane;
    playerSuit=(playerSuit+1)%3;
  } else if(state==='gameover'){
    if(performance.now()-gameoverTime>GAMEOVER_LOCK){
      // Check if tapped share button
      // Otherwise retry
      startGame();
    }
  }
}

let shareBtn={x:0,y:0,w:0,h:0,visible:false};

function handleInput(ex,ey){
  if(state==='gameover'&&shareBtn.visible){
    const rect=canvas.getBoundingClientRect();
    const scaleX=W/rect.width;
    const scaleY=H/rect.height;
    const cx=ex*scaleX;
    const cy=ey*scaleY;
    if(cx>=shareBtn.x&&cx<=shareBtn.x+shareBtn.w&&cy>=shareBtn.y&&cy<=shareBtn.y+shareBtn.h){
      shareChallenge();
      return;
    }
  }
  doAction();
}

canvas.addEventListener('pointerdown',(e)=>{
  e.preventDefault();
  const rect=canvas.getBoundingClientRect();
  handleInput(e.clientX-rect.left,e.clientY-rect.top);
},{passive:false});

document.addEventListener('keydown',(e)=>{
  if(e.code==='Space'||e.code==='Enter'){
    e.preventDefault();
    doAction();
  }
});

// Prevent scrolling/zooming
document.addEventListener('touchmove',(e)=>{e.preventDefault()},{passive:false});

/* ===== SHARE/CHALLENGE ===== */
function shareChallenge(){
  const seed=SEED||Math.random().toString(36).slice(2,8);
  const url=`https://balinti.github.io/color-dash/?seed=${seed}&challenge=1&score=${score}`;
  const text=`I scored ${score} in Color Dash! Can you beat me?`;
  if(navigator.share){
    navigator.share({title:'Color Dash Challenge',text,url}).catch(()=>{});
  } else if(navigator.clipboard){
    navigator.clipboard.writeText(text+' '+url).then(()=>{
      shareBtn.copied=true;
      setTimeout(()=>{shareBtn.copied=false},2000);
    }).catch(()=>{});
  }
}

/* ===== GAME LIFECYCLE ===== */
function startGame(){
  state='playing';
  score=0;combo=0;maxCombo=0;multiplier=1;
  playerLane=0;playerSuit=0;
  gates=[];particles=[];
  speed=2.2;baseSpeed=2.2;
  shakeX=0;shakeY=0;shakeMag=0;
  slowmoTimer=0;slowmoFactor=1;
  gateSpawnTimer=0;laneOffset=0;
  splitGateNext=false;lockGateNext=false;comboGateNext=false;
  tick=0;
  shareBtn.visible=false;
  if(IS_CHALLENGE){
    dailyLabel='Challenge: '+SEED;
  }
  spawnGates();
}

function endGame(){
  state='gameover';
  gameoverTime=performance.now();
  startShake(12,0.88);
  // Death particles
  const px=LANE_X[playerLane];
  emitParticles(px,PLAYER_Y,SUIT_COLORS[SUITS[playerSuit]],40,6,60);
  emitParticles(px,PLAYER_Y,'#fff',15,4,50);
  if(score>bestScore){
    bestScore=score;
    try{localStorage.setItem('colorDashBest',bestScore)}catch(e){}
  }
  shareBtn.visible=true;
}

/* ===== UPDATE ===== */
function update(dt){
  tick++;
  hueShift+=0.3;

  if(state!=='playing')return;

  // Slowmo
  if(slowmoTimer>0){
    slowmoTimer-=dt;
    slowmoFactor=0.3;
    if(slowmoTimer<=0)slowmoFactor=1;
  }

  const eff=speed*slowmoFactor;

  // Spawn gates
  gateSpawnTimer+=eff;
  const spawnInterval=Math.max(100,180-score*0.8);
  if(gateSpawnTimer>=spawnInterval){
    gateSpawnTimer=0;
    spawnGates();
  }

  // Move gates
  for(let i=gates.length-1;i>=0;i--){
    const g=gates[i];
    g.y+=eff;

    // Check collision with player
    if(!g.passed && g.lane===playerLane){
      const gTop=g.y;
      const gBot=g.y+g.h;
      const pTop=PLAYER_Y-PLAYER_R;
      const pBot=PLAYER_Y+PLAYER_R;

      if(gBot>pTop && gTop<pBot){
        if(g.suit===SUITS[playerSuit]){
          // Match!
          g.passed=true;
          score++;
          combo++;
          if(combo>maxCombo)maxCombo=combo;
          multiplier=Math.min(6,1+Math.floor(combo/3));
          updateDifficulty();
          emitParticles(LANE_X[g.lane],g.y+g.h/2,SUIT_COLORS[g.suit],8,3,30);
          if(multiplier>=4)startShake(2,0.85);
        } else {
          // Wrong suit
          const overlap=Math.min(gBot-pTop,pBot-gTop);
          if(overlap<SCRAPE_THRESHOLD&&!g.scraped){
            // Scrape - near miss forgiveness
            g.scraped=true;
            g.passed=true;
            score++;
            combo=0;
            multiplier=1;
            slowmoTimer=130;
            updateDifficulty();
            emitParticles(LANE_X[g.lane],PLAYER_Y,'#ff8800',12,4,25);
            startShake(3,0.9);
          } else if(overlap>=SCRAPE_THRESHOLD){
            endGame();
            return;
          }
        }
      }
    }

    // Remove off-screen gates
    if(g.y>H+50){
      gates.splice(i,1);
    }
  }

  // Shake
  if(shakeMag>0.5){
    shakeX=(Math.random()-0.5)*shakeMag;
    shakeY=(Math.random()-0.5)*shakeMag;
    shakeMag*=shakeDecay;
  } else {
    shakeX=0;shakeY=0;shakeMag=0;
  }

  // Particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx;
    p.y+=p.vy;
    p.vy+=0.1;
    p.life--;
    if(p.life<=0)particles.splice(i,1);
  }
}

/* ===== DRAW ===== */
function drawBackground(){
  const grad=ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,`hsl(${230+Math.sin(hueShift*0.01)*10},30%,8%)`);
  grad.addColorStop(1,`hsl(${250+Math.sin(hueShift*0.015)*10},25%,12%)`);
  ctx.fillStyle=grad;
  ctx.fillRect(0,0,W,H);

  // Lane tints
  ctx.fillStyle='rgba(255,255,255,0.015)';
  ctx.fillRect(LANE_X[0]-LANE_W/2,0,LANE_W,H);
  ctx.fillStyle='rgba(255,255,255,0.025)';
  ctx.fillRect(LANE_X[1]-LANE_W/2,0,LANE_W,H);

  // Lane divider
  ctx.setLineDash([8,12]);
  ctx.strokeStyle='rgba(255,255,255,0.08)';
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(W/2,0);
  ctx.lineTo(W/2,H);
  ctx.stroke();
  ctx.setLineDash([]);

  // Lane borders
  ctx.strokeStyle='rgba(255,255,255,0.04)';
  ctx.lineWidth=1;
  for(const lx of LANE_X){
    ctx.beginPath();
    ctx.moveTo(lx-LANE_W/2,0);ctx.lineTo(lx-LANE_W/2,H);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(lx+LANE_W/2,0);ctx.lineTo(lx+LANE_W/2,H);
    ctx.stroke();
  }
}

function drawGate(g){
  const x=LANE_X[g.lane]-g.w/2;
  const y=g.y;
  const suit=g.suit;
  const col=SUIT_COLORS[suit];
  const dark=SUIT_DARK[suit];

  // Gate body
  ctx.fillStyle=dark;
  ctx.globalAlpha=0.7;
  const r=8;
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+g.w-r,y);
  ctx.quadraticCurveTo(x+g.w,y,x+g.w,y+r);
  ctx.lineTo(x+g.w,y+g.h-r);
  ctx.quadraticCurveTo(x+g.w,y+g.h,x+g.w-r,y+g.h);
  ctx.lineTo(x+r,y+g.h);
  ctx.quadraticCurveTo(x,y+g.h,x,y+g.h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
  ctx.fill();
  ctx.globalAlpha=1;

  // Pattern overlay
  ctx.save();
  ctx.beginPath();
  ctx.rect(x,y,g.w,g.h);
  ctx.clip();
  drawPattern(x,y,g.w,g.h,suit,0.15);
  ctx.restore();

  // Border
  ctx.strokeStyle=col;
  ctx.lineWidth=2.5;
  ctx.globalAlpha=0.9;
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+g.w-r,y);
  ctx.quadraticCurveTo(x+g.w,y,x+g.w,y+r);
  ctx.lineTo(x+g.w,y+g.h-r);
  ctx.quadraticCurveTo(x+g.w,y+g.h,x+g.w-r,y+g.h);
  ctx.lineTo(x+r,y+g.h);
  ctx.quadraticCurveTo(x,y+g.h,x,y+g.h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
  ctx.stroke();
  ctx.globalAlpha=1;

  // Suit icon in center
  drawSuitIcon(LANE_X[g.lane],y+g.h/2,suit,14,0.9);

  // Special markers
  if(g.special==='split'){
    ctx.fillStyle='#fff';
    ctx.globalAlpha=0.6;
    ctx.font='bold 10px sans-serif';
    ctx.textAlign='center';
    ctx.fillText('SPLIT',LANE_X[g.lane],y+g.h-4);
    ctx.globalAlpha=1;
  } else if(g.special==='lock'){
    // Show preview dots
    ctx.fillStyle='rgba(255,255,255,0.5)';
    ctx.font='9px sans-serif';
    ctx.textAlign='center';
    ctx.fillText('LOCK',LANE_X[g.lane],y+12);
    // Show next 2 gates for this lane as small icons
    let preview=gates.filter(gg=>gg.lane===g.lane&&gg.y<g.y&&!gg.passed).slice(0,2);
    for(let pi=0;pi<preview.length;pi++){
      drawSuitIcon(LANE_X[g.lane]-20+pi*40,y+g.h-10,preview[pi].suit,6,0.6);
    }
  } else if(g.special==='combo'){
    ctx.fillStyle='#fff';
    ctx.globalAlpha=0.6;
    ctx.font='bold 10px sans-serif';
    ctx.textAlign='center';
    ctx.fillText('COMBO',LANE_X[g.lane],y+g.h-4);
    ctx.globalAlpha=1;
  }
}

function drawPlayer(){
  const px=LANE_X[playerLane];
  const py=PLAYER_Y;
  const suit=SUITS[playerSuit];
  const col=SUIT_COLORS[suit];

  // Glow
  const glow=ctx.createRadialGradient(px,py,0,px,py,PLAYER_R*2.5);
  glow.addColorStop(0,col.replace('55%','55%').replace(')',',0.25)').replace('hsl','hsla'));
  glow.addColorStop(1,'transparent');
  ctx.fillStyle=glow;
  ctx.beginPath();
  ctx.arc(px,py,PLAYER_R*2.5,0,Math.PI*2);
  ctx.fill();

  // Body circle
  ctx.beginPath();
  ctx.arc(px,py,PLAYER_R,0,Math.PI*2);
  ctx.fillStyle=SUIT_DARK[suit];
  ctx.fill();
  ctx.strokeStyle=col;
  ctx.lineWidth=3;
  ctx.stroke();

  // Suit icon
  drawSuitIcon(px,py,suit,10,1);

  // Direction indicator
  ctx.fillStyle='rgba(255,255,255,0.3)';
  ctx.beginPath();
  const arrowX=playerLane===0?px+PLAYER_R+8:px-PLAYER_R-8;
  const dir=playerLane===0?1:-1;
  ctx.moveTo(arrowX,py-6);
  ctx.lineTo(arrowX+dir*8,py);
  ctx.lineTo(arrowX,py+6);
  ctx.closePath();
  ctx.fill();
}

function drawParticles(){
  for(const p of particles){
    const alpha=p.life/p.maxLife;
    ctx.globalAlpha=alpha;
    ctx.fillStyle=p.color;
    ctx.fillRect(p.x-p.size/2,p.y-p.size/2,p.size,p.size);
  }
  ctx.globalAlpha=1;
}

function drawHUD(){
  // Score
  ctx.fillStyle='#fff';
  ctx.font='bold 28px sans-serif';
  ctx.textAlign='center';
  ctx.fillText(score,W/2,45);

  // Multiplier
  if(multiplier>1){
    const mCol=`hsl(${(hueShift*2)%360},80%,65%)`;
    ctx.fillStyle=mCol;
    ctx.font='bold 18px sans-serif';
    ctx.fillText('x'+multiplier,W/2,70);
  }

  // Combo
  if(combo>2){
    ctx.fillStyle='rgba(255,255,255,0.5)';
    ctx.font='12px sans-serif';
    ctx.fillText(combo+' combo',W/2,88);
  }

  // Best score
  ctx.fillStyle='rgba(255,255,255,0.3)';
  ctx.font='11px sans-serif';
  ctx.textAlign='right';
  ctx.fillText('BEST: '+bestScore,W-16,28);

  // Current suit indicator top-left
  ctx.textAlign='left';
  drawSuitIcon(28,28,SUITS[playerSuit],10,0.7);
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.font='11px sans-serif';
  ctx.fillText(SUIT_NAMES[SUITS[playerSuit]],46,32);

  // Challenge label
  if(IS_CHALLENGE&&dailyLabel){
    ctx.fillStyle='rgba(255,200,50,0.6)';
    ctx.font='bold 11px sans-serif';
    ctx.textAlign='center';
    ctx.fillText(dailyLabel,W/2,H-16);
  }
  if(IS_CHALLENGE&&challengeScore>0){
    ctx.fillStyle='rgba(255,200,50,0.4)';
    ctx.font='10px sans-serif';
    ctx.textAlign='center';
    ctx.fillText('Score to beat: '+challengeScore,W/2,H-4);
  }
}

function drawStartScreen(){
  drawBackground();

  // Title
  ctx.fillStyle='#fff';
  ctx.font='bold 42px sans-serif';
  ctx.textAlign='center';
  ctx.fillText('COLOR DASH',W/2,200);

  // Subtitle
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.font='16px sans-serif';
  ctx.fillText('Split Rush',W/2,235);

  // Suit icons showcase
  drawSuitIcon(W/2-70,310,'R',20,0.8);
  drawSuitIcon(W/2,310,'B',20,0.8);
  drawSuitIcon(W/2+70,310,'Y',20,0.8);

  // Labels
  ctx.font='11px sans-serif';
  ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.fillText('Red',W/2-70,345);
  ctx.fillText('Blue',W/2,345);
  ctx.fillText('Yellow',W/2+70,345);

  // Instructions
  ctx.fillStyle='rgba(255,255,255,0.6)';
  ctx.font='14px sans-serif';
  ctx.fillText('Tap / Space / Enter',W/2,410);
  ctx.fillText('Switch lane + Cycle color',W/2,432);
  ctx.fillText('Match the gate color to pass!',W/2,460);

  // Colorblind note
  ctx.fillStyle='rgba(255,255,255,0.3)';
  ctx.font='11px sans-serif';
  ctx.fillText('Colorblind friendly: icons & patterns',W/2,495);

  // Tap prompt
  const pulse=0.5+Math.sin(tick*0.06)*0.3;
  ctx.globalAlpha=pulse;
  ctx.fillStyle='#fff';
  ctx.font='bold 20px sans-serif';
  ctx.fillText('TAP TO START',W/2,580);
  ctx.globalAlpha=1;

  // Best score
  if(bestScore>0){
    ctx.fillStyle='rgba(255,255,255,0.4)';
    ctx.font='13px sans-serif';
    ctx.fillText('Best: '+bestScore,W/2,620);
  }

  // Challenge info
  if(IS_CHALLENGE){
    ctx.fillStyle='rgba(255,200,50,0.7)';
    ctx.font='bold 13px sans-serif';
    ctx.fillText('Challenge Mode: '+SEED,W/2,650);
    if(challengeScore>0){
      ctx.fillText('Score to beat: '+challengeScore,W/2,670);
    }
  }
}

function drawGameOverScreen(){
  // Dim overlay
  ctx.fillStyle='rgba(0,0,0,0.55)';
  ctx.fillRect(0,0,W,H);

  // Game Over
  ctx.fillStyle='#fff';
  ctx.font='bold 36px sans-serif';
  ctx.textAlign='center';
  ctx.fillText('GAME OVER',W/2,250);

  // Score
  ctx.font='bold 60px sans-serif';
  ctx.fillText(score,W/2,340);

  // Max combo
  if(maxCombo>2){
    ctx.fillStyle='rgba(255,255,255,0.6)';
    ctx.font='16px sans-serif';
    ctx.fillText('Max Combo: '+maxCombo,W/2,375);
  }

  // New best
  if(score>=bestScore&&score>0){
    ctx.fillStyle='hsl(50,90%,60%)';
    ctx.font='bold 18px sans-serif';
    ctx.fillText('NEW BEST!',W/2,405);
  }

  // Best
  ctx.fillStyle='rgba(255,255,255,0.4)';
  ctx.font='14px sans-serif';
  ctx.fillText('Best: '+bestScore,W/2,435);

  // Challenge result
  if(IS_CHALLENGE&&challengeScore>0){
    if(score>challengeScore){
      ctx.fillStyle='hsl(120,70%,55%)';
      ctx.font='bold 16px sans-serif';
      ctx.fillText('You beat the challenge!',W/2,470);
    } else {
      ctx.fillStyle='hsl(0,70%,60%)';
      ctx.font='14px sans-serif';
      ctx.fillText('Challenge score: '+challengeScore,W/2,470);
    }
  }

  // Share button
  const btnW=200,btnH=44;
  const btnX=W/2-btnW/2;
  const btnY=500;
  shareBtn.x=btnX;shareBtn.y=btnY;shareBtn.w=btnW;shareBtn.h=btnH;

  ctx.fillStyle='hsl(260,60%,45%)';
  ctx.beginPath();
  const br=10;
  ctx.moveTo(btnX+br,btnY);
  ctx.lineTo(btnX+btnW-br,btnY);
  ctx.quadraticCurveTo(btnX+btnW,btnY,btnX+btnW,btnY+br);
  ctx.lineTo(btnX+btnW,btnY+btnH-br);
  ctx.quadraticCurveTo(btnX+btnW,btnY+btnH,btnX+btnW-br,btnY+btnH);
  ctx.lineTo(btnX+br,btnY+btnH);
  ctx.quadraticCurveTo(btnX,btnY+btnH,btnX,btnY+btnH-br);
  ctx.lineTo(btnX,btnY+br);
  ctx.quadraticCurveTo(btnX,btnY,btnX+br,btnY);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle='#fff';
  ctx.font='bold 15px sans-serif';
  if(shareBtn.copied){
    ctx.fillText('Link Copied!',W/2,btnY+btnH/2+5);
  } else {
    ctx.fillText('Challenge a Friend',W/2,btnY+btnH/2+5);
  }

  // Retry prompt
  const elapsed=performance.now()-gameoverTime;
  if(elapsed>GAMEOVER_LOCK){
    const pulse=0.4+Math.sin(tick*0.06)*0.3;
    ctx.globalAlpha=pulse;
    ctx.fillStyle='#fff';
    ctx.font='16px sans-serif';
    ctx.fillText('Tap to Retry',W/2,600);
    ctx.globalAlpha=1;
  }
}

/* ===== MAIN LOOP ===== */
let lastTime=0;

function frame(time){
  const dt=Math.min(time-lastTime,50);
  lastTime=time;

  tick++;
  update(dt);

  ctx.save();
  ctx.translate(shakeX,shakeY);

  if(state==='start'){
    drawStartScreen();
  } else {
    drawBackground();
    // Draw gates
    for(const g of gates) drawGate(g);
    drawPlayer();
    drawParticles();
    drawHUD();
    if(state==='gameover') drawGameOverScreen();
  }

  ctx.restore();

  // Shake update for non-playing states
  if(state!=='playing'&&shakeMag>0.5){
    shakeX=(Math.random()-0.5)*shakeMag;
    shakeY=(Math.random()-0.5)*shakeMag;
    shakeMag*=shakeDecay;
  } else if(state!=='playing'){
    shakeX=0;shakeY=0;
  }

  // Particles update in non-playing
  if(state!=='playing'){
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.x+=p.vx;
      p.y+=p.vy;
      p.vy+=0.1;
      p.life--;
      if(p.life<=0)particles.splice(i,1);
    }
  }

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
})();
</script>
</body>
</html>