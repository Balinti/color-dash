<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#1a1a2e">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Play Color Dash: Paintline - Run through color gates matching your current color. Tap to switch between colors and lanes!">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og.svg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Play Color Dash: Paintline - Endless runner with color matching and perfect zones!">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og.svg">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0f0f23;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#eee;touch-action:manipulation;-webkit-tap-highlight-color:transparent;user-select:none;-webkit-user-select:none}
#wrap{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;height:100%;max-width:420px;max-height:750px;margin:0 auto;position:relative}
canvas{display:block;width:100%;height:100%;cursor:pointer;touch-action:none}
#info-toggle{position:fixed;bottom:8px;right:8px;background:rgba(255,255,255,.12);border:none;color:#aaa;font-size:13px;padding:4px 10px;border-radius:12px;cursor:pointer;z-index:10}
#info-toggle:hover{background:rgba(255,255,255,.2)}
#info-panel{position:fixed;bottom:40px;left:50%;transform:translateX(-50%);width:92%;max-width:400px;max-height:55vh;overflow-y:auto;background:#16162b;border:1px solid #333;border-radius:12px;padding:16px;font-size:13px;line-height:1.5;color:#ccc;z-index:10;display:none}
#info-panel.open{display:block}
#info-panel h3{color:#fff;margin:10px 0 4px;font-size:14px}
#info-panel h3:first-child{margin-top:0}
#info-panel p,#info-panel li{color:#bbb}
#info-panel ul{padding-left:18px}
</style>
</head>
<body>
<div id="wrap"><canvas id="c"></canvas></div>
<button id="info-toggle" aria-label="Toggle game info">&#x2139; Info</button>
<div id="info-panel" role="complementary">
<h3>About Color Dash: Paintline</h3>
<p>An endless forward runner with two lanes. Tap to switch your color and flip lanes. Match the gate color to pass through safely!</p>
<h3>How to Play</h3>
<ul>
<li>Tap screen, press Space or Enter to switch color &amp; lane</li>
<li>Match your color to the gate color to survive</li>
<li>Hit the bright center stripe for a Perfect bonus</li>
<li>3 consecutive Perfects earn a Paint Shield</li>
<li>Shield blocks one wrong-color hit</li>
</ul>
<h3>Gate Types</h3>
<ul>
<li><strong>Twin Gate</strong> &ndash; paired lanes, one matches your color</li>
<li><strong>Split Sequence</strong> &ndash; 3 quick gates in a row</li>
<li><strong>Wildcard Gate</strong> &ndash; any color passes; Perfect gives big bonus</li>
<li><strong>Swap Gate</strong> &ndash; auto-cycles your color on pass</li>
</ul>
<h3>FAQ</h3>
<p><strong>Q: Is this free?</strong> A: Yes, completely free to play in your browser.</p>
<p><strong>Q: Does it work on mobile?</strong> A: Yes, optimized for both mobile and desktop.</p>
<h3>Accessibility</h3>
<p>Colorblind-friendly: each color displays a unique pattern. Red&nbsp;=&nbsp;triangles, Green&nbsp;=&nbsp;circles, Blue&nbsp;=&nbsp;diagonal stripes. The perfect zone uses a high-contrast white/yellow stripe.</p>
</div>
<script>
'use strict';
(()=>{

/* ══════════════ CONSTANTS ══════════════ */
const COLORS=[
  {name:'Red',  fill:'hsl(0,80%,55%)',  dark:'hsl(0,55%,30%)',  light:'hsl(0,85%,70%)'},
  {name:'Green',fill:'hsl(140,65%,45%)',dark:'hsl(140,45%,25%)',light:'hsl(140,70%,60%)'},
  {name:'Blue', fill:'hsl(220,75%,55%)',dark:'hsl(220,50%,30%)',light:'hsl(220,80%,70%)'}
];
const PLAYER_R=15;
const GATE_THICK=20;
const PERFECT_BASE=10;
const PERFECT_MIN=3.5;
const SHIELD_COST=3;
const GRAZE_PX=7;
const LS_KEY='paintline_best';
const PI=Math.PI,TAU=PI*2;

/* ══════════════ CANVAS ══════════════ */
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
let W,H,DPR;
let laneY0,laneY1,laneH,playerBaseX;

function resize(){
  const wrap=document.getElementById('wrap');
  const r=wrap.getBoundingClientRect();
  DPR=Math.min(window.devicePixelRatio||1,3);
  W=r.width; H=r.height;
  canvas.width=Math.round(W*DPR);
  canvas.height=Math.round(H*DPR);
  canvas.style.width=W+'px';
  canvas.style.height=H+'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  laneH=H*0.28;
  laneY0=H*0.30;
  laneY1=H*0.62;
  playerBaseX=W*0.18;
}
window.addEventListener('resize',resize);
resize();

/* ══════════════ HELPERS ══════════════ */
const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
const lerp=(a,b,t)=>a+(b-a)*t;
const rand=(a,b)=>a+Math.random()*(b-a);
const randInt=(a,b)=>Math.floor(rand(a,b+0.999));

/* ══════════════ STATE ══════════════ */
let state='start';
let score,best,colorIdx,lane;
let gates,particles;
let perfectStreak,totalPerfects,maxCombo;
let shield,multiplier;
let shakeAmt,shakeDur;
let hitStop,invuln;
let hue,frameCount;
let playerVisY,playerTgtY;
let spawnCD;
let summaryPerfects,summaryMaxCombo,summaryShields;
let shareMsg='',shareMsgT=0;
let shareBtn={x:0,y:0,w:0,h:0};

best=parseInt(localStorage.getItem(LS_KEY))||0;

/* ══════════════ DIFFICULTY ══════════════ */
function gameSpeed(){ return 2.6+0.4*Math.sqrt(score); }
function spawnInterval(){ return Math.max(50,115-score*0.35); }
function perfectW(){ return Math.max(PERFECT_MIN,PERFECT_BASE-score*0.035); }

/* ══════════════ PARTICLES ══════════════ */
function emitP(x,y,col,n,spd,szLo,szHi){
  for(let i=0;i<n;i++){
    const a=rand(0,TAU),s=rand(spd*0.3,spd);
    particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,
      life:1,decay:rand(0.012,0.035),sz:rand(szLo,szHi),col});
  }
  if(particles.length>500) particles.splice(0,particles.length-500);
}
function tickParticles(){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx; p.y+=p.vy; p.vy+=0.05; p.life-=p.decay;
    if(p.life<=0) particles.splice(i,1);
  }
}
function drawParticles(){
  for(const p of particles){
    ctx.globalAlpha=clamp(p.life,0,1);
    ctx.fillStyle=p.col;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.sz*p.life,0,TAU);
    ctx.fill();
  }
  ctx.globalAlpha=1;
}

/* ══════════════ SHAKE ══════════════ */
let sX=0,sY=0;
function shake(intensity,dur){ shakeAmt=intensity; shakeDur=dur; }
function tickShake(){
  if(shakeDur>0){
    shakeDur--;
    sX=(Math.random()-0.5)*shakeAmt*(shakeDur/10);
    sY=(Math.random()-0.5)*shakeAmt*(shakeDur/10);
  } else { sX=sY=0; }
}

/* ══════════════ COLORBLIND PATTERNS ══════════════ */
function drawCBPattern(cx,cy,sz,ci,a){
  ctx.globalAlpha=a||0.7;
  ctx.strokeStyle='#fff'; ctx.fillStyle='#fff'; ctx.lineWidth=1.5;
  if(ci===0){
    // Red = triangle
    ctx.beginPath();
    ctx.moveTo(cx,cy-sz*0.38);
    ctx.lineTo(cx-sz*0.33,cy+sz*0.28);
    ctx.lineTo(cx+sz*0.33,cy+sz*0.28);
    ctx.closePath(); ctx.stroke();
  } else if(ci===1){
    // Green = circle
    ctx.beginPath();
    ctx.arc(cx,cy,sz*0.28,0,TAU);
    ctx.stroke();
  } else {
    // Blue = diagonal stripes
    ctx.save();
    ctx.beginPath();
    ctx.rect(cx-sz*0.32,cy-sz*0.32,sz*0.64,sz*0.64);
    ctx.clip();
    for(let i=-4;i<5;i++){
      ctx.beginPath();
      ctx.moveTo(cx+i*sz*0.18-sz*0.5,cy-sz*0.5);
      ctx.lineTo(cx+i*sz*0.18+sz*0.5,cy+sz*0.5);
      ctx.stroke();
    }
    ctx.restore();
  }
  ctx.globalAlpha=1;
}

/* ══════════════ GATE TYPES ══════════════ */
const GT_TWIN=0,GT_SPLIT=1,GT_WILD=2,GT_SWAP=3;

function makeGate(type){
  const pw=perfectW();
  if(type===GT_TWIN){
    const matchL=randInt(0,1);
    const other=(colorIdx+randInt(1,2))%3;
    return {type,x:W+30,w:GATE_THICK,pw,
      lanes:[{ci:matchL===0?colorIdx:other},{ci:matchL===1?colorIdx:other}],
      scored:false};
  }
  if(type===GT_WILD){
    return {type,x:W+30,w:GATE_THICK,pw,
      lanes:[{ci:-1},{ci:-1}],scored:false};
  }
  if(type===GT_SWAP){
    const c=randInt(0,2);
    return {type,x:W+30,w:GATE_THICK,pw,
      lanes:[{ci:c},{ci:(c+1)%3}],scored:false,swapped:false};
  }
  return null;
}

function spawnGate(){
  const r=Math.random();
  let type;
  if(score<5) type=GT_TWIN;
  else if(r<0.52) type=GT_TWIN;
  else if(r<0.70) type=GT_SPLIT;
  else if(r<0.85) type=GT_WILD;
  else type=GT_SWAP;

  if(type===GT_SPLIT){
    for(let i=0;i<3;i++){
      const g=makeGate(GT_TWIN);
      g.x=W+30+i*48;
      gates.push(g);
    }
  } else {
    const g=makeGate(type);
    if(g) gates.push(g);
  }
}

/* ══════════════ GATE DRAWING ══════════════ */
function drawGate(g){
  for(let l=0;l<2;l++){
    const yt=l===0?laneY0:laneY1;
    const gc=g.lanes[l].ci;
    const wild=gc===-1;

    // Background fill
    if(wild){
      ctx.fillStyle=`hsl(${(hue*2+g.x)%360},65%,50%)`;
    } else {
      ctx.fillStyle=COLORS[gc].fill;
    }
    ctx.globalAlpha=0.35;
    ctx.fillRect(g.x-g.w/2,yt,g.w,laneH);
    ctx.globalAlpha=1;

    // Top/bottom bars
    const barCol=wild?`hsl(${(hue*2+g.x+60)%360},75%,60%)`:COLORS[gc].fill;
    ctx.fillStyle=barCol;
    ctx.fillRect(g.x-g.w/2,yt,g.w,3);
    ctx.fillRect(g.x-g.w/2,yt+laneH-3,g.w,3);

    // Side glow
    ctx.fillStyle=barCol;
    ctx.globalAlpha=0.15;
    ctx.fillRect(g.x-g.w/2-4,yt,4,laneH);
    ctx.fillRect(g.x+g.w/2,yt,4,laneH);
    ctx.globalAlpha=1;

    // Perfect stripe (center)
    const cy=yt+laneH/2;
    ctx.fillStyle='rgba(255,255,220,0.85)';
    ctx.fillRect(g.x-g.w/2,cy-g.pw/2,g.w,g.pw);

    // Colorblind pattern
    if(!wild) drawCBPattern(g.x,yt+laneH/2,laneH*0.35,gc,0.3);

    // Type label
    ctx.textAlign='center'; ctx.textBaseline='middle';
    if(wild){
      ctx.fillStyle='#fff'; ctx.font='bold 14px sans-serif';
      ctx.fillText('*',g.x,yt+laneH/2+1);
    } else if(g.type===GT_SWAP){
      ctx.fillStyle='#fff'; ctx.font='12px sans-serif';
      ctx.fillText('\u21BB',g.x,yt+laneH/2+1);
    }
  }
}

/* ══════════════ COLLISION / SCORING ══════════════ */
function checkGates(){
  const px=playerBaseX;
  const py=playerVisY;
  const pr=PLAYER_R;

  for(let i=gates.length-1;i>=0;i--){
    const g=gates[i];
    if(g.x+g.w<-10){ gates.splice(i,1); continue; }
    if(g.scored) continue;
    if(Math.abs(px-g.x)<g.w/2+pr){
      g.scored=true;
      const gc=g.lanes[lane].ci;
      const wild=gc===-1;
      const match=wild||gc===colorIdx;
      const laneCenter=(lane===0?laneY0:laneY1)+laneH/2;
      const dist=Math.abs(py-laneCenter);
      const isPerfect=dist<g.pw/2+3;

      if(match){
        let pts=1;
        if(isPerfect){
          perfectStreak++; totalPerfects++;
          if(perfectStreak>maxCombo) maxCombo=perfectStreak;
          multiplier=1+Math.floor(perfectStreak/2)*0.5;
          pts=Math.ceil((wild?3:2)*multiplier);
          hitStop=2;
          emitP(px,py,'#ffffaa',16,4.5,2,6);
          emitP(px,py,COLORS[colorIdx].light,10,3.5,2,5);
          shake(5,6);
          if(perfectStreak>0&&perfectStreak%SHIELD_COST===0){
            shield=Math.min(shield+1,3);
            emitP(px,py,'rgba(255,255,100,1)',12,3.5,3,6);
          }
        } else {
          perfectStreak=0; multiplier=1;
          pts=wild?2:1;
          emitP(px,py,COLORS[colorIdx].fill,6,2.5,2,4);
        }
        score+=pts;
        if(g.type===GT_SWAP&&!g.swapped){
          g.swapped=true;
          colorIdx=(colorIdx+1)%3;
          emitP(px,py,COLORS[colorIdx].fill,8,3,2,5);
        }
      } else {
        // Wrong color
        if(invuln>0){
          emitP(px,py,'#888',5,2,2,4);
        } else if(shield>0){
          shield--;
          invuln=30;
          perfectStreak=0; multiplier=1;
          shake(14,18);
          emitP(px,py,'rgba(255,255,100,1)',28,5.5,3,7);
          emitP(px,py,'#fff',16,4.5,2,5);
          summaryShields++;
        } else {
          // Graze check
          const grazeDist=Math.abs(px-g.x);
          if(grazeDist>g.w/2+pr-GRAZE_PX){
            perfectStreak=0; multiplier=1;
            shake(10,12);
            emitP(px,py,'#ff8800',12,3.5,2,5);
            score=Math.max(0,score-1);
          } else {
            doGameOver();
            return;
          }
        }
      }
    }
  }
}

/* ══════════════ STATE TRANSITIONS ══════════════ */
function resetGame(){
  score=0; colorIdx=0; lane=0;
  playerVisY=laneY0+laneH/2;
  playerTgtY=laneY0+laneH/2;
  gates=[]; particles=[];
  perfectStreak=0; totalPerfects=0; maxCombo=0;
  shield=0; multiplier=1;
  shakeAmt=0; shakeDur=0; sX=sY=0;
  hitStop=0; invuln=0;
  hue=0; frameCount=0; spawnCD=0;
  summaryPerfects=0; summaryMaxCombo=0; summaryShields=0;
  shareMsg=''; shareMsgT=0;
  state='playing';
}

function doGameOver(){
  state='gameover';
  summaryPerfects=totalPerfects;
  summaryMaxCombo=maxCombo;
  if(score>best){ best=score; localStorage.setItem(LS_KEY,String(best)); }
  shake(22,28);
  const py=playerVisY;
  emitP(playerBaseX,py,COLORS[colorIdx].fill,45,6.5,3,8);
  emitP(playerBaseX,py,'#fff',22,5.5,2,6);
}

function doInput(){
  if(state==='start'){ resetGame(); return; }
  if(state==='playing'){
    colorIdx=(colorIdx+1)%3;
    lane=lane===0?1:0;
    playerTgtY=(lane===0?laneY0:laneY1)+laneH/2;
  }
  if(state==='gameover'){ resetGame(); }
}

/* ══════════════ INPUT ══════════════ */
canvas.addEventListener('pointerdown',e=>{
  e.preventDefault();
  if(state==='gameover'){
    const rect=canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left;
    const my=e.clientY-rect.top;
    if(mx>=shareBtn.x&&mx<=shareBtn.x+shareBtn.w&&my>=shareBtn.y&&my<=shareBtn.y+shareBtn.h){
      doShare(); return;
    }
  }
  doInput();
});
document.addEventListener('keydown',e=>{
  if(e.code==='Space'||e.code==='Enter'){
    e.preventDefault(); doInput();
  }
});

/* ══════════════ SHARE ══════════════ */
function doShare(){
  const txt=`I scored ${score} in Color Dash: Paintline! ${summaryPerfects} perfects, ${summaryMaxCombo} max combo. Can you beat me?\nhttps://balinti.github.io/color-dash/`;
  if(navigator.share){
    navigator.share({title:'Color Dash',text:txt}).catch(()=>{});
  } else if(navigator.clipboard){
    navigator.clipboard.writeText(txt).then(()=>{
      shareMsg='Copied!'; shareMsgT=100;
    }).catch(()=>{});
  }
}

/* ══════════════ INFO PANEL ══════════════ */
document.getElementById('info-toggle').addEventListener('click',()=>{
  document.getElementById('info-panel').classList.toggle('open');
});

/* ══════════════ PLAYER DRAWING ══════════════ */
function drawPlayer(){
  const px=playerBaseX, py=playerVisY;

  // Glow
  const gr=ctx.createRadialGradient(px,py,PLAYER_R*0.3,px,py,PLAYER_R*2.2);
  gr.addColorStop(0,COLORS[colorIdx].fill.replace(')',',0.35)').replace('hsl','hsla'));
  gr.addColorStop(1,'transparent');
  ctx.fillStyle=gr;
  ctx.beginPath(); ctx.arc(px,py,PLAYER_R*2.2,0,TAU); ctx.fill();

  // Shield ring
  if(shield>0){
    ctx.strokeStyle='rgba(255,255,100,0.75)';
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(px,py,PLAYER_R+5,0,TAU); ctx.stroke();
    for(let i=0;i<shield;i++){
      const a=-PI/2+i*(TAU/Math.max(shield,1));
      ctx.fillStyle='rgba(255,255,100,0.9)';
      ctx.beginPath();
      ctx.arc(px+Math.cos(a)*(PLAYER_R+5),py+Math.sin(a)*(PLAYER_R+5),3,0,TAU);
      ctx.fill();
    }
  }

  // Invuln flash
  if(invuln>0&&frameCount%4<2){
    ctx.fillStyle='rgba(255,255,255,0.3)';
    ctx.beginPath(); ctx.arc(px,py,PLAYER_R+8,0,TAU); ctx.fill();
  }

  // Body
  ctx.fillStyle=COLORS[colorIdx].fill;
  ctx.beginPath(); ctx.arc(px,py,PLAYER_R,0,TAU); ctx.fill();

  // Highlight
  ctx.fillStyle=COLORS[colorIdx].light;
  ctx.globalAlpha=0.4;
  ctx.beginPath(); ctx.arc(px-3,py-4,PLAYER_R*0.5,0,TAU); ctx.fill();
  ctx.globalAlpha=1;

  // CB pattern
  drawCBPattern(px,py,PLAYER_R*1.8,colorIdx,0.8);

  // Trail
  if(state==='playing'&&frameCount%3===0){
    emitP(px-PLAYER_R*0.4,py,COLORS[colorIdx].dark,1,1,2,3.5);
  }
}

/* ══════════════ DRAWING ══════════════ */
function drawBg(){
  const g=ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#0f0f23');
  g.addColorStop(0.5,`hsl(${(hue*0.15)%360+240},20%,14%)`);
  g.addColorStop(1,'#0f0f23');
  ctx.fillStyle=g;
  ctx.fillRect(0,0,W,H);

  // Lane bgs
  for(let l=0;l<2;l++){
    const yt=l===0?laneY0:laneY1;
    ctx.fillStyle='rgba(255,255,255,0.025)';
    ctx.fillRect(0,yt,W,laneH);
    ctx.strokeStyle='rgba(255,255,255,0.06)';
    ctx.lineWidth=1; ctx.setLineDash([6,8]);
    ctx.beginPath();
    ctx.moveTo(0,yt+laneH/2); ctx.lineTo(W,yt+laneH/2);
    ctx.stroke(); ctx.setLineDash([]);
  }

  // Motion lines
  if(state==='playing'){
    const off=(frameCount*gameSpeed()*0.6)%50;
    ctx.strokeStyle='rgba(255,255,255,0.03)';
    ctx.lineWidth=1;
    for(let x=-off;x<W+50;x+=50){
      for(let l=0;l<2;l++){
        const yt=l===0?laneY0:laneY1;
        ctx.beginPath(); ctx.moveTo(x,yt); ctx.lineTo(x,yt+laneH); ctx.stroke();
      }
    }
  }
}

function drawHUD(){
  ctx.textAlign='center'; ctx.textBaseline='top';
  ctx.fillStyle='#fff'; ctx.font='bold 26px sans-serif';
  ctx.fillText(String(score),W/2,10);

  ctx.font='11px sans-serif'; ctx.fillStyle='rgba(255,255,255,0.45)';
  ctx.fillText('BEST: '+best,W/2,40);

  if(multiplier>1){
    ctx.font='bold 14px sans-serif'; ctx.fillStyle='#ffffaa';
    ctx.fillText('x'+multiplier.toFixed(1),W/2+55,14);
  }

  // Shield pips top-left
  if(shield>0){
    for(let i=0;i<shield;i++){
      ctx.fillStyle='rgba(255,255,100,0.8)';
      ctx.beginPath(); ctx.arc(16+i*16,20,5,0,TAU); ctx.fill();
      ctx.strokeStyle='rgba(255,255,100,0.4)';
      ctx.lineWidth=1;
      ctx.beginPath(); ctx.arc(16+i*16,20,7,0,TAU); ctx.stroke();
    }
  }

  // Streak indicator
  if(perfectStreak>=2){
    ctx.font='bold 15px sans-serif';
    ctx.fillStyle=`hsl(${(hue*3)%360},80%,70%)`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(perfectStreak+' PERFECT!',W/2,laneY0-16);
  }

  // Current color indicator top-right
  ctx.fillStyle=COLORS[colorIdx].fill;
  ctx.beginPath(); ctx.arc(W-20,20,8,0,TAU); ctx.fill();
  drawCBPattern(W-20,20,14,colorIdx,0.9);
}

function drawStartScreen(){
  drawBg();

  ctx.textAlign='center'; ctx.textBaseline='middle';

  // Title
  ctx.fillStyle='#fff'; ctx.font='bold 34px sans-serif';
  ctx.fillText('COLOR DASH',W/2,H*0.25);

  // Subtitle
  ctx.fillStyle=`hsl(${hue%360},70%,65%)`; ctx.font='16px sans-serif';
  ctx.fillText('P A I N T L I N E',W/2,H*0.25+32);

  // Orbiting color orbs
  for(let i=0;i<3;i++){
    const a=hue*0.025+i*(TAU/3);
    const ox=W/2+Math.cos(a)*38;
    const oy=H*0.42+Math.sin(a)*18;
    ctx.fillStyle=COLORS[i].fill;
    ctx.beginPath(); ctx.arc(ox,oy,13,0,TAU); ctx.fill();
    drawCBPattern(ox,oy,22,i,0.75);
  }

  // Instructions
  ctx.fillStyle='rgba(255,255,255,0.6)'; ctx.font='13px sans-serif';
  ctx.fillText('Tap / Space / Enter = Switch Color + Lane',W/2,H*0.55);
  ctx.fillText('Match the gate color. Hit center for Perfect!',W/2,H*0.60);

  // Best
  if(best>0){
    ctx.fillStyle='rgba(255,255,255,0.4)'; ctx.font='13px sans-serif';
    ctx.fillText('Best: '+best,W/2,H*0.68);
  }

  // Tap to start
  const pulse=0.55+0.45*Math.sin(performance.now()*0.004);
  ctx.fillStyle=`rgba(255,255,255,${pulse})`; ctx.font='bold 18px sans-serif';
  ctx.fillText('Tap to Start',W/2,H*0.78);
}

function drawGameOverScreen(){
  ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
  ctx.textAlign='center'; ctx.textBaseline='middle';

  ctx.fillStyle='#ff4455'; ctx.font='bold 30px sans-serif';
  ctx.fillText('GAME OVER',W/2,H*0.22);

  ctx.fillStyle='#fff'; ctx.font='bold 42px sans-serif';
  ctx.fillText(String(score),W/2,H*0.32);

  ctx.font='12px sans-serif'; ctx.fillStyle='rgba(255,255,255,0.45)';
  ctx.fillText('BEST: '+best,W/2,H*0.38);

  // Stats
  ctx.font='12px sans-serif'; ctx.fillStyle='rgba(255,255,255,0.6)';
  ctx.fillText('Perfects: '+summaryPerfects+'  |  Max Combo: '+summaryMaxCombo+'  |  Shields Used: '+summaryShields,W/2,H*0.45);

  // Share button
  const bw=170,bh=38;
  const bx=W/2-bw/2,by=H*0.52;
  shareBtn={x:bx,y:by,w:bw,h:bh};
  ctx.fillStyle='rgba(255,255,255,0.12)';
  ctx.beginPath();
  if(ctx.roundRect) ctx.roundRect(bx,by,bw,bh,8);
  else { ctx.moveTo(bx+8,by); ctx.lineTo(bx+bw-8,by); ctx.quadraticCurveTo(bx+bw,by,bx+bw,by+8); ctx.lineTo(bx+bw,by+bh-8); ctx.quadraticCurveTo(bx+bw,by+bh,bx+bw-8,by+bh); ctx.lineTo(bx+8,by+bh); ctx.quadraticCurveTo(bx,by+bh,bx,by+bh-8); ctx.lineTo(bx,by+8); ctx.quadraticCurveTo(bx,by,bx+8,by); }
  ctx.fill();
  ctx.fillStyle='#fff'; ctx.font='13px sans-serif';
  ctx.fillText('Challenge a Friend',W/2,by+bh/2+1);

  if(shareMsgT>0){
    ctx.fillStyle='#ffffaa'; ctx.font='12px sans-serif';
    ctx.fillText(shareMsg,W/2,by+bh+16);
  }

  // Tap to retry
  const pulse=0.5+0.5*Math.sin(performance.now()*0.004);
  ctx.fillStyle=`rgba(255,255,255,${pulse})`; ctx.font='bold 16px sans-serif';
  ctx.fillText('Tap to Retry',W/2,H*0.72);
}

/* ══════════════ MAIN LOOP ══════════════ */
let lastT=0;
function loop(ts){
  requestAnimationFrame(loop);
  const rawDt=ts-lastT; lastT=ts;
  const dt=Math.min(rawDt,33)/16.67;

  hue+=0.5; frameCount++;

  if(hitStop>0){ hitStop--; return; }
  if(shareMsgT>0) shareMsgT--;

  ctx.save();
  ctx.translate(sX,sY);

  if(state==='start'){
    drawStartScreen();
    tickParticles(); drawParticles();
  } else if(state==='playing'){
    if(invuln>0) invuln--;

    // Spawn
    spawnCD+=dt;
    const si=spawnInterval()/gameSpeed();
    if(spawnCD>=si){ spawnCD-=si; spawnGate(); }

    // Move gates
    const spd=gameSpeed();
    for(const g of gates) g.x-=spd*dt;

    // Player lane lerp
    playerVisY=lerp(playerVisY,playerTgtY,0.22);

    checkGates();
    tickParticles();
    tickShake();

    drawBg();
    for(const g of gates) drawGate(g);
    drawPlayer();
    drawParticles();
    drawHUD();
  } else if(state==='gameover'){
    tickParticles(); tickShake();
    drawBg();
    for(const g of gates) drawGate(g);
    drawParticles();
    drawGameOverScreen();
  }

  ctx.restore();
}

requestAnimationFrame(loop);
})();
</script>
</body>
</html>
