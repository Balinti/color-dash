<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="theme-color" content="#0a0a1a">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:'Segoe UI',system-ui,sans-serif;touch-action:none;user-select:none;-webkit-user-select:none}
#wrap{display:flex;align-items:center;justify-content:center;width:100%;height:100%;height:100dvh}
#gameContainer{position:relative;width:100%;max-width:420px;height:100%;max-height:750px;background:#0a0a1a}
canvas{display:block;width:100%;height:100%}
@media(min-width:421px)and (min-height:751px){#gameContainer{border-radius:18px;box-shadow:0 0 60px rgba(0,200,255,.15),0 0 120px rgba(255,0,180,.1)}}
</style>
</head>
<body>
<div id="wrap">
<div id="gameContainer">
<canvas id="gc"></canvas>
</div>
</div>
<script>
'use strict';
(()=>{

const canvas = document.getElementById('gc');
const ctx = canvas.getContext('2d');
const container = document.getElementById('gameContainer');

/* ── High-DPI ── */
const MAX_DPR = 3;
let dpr, W, H;

function resize() {
  const rect = container.getBoundingClientRect();
  W = rect.width;
  H = rect.height;
  dpr = Math.min(window.devicePixelRatio || 1, MAX_DPR);
  canvas.width  = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
}
resize();
window.addEventListener('resize', resize);

/* ── Palette ── */
const CYAN    = '#00e5ff';
const MAGENTA = '#ff00aa';
const CYAN_DARK  = '#006680';
const MAGENTA_DARK = '#800055';

/* ── WebAudio synth ── */
let audioCtx = null;
let muted = false;
function getAudio() {
  if (!audioCtx) try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {}
  return audioCtx;
}
function tone(freq, dur, type, vol) {
  if (muted) return;
  const a = getAudio(); if (!a) return;
  const o = a.createOscillator();
  const g = a.createGain();
  o.type = type || 'sine';
  o.frequency.value = freq;
  g.gain.value = vol || 0.07;
  g.gain.exponentialRampToValueAtTime(0.001, a.currentTime + dur);
  o.connect(g); g.connect(a.destination);
  o.start(); o.stop(a.currentTime + dur);
}
function sfxFlip()    { tone(600,.07,'sine',.10); tone(920,.05,'sine',.06); }
function sfxCorrect() { tone(800,.09,'sine',.11); setTimeout(()=>tone(1200,.09,'sine',.07),45); }
function sfxWrong()   { tone(200,.20,'sawtooth',.09); tone(150,.25,'sawtooth',.05); }
function sfxClutch()  { tone(1000,.07,'sine',.10); setTimeout(()=>tone(1400,.07,'sine',.09),35); setTimeout(()=>tone(1800,.09,'sine',.07),70); }
function sfxGameOver(){ tone(300,.30,'sawtooth',.10); setTimeout(()=>tone(200,.35,'sawtooth',.08),90); setTimeout(()=>tone(100,.45,'sawtooth',.06),220); }

/* ── State ── */
const LS_KEY = 'color_dash_best';
let state = 'start'; // start | playing | gameover
let score, bestScore, combo, shields;
let runnerLane, runnerColor; // 0=left/cyan, 1=right/magenta
let gates, particles, floatTexts;
let gameTime, lastFlipTime, lastGateSpawn;
let flipAnim, flipDir;
let shakeX, shakeY, shakeDecay;
let bgHue, bgTargetHue, comboGlow;
let gameOverTimer, startPulse = 0;
let prevSpawnLane, prevSpawnColor;

bestScore = parseInt(localStorage.getItem(LS_KEY)) || 0;

/* ── Constants ── */
const MAX_SHIELDS = 3;
const MAX_COMBO   = 4;
const RUNNER_R    = 16;
const GATE_W_FRAC = 0.22;
const GATE_H      = 50;
const RUNNER_Y_FRAC = 0.78;

function laneX(lane) { return W * 0.5 + (lane === 0 ? -W * 0.14 : W * 0.14); }
function runnerYPos()  { return H * RUNNER_Y_FRAC; }

/* ── Difficulty curves ── */
function getSpeed()          { return 170 + score * 3 + combo * 7; }
function getSpawnInterval()  { return Math.max(0.72, 1.9 - score * 0.017); }
function getMinFlipInterval(){ return Math.max(0.35, 0.85 - score * 0.008); }

/* ── Particles ── */
function emitBurst(x, y, color, count, speed, life) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const s = speed * (0.4 + Math.random() * 0.6);
    particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s,
      life: life*(0.5+Math.random()*0.5), maxLife: life,
      color, size: 2 + Math.random() * 3 });
  }
}
function emitSparks(x, y, count) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const s = 70 + Math.random() * 120;
    particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s,
      life: 0.25+Math.random()*0.2, maxLife: 0.45,
      color: '#fff', size: 1.5 + Math.random() * 1.5 });
  }
}
function addFloat(x, y, text, color) {
  floatTexts.push({ x, y, text, color, life: 1.2, maxLife: 1.2 });
}
function addShake(amt) { shakeDecay = Math.max(shakeDecay, amt); }

/* ── Gate spawn ── */
function spawnGate() {
  const sinceFlip = gameTime - lastFlipTime;
  const minFlip   = getMinFlipInterval();
  let lane, color;

  if (sinceFlip < minFlip) {
    // Runner cannot flip in time — give them a freebie on current lane+color
    lane  = runnerLane;
    color = runnerColor;
  } else {
    lane  = Math.random() < 0.5 ? 0 : 1;
    color = Math.random() < 0.5 ? 0 : 1;
    // Reduce streaks of identical gates
    if (prevSpawnLane === lane && prevSpawnColor === color && Math.random() < 0.45) {
      Math.random() < 0.5 ? (lane = 1 - lane) : (color = 1 - color);
    }
  }
  prevSpawnLane  = lane;
  prevSpawnColor = color;

  gates.push({ lane, color, y: -GATE_H, scored: false, opacity: 0, filled: false });
  lastGateSpawn = gameTime;
}

/* ── Game lifecycle ── */
function startGame() {
  state = 'playing';
  score = 0; combo = 0; shields = MAX_SHIELDS;
  runnerLane = 0; runnerColor = 0;
  gates = []; particles = []; floatTexts = [];
  gameTime = 0; lastFlipTime = -999; lastGateSpawn = -999;
  flipAnim = 0; flipDir = 0;
  shakeX = 0; shakeY = 0; shakeDecay = 0;
  gameOverTimer = 0;
  bgHue = 200; bgTargetHue = 200; comboGlow = 0;
  prevSpawnLane = -1; prevSpawnColor = -1;
}

function triggerGameOver() {
  state = 'gameover';
  gameOverTimer = 0;
  if (score > bestScore) { bestScore = score; localStorage.setItem(LS_KEY, bestScore); }
  addShake(14);
  sfxGameOver();
  emitBurst(laneX(runnerLane), runnerYPos(), '#888', 25, 150, 0.8);
  emitSparks(laneX(runnerLane), runnerYPos(), 15);
}

/* ── Input ── */
function doFlip() {
  if (state === 'start')    { startGame(); return; }
  if (state === 'gameover') { if (gameOverTimer > 0.6) startGame(); return; }

  runnerLane  = 1 - runnerLane;
  runnerColor = 1 - runnerColor;
  lastFlipTime = gameTime;
  flipAnim = 1;
  flipDir  = runnerLane === 1 ? 1 : -1;
  sfxFlip();
  emitBurst(laneX(runnerLane), runnerYPos(), runnerColor === 0 ? CYAN : MAGENTA, 6, 55, 0.28);
  addShake(1.5);
}

canvas.addEventListener('pointerdown', e => { e.preventDefault(); getAudio(); doFlip(); });
document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); doFlip(); }
  if (e.code === 'KeyM') muted = !muted;
});

/* ── UPDATE ── */
function update(dt) {
  startPulse += dt;

  // Shake decay
  if (shakeDecay > 0) {
    shakeX = (Math.random() - 0.5) * shakeDecay * 2;
    shakeY = (Math.random() - 0.5) * shakeDecay * 2;
    shakeDecay = Math.max(0, shakeDecay - dt * 38);
  } else { shakeX = 0; shakeY = 0; }

  // Flip anim
  if (flipAnim > 0) flipAnim = Math.max(0, flipAnim - dt * 5.5);

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt; p.y += p.vy * dt;
    p.vy += 180 * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Float texts
  for (let i = floatTexts.length - 1; i >= 0; i--) {
    const ft = floatTexts[i];
    ft.y -= 38 * dt;
    ft.life -= dt;
    if (ft.life <= 0) floatTexts.splice(i, 1);
  }

  if (state === 'gameover') {
    gameOverTimer += dt;
    bgHue += (0 - bgHue) * dt * 2;
    comboGlow = Math.max(0, comboGlow - dt * 3);
    return;
  }
  if (state !== 'playing') return;

  gameTime += dt;

  // BG colour shift
  bgTargetHue = runnerColor === 0 ? 200 : 320;
  bgHue += (bgTargetHue - bgHue) * dt * 3;
  comboGlow += (Math.min(combo, MAX_COMBO) / MAX_COMBO - comboGlow) * dt * 4;

  // Spawn
  if (gameTime - lastGateSpawn > getSpawnInterval()) spawnGate();

  // Move gates & collisions
  const speed = getSpeed();
  const rx = laneX(runnerLane);
  const ry = runnerYPos();

  for (let i = gates.length - 1; i >= 0; i--) {
    const g = gates[i];
    g.y += speed * dt;

    // Telegraph opacity
    if (!g.filled) {
      g.opacity = Math.min(1, g.opacity + dt * 2.5);
      if (g.opacity >= 1) g.filled = true;
    }

    // Collision: only when gate is in runner's lane
    if (!g.scored && g.lane === runnerLane) {
      const gTop = g.y;
      const gBot = g.y + GATE_H;
      if (gBot > ry - RUNNER_R && gTop < ry + RUNNER_R) {
        g.scored = true;
        if (g.color === runnerColor) {
          // ── CORRECT ──
          combo = Math.min(combo + 1, MAX_COMBO);
          const pts = combo;
          score += pts;

          // Near-miss (CLUTCH) check
          const nearDist = Math.min(Math.abs(ry - gTop), Math.abs(ry - gBot));
          if (nearDist < RUNNER_R * 1.6) {
            score += 2;
            addFloat(rx, ry - 32, 'CLUTCH +2', '#ffee00');
            sfxClutch();
            emitSparks(rx, ry, 14);
            emitBurst(rx, ry, '#ffee00', 10, 100, 0.4);
            addShake(3.5);
          } else {
            addFloat(rx, ry - 32, combo > 1 ? `+${pts} x${combo}` : `+${pts}`, runnerColor === 0 ? CYAN : MAGENTA);
            addShake(2);
          }
          sfxCorrect();
          emitBurst(rx, ry, runnerColor === 0 ? CYAN : MAGENTA, 12, 100, 0.4);
          emitSparks(rx, ry, 8);

        } else {
          // ── WRONG ──
          combo = 0;
          shields--;
          sfxWrong();
          emitBurst(rx, ry, '#555', 10, 80, 0.5);
          addFloat(rx, ry - 32, shields > 0 ? 'WRONG' : 'DESTROYED', shields > 0 ? '#ff4444' : '#ff0000');
          addShake(7);
          if (shields <= 0) { triggerGameOver(); return; }
        }
      }
    }

    // Remove offscreen
    if (g.y > H + GATE_H) gates.splice(i, 1);
  }
}

/* ── DRAW ── */
function draw() {
  ctx.save();
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.translate(shakeX, shakeY);

  // BG
  const bgL = 7 + comboGlow * 5;
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, `hsl(${bgHue},40%,${bgL}%)`);
  grad.addColorStop(1, `hsl(${bgHue + 20},30%,${Math.max(3, bgL - 3)}%)`);
  ctx.fillStyle = grad;
  ctx.fillRect(-20, -20, W + 40, H + 40);

  // Combo vignette
  if (comboGlow > 0.1) {
    const cg = ctx.createRadialGradient(W/2, H*0.5, W*0.1, W/2, H*0.5, W*0.7);
    const cc = runnerColor === 0 ? '0,229,255' : '255,0,170';
    cg.addColorStop(0, `rgba(${cc},${(comboGlow * 0.08).toFixed(3)})`);
    cg.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = cg;
    ctx.fillRect(0, 0, W, H);
  }

  // Road lines
  drawRoadLines();

  // Gates
  for (const g of gates) drawGate(g);

  // Runner
  drawRunner();

  // Particles
  for (const p of particles) {
    const a = p.life / p.maxLife;
    ctx.globalAlpha = a;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * a, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Float texts
  for (const ft of floatTexts) {
    const a = ft.life / ft.maxLife;
    ctx.globalAlpha = a;
    ctx.fillStyle = ft.color;
    ctx.font = `bold ${13 + a * 5}px 'Segoe UI',system-ui,sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(ft.text, ft.x, ft.y);
  }
  ctx.globalAlpha = 1;

  // UI overlay
  drawUI();

  ctx.restore();
}

/* ── Road ── */
let roadOffset = 0;
function drawRoadLines() {
  if (state === 'playing') roadOffset = (roadOffset + getSpeed() * 0.016) % 24;

  // Center divider
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1;
  ctx.setLineDash([6, 12]);
  ctx.lineDashOffset = -roadOffset;
  ctx.beginPath();
  ctx.moveTo(W / 2, 0); ctx.lineTo(W / 2, H);
  ctx.stroke();
  ctx.setLineDash([]);

  // Lane guides
  for (let lane = 0; lane < 2; lane++) {
    const lx = laneX(lane);
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = W * GATE_W_FRAC + 4;
    ctx.beginPath();
    ctx.moveTo(lx, 0); ctx.lineTo(lx, H);
    ctx.stroke();
  }
  ctx.lineWidth = 1;
}

/* ── Gate ── */
function drawGate(g) {
  const gx = laneX(g.lane);
  const gw = W * GATE_W_FRAC;
  const x  = gx - gw / 2;
  const y  = g.y;
  const color = g.color === 0 ? CYAN : MAGENTA;
  const darkColor = g.color === 0 ? CYAN_DARK : MAGENTA_DARK;

  ctx.save();
  ctx.globalAlpha = g.opacity;

  // Telegraph outline
  if (!g.filled) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(x + 2, y + 2, gw - 4, GATE_H - 4);
    ctx.setLineDash([]);
    ctx.restore();
    return;
  }

  // Filled body
  const gGrad = ctx.createLinearGradient(x, y, x, y + GATE_H);
  gGrad.addColorStop(0, color + '30');
  gGrad.addColorStop(1, color + '10');
  ctx.fillStyle = gGrad;
  ctx.fillRect(x, y, gw, GATE_H);

  // Border
  ctx.strokeStyle = color;
  ctx.lineWidth = 2.5;
  ctx.strokeRect(x, y, gw, GATE_H);

  // Accessibility patterns
  if (g.color === 0) {
    // Stripes
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, gw, GATE_H);
    ctx.clip();
    ctx.strokeStyle = color + '44';
    ctx.lineWidth = 1.5;
    for (let sx = x - GATE_H; sx < x + gw + GATE_H; sx += 9) {
      ctx.beginPath();
      ctx.moveTo(sx, y); ctx.lineTo(sx + GATE_H, y + GATE_H);
      ctx.stroke();
    }
    ctx.restore();
    // Circle icon
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(gx, y + GATE_H / 2, 10, 0, Math.PI * 2);
    ctx.stroke();
  } else {
    // Dots
    ctx.fillStyle = color + '66';
    for (let dx = x + 6; dx < x + gw; dx += 9) {
      for (let dy = y + 6; dy < y + GATE_H; dy += 9) {
        ctx.beginPath();
        ctx.arc(dx, dy, 1.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    // Triangle icon
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(gx, y + GATE_H / 2 - 10);
    ctx.lineTo(gx + 9, y + GATE_H / 2 + 7);
    ctx.lineTo(gx - 9, y + GATE_H / 2 + 7);
    ctx.closePath();
    ctx.stroke();
  }

  // Glow
  ctx.shadowColor = color;
  ctx.shadowBlur = 12;
  ctx.strokeStyle = color + '22';
  ctx.lineWidth = 1;
  ctx.strokeRect(x - 1, y - 1, gw + 2, GATE_H + 2);
  ctx.shadowBlur = 0;

  ctx.restore();
}

/* ── Runner ── */
function drawRunner() {
  const rx = laneX(runnerLane);
  const ry = runnerYPos();
  const color = runnerColor === 0 ? CYAN : MAGENTA;

  ctx.save();

  // Squash / stretch
  let sx = 1, sy = 1;
  if (flipAnim > 0) {
    sx = 1 + 0.3 * Math.sin(flipAnim * Math.PI);
    sy = 1 - 0.2 * Math.sin(flipAnim * Math.PI);
  }

  ctx.translate(rx, ry);
  ctx.scale(sx, sy);

  // Trail ghost
  if (flipAnim > 0) {
    ctx.globalAlpha = flipAnim * 0.3;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(-flipDir * 18 * flipAnim, 0, RUNNER_R * 0.65, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Outer glow
  ctx.shadowColor = color;
  ctx.shadowBlur = 22;

  // Main body
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(0, 0, RUNNER_R, 0, Math.PI * 2);
  ctx.fill();

  // Inner dark
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.arc(0, 0, RUNNER_R * 0.55, 0, Math.PI * 2);
  ctx.fill();

  // Inner icon (matches gate patterns)
  ctx.strokeStyle = 'rgba(255,255,255,0.85)';
  ctx.lineWidth = 1.5;
  if (runnerColor === 0) {
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.stroke();
  } else {
    ctx.beginPath();
    ctx.moveTo(0, -6);
    ctx.lineTo(5.5, 4.5);
    ctx.lineTo(-5.5, 4.5);
    ctx.closePath();
    ctx.stroke();
  }

  ctx.restore();
}

/* ── UI ── */
function drawUI() {
  ctx.textBaseline = 'top';

  if (state === 'start') { drawStartScreen(); return; }

  // Score
  ctx.fillStyle = 'rgba(255,255,255,0.92)';
  ctx.font = "bold 30px 'Segoe UI',system-ui,sans-serif";
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(score, W / 2, 14);

  // Combo
  if (combo > 1) {
    ctx.fillStyle = runnerColor === 0 ? CYAN : MAGENTA;
    ctx.font = "bold 15px 'Segoe UI',system-ui,sans-serif";
    ctx.fillText(`x${combo} COMBO`, W / 2, 48);
  }

  // Shield pips
  const pipStartX = W / 2 - (MAX_SHIELDS - 1) * 18 / 2;
  for (let i = 0; i < MAX_SHIELDS; i++) {
    const px = pipStartX + i * 18;
    const py = 70;
    ctx.beginPath();
    ctx.moveTo(px, py - 6);
    ctx.lineTo(px + 5, py);
    ctx.lineTo(px, py + 6);
    ctx.lineTo(px - 5, py);
    ctx.closePath();
    if (i < shields) {
      ctx.fillStyle = '#00ff88';
      ctx.shadowColor = '#00ff88';
      ctx.shadowBlur = 6;
    } else {
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.shadowBlur = 0;
    }
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Mute
  ctx.fillStyle = 'rgba(255,255,255,0.25)';
  ctx.font = "11px 'Segoe UI',system-ui,sans-serif";
  ctx.textAlign = 'right';
  ctx.fillText(muted ? '[M] unmute' : '[M] mute', W - 10, 8);

  if (state === 'gameover') drawGameOver();
}

function drawStartScreen() {
  // Title
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.shadowColor = CYAN;
  ctx.shadowBlur = 25;
  ctx.fillStyle = CYAN;
  ctx.font = "bold 44px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText('COLOR', W / 2, H * 0.27);

  ctx.shadowColor = MAGENTA;
  ctx.fillStyle = MAGENTA;
  ctx.fillText('DASH', W / 2, H * 0.27 + 50);
  ctx.shadowBlur = 0;

  // Subtitle
  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.font = "14px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText('Flip Sprint', W / 2, H * 0.27 + 85);

  // Instructions
  ctx.fillStyle = 'rgba(255,255,255,0.55)';
  ctx.font = "13px 'Segoe UI',system-ui,sans-serif";
  const lines = [
    'Tap or Space to flip lanes & color',
    'Match gate color to score points',
    'Wrong color = lose a shield pip',
    'Build combos for x2 x3 x4 multiplier!'
  ];
  lines.forEach((t, i) => ctx.fillText(t, W / 2, H * 0.49 + i * 23));

  // Color legend
  const ly = H * 0.49 + lines.length * 23 + 28;

  ctx.fillStyle = CYAN;
  ctx.beginPath(); ctx.arc(W / 2 - 60, ly, 8, 0, Math.PI * 2); ctx.fill();
  // Stripe hint
  ctx.strokeStyle = '#006680';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(W/2-66,ly-4); ctx.lineTo(W/2-54,ly+4); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W/2-63,ly-6); ctx.lineTo(W/2-57,ly+6); ctx.stroke();
  ctx.fillStyle = 'rgba(255,255,255,0.65)';
  ctx.font = "12px 'Segoe UI',system-ui,sans-serif";
  ctx.textAlign = 'left';
  ctx.fillText('Cyan \u00B7 Circle \u00B7 Stripes', W / 2 - 46, ly);

  ctx.fillStyle = MAGENTA;
  ctx.beginPath(); ctx.arc(W / 2 - 60, ly + 26, 8, 0, Math.PI * 2); ctx.fill();
  // Dot hint
  ctx.fillStyle = '#800055';
  for (let d = -1; d <= 1; d++) { ctx.beginPath(); ctx.arc(W/2-60+d*5, ly+26, 1.5, 0, Math.PI*2); ctx.fill(); }
  ctx.fillStyle = 'rgba(255,255,255,0.65)';
  ctx.fillText('Magenta \u00B7 Triangle \u00B7 Dots', W / 2 - 46, ly + 26);

  ctx.textAlign = 'center';

  // Best score
  if (bestScore > 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.font = "13px 'Segoe UI',system-ui,sans-serif";
    ctx.fillText(`Best: ${bestScore}`, W / 2, H * 0.86 - 22);
  }

  // Pulse "Tap to Start"
  const pulse = 0.5 + 0.5 * Math.sin(startPulse * 3);
  ctx.fillStyle = `rgba(255,255,255,${(0.4 + pulse * 0.5).toFixed(2)})`;
  ctx.font = "bold 18px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText('Tap to Start', W / 2, H * 0.89);
}

function drawGameOver() {
  const alpha = Math.min(1, gameOverTimer * 2) * 0.72;
  ctx.fillStyle = `rgba(0,0,0,${alpha.toFixed(2)})`;
  ctx.fillRect(-20, -20, W + 40, H + 40);

  if (gameOverTimer < 0.25) return;

  const fade = Math.min(1, (gameOverTimer - 0.25) * 3);
  ctx.globalAlpha = fade;

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.shadowColor = '#ff3355';
  ctx.shadowBlur = 16;
  ctx.fillStyle = '#ff3355';
  ctx.font = "bold 38px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText('GAME OVER', W / 2, H * 0.32);
  ctx.shadowBlur = 0;

  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.font = "16px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText('SCORE', W / 2, H * 0.42 - 18);

  ctx.fillStyle = 'rgba(255,255,255,0.92)';
  ctx.font = "bold 54px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText(score, W / 2, H * 0.42 + 18);

  const isNewBest = score >= bestScore && score > 0;
  ctx.fillStyle = isNewBest ? '#ffee00' : 'rgba(255,255,255,0.55)';
  ctx.font = "bold 20px 'Segoe UI',system-ui,sans-serif";
  ctx.fillText(isNewBest ? `\u2605 NEW BEST! ${bestScore}` : `Best: ${bestScore}`, W / 2, H * 0.54);

  if (gameOverTimer > 0.7) {
    const p2 = 0.5 + 0.5 * Math.sin(startPulse * 3);
    ctx.fillStyle = `rgba(255,255,255,${(0.35 + p2 * 0.45).toFixed(2)})`;
    ctx.font = "bold 17px 'Segoe UI',system-ui,sans-serif";
    ctx.fillText('Tap to Retry', W / 2, H * 0.68);
  }

  ctx.globalAlpha = 1;
}

/* ── Main loop ── */
let lastTime = 0;
function loop(ts) {
  requestAnimationFrame(loop);
  if (!lastTime) { lastTime = ts; return; }
  let dt = (ts - lastTime) / 1000;
  lastTime = ts;
  if (dt > 0.1) dt = 0.1;
  if (dt <= 0) return;

  update(dt);
  draw();
}
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
