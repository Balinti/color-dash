<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#1a1a2e">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors.">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0f0f23;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;display:flex;flex-direction:column;align-items:center;justify-content:center;touch-action:none;user-select:none;-webkit-user-select:none;-webkit-tap-highlight-color:transparent}
#wrap{position:relative;touch-action:none;-webkit-touch-callout:none}
canvas{display:block;border-radius:10px}
#seo{max-width:420px;color:#666;font-size:11px;text-align:center;padding:6px 12px;line-height:1.4}
#seo h1{font-size:13px;color:#888;margin-bottom:3px}
#seo ul{list-style:none;padding:0}
#seo ul li::before{content:"- "}
</style>
</head>
<body>
<div id="wrap"><canvas id="c"></canvas></div>
<div id="seo">
<h1>Color Dash - Paint Split</h1>
<p>A hyper-casual endless runner. Match your paint color to the gates ahead!</p>
<ul>
<li>Tap or press Space to flip between Light and Dark</li>
<li>Match your color to pass through gates safely</li>
<li>Build combos for higher score multipliers</li>
<li>Collect Charge gates to refill your flip buffer</li>
</ul>
</div>
<script>
'use strict';
(function(){

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const wrap = document.getElementById('wrap');

/* ── Constants ── */
const LS_KEY = 'paintSplit_highScore_v1';
const MAX_W = 420, MAX_H = 750;
const DPR = Math.min(window.devicePixelRatio || 1, 2);

let W, H;
let state = 'start';
let score = 0, best = 0;
let combo = 0, comboMult = 1;
let buffer = 0.5;
let paint = 0; // 0=light, 1=dark
let rows = [];
let particles = [];
let lastTime = 0;
let distAcc = 0;
let shakeX = 0, shakeY = 0, shakeDur = 0, shakeStr = 0;
let hitstopTimer = 0;
let hueShift = 0;
let gameOverTimer = 0;
let challengeScore = null;
let showHint = true;
let hintTimer = 0;
let totalTime = 0;
let rowsSpawned = 0;

/* ── Runner ── */
const runner = { x: 0, targetX: 0, y: 0, r: 10, lane: 0 };

/* ── Lane positions ── */
let laneX = [0, 0];

/* ── Gate types ── */
const SAFE = 0, BONUS = 1, CHARGE = 2;

/* ── Load best ── */
try { best = parseInt(localStorage.getItem(LS_KEY)) || 0; } catch(e){}

/* ── Challenge param ── */
try {
  const p = new URLSearchParams(window.location.search);
  if (p.has('challenge')) {
    const v = parseInt(p.get('challenge'));
    if (!isNaN(v) && v > 0) challengeScore = v;
  }
} catch(e){}

/* ── Resize ── */
function resize() {
  W = Math.min(MAX_W, window.innerWidth);
  H = Math.min(MAX_H, window.innerHeight);
  canvas.width = Math.round(W * DPR);
  canvas.height = Math.round(H * DPR);
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  wrap.style.width = W + 'px';
  wrap.style.height = H + 'px';
  laneX[0] = W * 0.30;
  laneX[1] = W * 0.70;
  runner.y = H * 0.72;
  if (state !== 'playing') {
    runner.targetX = laneX[runner.lane];
    runner.x = runner.targetX;
  }
}
window.addEventListener('resize', resize);
resize();

/* ── Difficulty formulas ── */
function getSpeed() { return Math.min(520, 220 + 18 * Math.sqrt(score)); }
function getSpacing() { return Math.max(118, 178 - 0.55 * score); }
function getPBonus() { return Math.min(0.28, Math.max(0, 0.0035 * score)); }
function getPCharge() { return Math.min(0.10, Math.max(0.04, 0.10 - 0.0007 * score)); }
function getShrink() { return score > 40 ? Math.min(10, (score - 40) * 0.25) : 0; }
function getBurstChance() { return score > 50 ? Math.min(0.18, (score - 50) * 0.004) : 0; }

/* ── Gate width ── */
function gateWidth(type) {
  const s = getShrink();
  return type === BONUS ? Math.max(22, 34 - s) : Math.max(36, 54 - s);
}

/* ── Row spawning ── */
function makeRow(y) {
  const pB = getPBonus();
  const pC = getPCharge();
  const gates = [];
  for (let lane = 0; lane < 2; lane++) {
    let type = SAFE;
    const r = Math.random();
    if (r < pC) type = CHARGE;
    else if (r < pC + pB) type = BONUS;
    // First 3 rows: safe and wide
    if (rowsSpawned < 3) type = SAFE;
    const gPaint = Math.random() < 0.5 ? 0 : 1;
    gates.push({ lane: lane, type: type, paint: gPaint, w: gateWidth(type), scored: false, pulseT: Math.random() * 6.28 });
  }
  rowsSpawned++;
  return { y: y, gates: gates, resolved: false };
}

/* ── Particles ── */
function spawnBurst(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * 6.2832;
    const sp = 40 + Math.random() * 130;
    particles.push({
      x: x, y: y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp,
      life: 0.35 + Math.random() * 0.45, maxLife: 0.5,
      r: 2 + Math.random() * 3.5, color: color
    });
  }
}

function spawnTrail(x, y) {
  particles.push({
    x: x + (Math.random() - 0.5) * 6, y: y + 8,
    vx: (Math.random() - 0.5) * 12, vy: 15 + Math.random() * 25,
    life: 0.18 + Math.random() * 0.15, maxLife: 0.3,
    r: 1.2 + Math.random() * 2, color: paint === 0 ? '#ffe066' : '#7ecfff'
  });
}

function spawnScrape(x, y) {
  for (let i = 0; i < 7; i++) {
    particles.push({
      x: x, y: y, vx: (Math.random() - 0.5) * 90, vy: -20 + Math.random() * 50,
      life: 0.22, maxLife: 0.22,
      r: 1.5, color: '#ff8844'
    });
  }
}

/* ── Screen shake ── */
function triggerShake(str, dur) {
  shakeStr = Math.max(shakeStr, str);
  shakeDur = Math.max(shakeDur, dur);
}

/* ── Input ── */
let inputLocked = false;

function handleInput(e) {
  if (e.type === 'keydown') {
    if (e.code === 'Space') e.preventDefault();
    if (e.code !== 'Space' && e.code !== 'Enter') return;
  }
  if (inputLocked) return;
  if (state === 'start') {
    startGame();
  } else if (state === 'playing') {
    flipPaint();
  } else if (state === 'gameover') {
    if (gameOverTimer < 0.28) return;
    resetToStart();
  }
}

canvas.addEventListener('pointerdown', handleInput);
document.addEventListener('keydown', handleInput);

function flipPaint() {
  paint = paint === 0 ? 1 : 0;
  combo = 0;
  comboMult = 1;
  showHint = false;
}

function startGame() {
  state = 'playing';
  score = 0; combo = 0; comboMult = 1;
  buffer = 0.5; paint = 0;
  rows = []; particles = [];
  distAcc = 0; shakeX = 0; shakeY = 0; shakeDur = 0; shakeStr = 0;
  hitstopTimer = 0; gameOverTimer = 0;
  showHint = true; hintTimer = 0;
  totalTime = 0; rowsSpawned = 0;
  runner.lane = 0;
  runner.targetX = laneX[0];
  runner.x = laneX[0];
  // Spawn initial rows
  const sp = 178; // initial spacing
  for (let i = 0; i < 6; i++) {
    rows.push(makeRow(-60 - i * sp));
  }
}

function resetToStart() {
  state = 'start';
  particles = [];
  shakeX = 0; shakeY = 0; shakeDur = 0; shakeStr = 0;
}

function triggerGameOver() {
  state = 'gameover';
  gameOverTimer = 0;
  if (score > best) {
    best = score;
    try { localStorage.setItem(LS_KEY, best); } catch(e){}
  }
  triggerShake(10, 0.5);
  hitstopTimer = 0.12;
  spawnBurst(runner.x, runner.y, '#ff4466', 35);
}

/* ── Color helpers ── */
function hsl(h, s, l, a) {
  return a !== undefined ? 'hsla('+h+','+s+'%,'+l+'%,'+a+')' : 'hsl('+h+','+s+'%,'+l+'%)';
}

function paintColor(p, bright) {
  if (p === 0) return bright ? hsl((hueShift+45)%360, 80, 72) : hsl((hueShift+45)%360, 60, 55);
  return bright ? hsl((hueShift+220)%360, 70, 65) : hsl((hueShift+220)%360, 55, 45);
}

function paintOutline(p) {
  if (p === 0) return 'rgba(255,255,200,0.7)';
  return 'rgba(100,180,255,0.6)';
}

function bgGrad() {
  const base = paint === 0 ? (hueShift + 240) % 360 : (hueShift + 260) % 360;
  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, hsl(base, 28, 11));
  g.addColorStop(1, hsl((base + 20) % 360, 22, 7));
  return g;
}

/* ── Drawing patterns ── */
function drawDots(x, y, w, h) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(x - w/2, y - h/2, w, h);
  ctx.clip();
  const sp = 7;
  for (let dx = x - w/2 + 3; dx < x + w/2; dx += sp) {
    for (let dy = y - h/2 + 3; dy < y + h/2; dy += sp) {
      ctx.beginPath();
      ctx.arc(dx, dy, 1.4, 0, 6.2832);
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.fill();
    }
  }
  ctx.restore();
}

function drawStripes(x, y, w, h) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(x - w/2, y - h/2, w, h);
  ctx.clip();
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1.5;
  const sp = 6;
  for (let d = -w - h; d < w + h; d += sp) {
    ctx.beginPath();
    ctx.moveTo(x - w/2 + d, y - h/2);
    ctx.lineTo(x - w/2 + d + h, y + h/2);
    ctx.stroke();
  }
  ctx.restore();
}

function drawChargeStripes(x, y, w, h) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(x - w/2, y - h/2, w, h);
  ctx.clip();
  ctx.strokeStyle = 'rgba(255,220,50,0.45)';
  ctx.lineWidth = 2;
  const sp = 9;
  for (let d = -w - h; d < w + h; d += sp) {
    ctx.beginPath();
    ctx.moveTo(x - w/2 + d, y + h/2);
    ctx.lineTo(x - w/2 + d + h, y - h/2);
    ctx.stroke();
  }
  // Lightning mark
  ctx.fillStyle = 'rgba(255,220,50,0.8)';
  ctx.font = 'bold 11px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('\u26A1', x, y);
  ctx.restore();
}

/* ── Rounded rect ── */
function rRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

/* ── Auto-lane AI ── */
function pickLane() {
  let nearestRow = null;
  let nearestDist = Infinity;
  for (let i = 0; i < rows.length; i++) {
    if (rows[i].resolved) continue;
    const d = runner.y - rows[i].y;
    if (d > -80 && d < nearestDist) {
      nearestDist = d;
      nearestRow = rows[i];
    }
  }
  if (!nearestRow) return;
  let bestLane = 0, bestS = -999;
  for (const g of nearestRow.gates) {
    let s = 0;
    if (g.paint === paint) s += 10;
    if (g.type === BONUS && g.paint === paint) s += 5;
    if (g.type === CHARGE) s += (buffer < 0.4 ? 6 : 1);
    if (s > bestS) { bestS = s; bestLane = g.lane; }
  }
  runner.lane = bestLane;
}

/* ── Update ── */
function update(dt) {
  if (hitstopTimer > 0) { hitstopTimer -= dt; return; }

  // Shake decay
  if (shakeDur > 0) {
    shakeDur -= dt;
    shakeX = (Math.random()-0.5) * shakeStr * 2;
    shakeY = (Math.random()-0.5) * shakeStr * 2;
    shakeStr *= 0.9;
  } else { shakeX = 0; shakeY = 0; }

  if (state === 'gameover') {
    gameOverTimer += dt;
    updateParticles(dt);
    return;
  }
  if (state !== 'playing') return;

  totalTime += dt;
  hueShift = (hueShift + dt * 8) % 360;
  if (showHint) { hintTimer += dt; if (hintTimer > 5) showHint = false; }

  // Auto-lane pick
  pickLane();

  // Runner movement
  runner.targetX = laneX[runner.lane];
  runner.x += (runner.targetX - runner.x) * Math.min(1, dt * 14);

  // Trail
  if (Math.random() < 0.55) spawnTrail(runner.x, runner.y);

  const speed = getSpeed();
  const spacing = getSpacing();

  // Move rows
  for (let i = rows.length - 1; i >= 0; i--) {
    rows[i].y += speed * dt;
    if (rows[i].y > H + 50) rows.splice(i, 1);
  }

  // Collision
  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    if (row.resolved) continue;
    if (Math.abs(row.y - runner.y) <= 14) {
      row.resolved = true;
      resolveRow(row);
      if (state !== 'playing') return;
    }
  }

  // Spawn new rows
  distAcc += speed * dt;
  while (distAcc >= spacing) {
    distAcc -= spacing;
    const topY = rows.length > 0 ? Math.min.apply(null, rows.map(function(r){return r.y;})) : 0;
    let newY = topY - spacing;
    if (newY > -60) newY = -60;
    rows.push(makeRow(newY));
    // Burst chance
    if (Math.random() < getBurstChance()) {
      rows.push(makeRow(newY - spacing * 0.68));
    }
  }

  // Particles
  updateParticles(dt);
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
  // Cap particle count
  if (particles.length > 200) particles.splice(0, particles.length - 200);
}

function resolveRow(row) {
  // Find gate in runner's lane
  let g = null;
  for (let i = 0; i < row.gates.length; i++) {
    if (row.gates[i].lane === runner.lane) { g = row.gates[i]; break; }
  }
  if (!g) { triggerGameOver(); return; }

  const gx = laneX[g.lane];
  const halfW = g.w / 2;
  const dist = Math.abs(runner.x - gx);

  if (dist > halfW + runner.r + 2) {
    triggerGameOver();
    return;
  }

  if (g.paint === paint) {
    successGate(g, dist, halfW, false);
  } else if (buffer > 0) {
    // Auto-flip save
    paint = g.paint;
    buffer = Math.max(0, buffer - 0.35);
    successGate(g, dist, halfW, true);
    triggerShake(5, 0.22);
    spawnBurst(runner.x, runner.y, '#ffaa00', 12);
  } else {
    triggerGameOver();
  }
}

function successGate(g, dist, halfW, wasSave) {
  const edgeDist = halfW - dist + runner.r;
  const nearMiss = edgeDist >= 0 && edgeDist < 4;

  let base = 1;
  if (g.type === BONUS) base = 3;
  if (g.type === CHARGE) {
    base = 1;
    buffer = Math.min(1, buffer + 0.45);
    spawnBurst(runner.x, runner.y, '#ffee44', 8);
  }

  if (!wasSave) {
    combo++;
  } else {
    combo = 0;
  }
  comboMult = Math.min(4, 1 + Math.floor(combo / 4));
  score += base * comboMult;

  // Perfect drip (no save, no near-miss)
  if (!wasSave && !nearMiss) {
    buffer = Math.min(1, buffer + 0.03);
  }

  // Particles
  const col = paintColor(g.paint, true);
  const count = g.type === BONUS ? 20 : 9;
  spawnBurst(runner.x, runner.y, col, count);

  if (g.type === BONUS) triggerShake(3, 0.15);

  if (nearMiss) spawnScrape(runner.x + (dist > 0 ? runner.r : -runner.r), runner.y);

  g.scored = true;
}

/* ── Draw ── */
function draw() {
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.clearRect(0, 0, W, H);

  // Background
  ctx.fillStyle = bgGrad();
  ctx.fillRect(0, 0, W, H);

  // Lane guides
  ctx.globalAlpha = 0.07;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1;
  for (let i = 0; i < 2; i++) {
    ctx.beginPath();
    ctx.moveTo(laneX[i], 0);
    ctx.lineTo(laneX[i], H);
    ctx.stroke();
  }
  // Center divider
  ctx.beginPath();
  ctx.moveTo(W/2, 0);
  ctx.lineTo(W/2, H);
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Apply shake
  ctx.save();
  ctx.translate(shakeX, shakeY);

  if (state === 'playing' || state === 'gameover') {
    drawGates();
    drawRunner();
    drawParticles();
    drawUI();
  }

  ctx.restore();

  if (state === 'start') drawStartScreen();
  if (state === 'gameover') drawGameOverScreen();
}

function drawGates() {
  for (let ri = 0; ri < rows.length; ri++) {
    const row = rows[ri];
    for (let gi = 0; gi < row.gates.length; gi++) {
      const g = row.gates[gi];
      if (g.scored) continue;
      const x = laneX[g.lane];
      const y = row.y;
      const gw = g.w;
      const gh = 18;

      // Pulse for bonus
      let scale = 1;
      if (g.type === BONUS) {
        g.pulseT += 0.06;
        scale = 1 + 0.1 * Math.sin(g.pulseT);
      }

      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);

      // Gate body fill
      const col = paintColor(g.paint, true);
      ctx.fillStyle = col;
      ctx.globalAlpha = 0.85;
      rRect(-gw/2, -gh/2, gw, gh, 6);
      ctx.fill();

      // Bloom/glow stroke
      ctx.globalAlpha = 0.5;
      ctx.strokeStyle = col;
      ctx.lineWidth = 4;
      rRect(-gw/2 - 2, -gh/2 - 2, gw + 4, gh + 4, 8);
      ctx.stroke();

      // Outline (colorblind)
      ctx.globalAlpha = 1;
      ctx.strokeStyle = paintOutline(g.paint);
      ctx.lineWidth = g.paint === 0 ? 1.5 : 2.5;
      rRect(-gw/2, -gh/2, gw, gh, 6);
      ctx.stroke();

      // Pattern overlay
      ctx.globalAlpha = 1;
      if (g.type === CHARGE) {
        drawChargeStripes(0, 0, gw, gh);
      } else if (g.paint === 0) {
        drawDots(0, 0, gw, gh);
      } else {
        drawStripes(0, 0, gw, gh);
      }

      ctx.restore();
    }
  }
}

function drawRunner() {
  const x = runner.x;
  const y = runner.y;
  const r = runner.r;

  // Glow
  const gc = paint === 0 ? '255,230,100' : '100,180,255';
  const glow = ctx.createRadialGradient(x, y, r*0.4, x, y, r*2.8);
  glow.addColorStop(0, 'rgba('+gc+',0.45)');
  glow.addColorStop(1, 'rgba('+gc+',0)');
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(x, y, r*2.8, 0, 6.2832);
  ctx.fill();

  // Ball
  ctx.fillStyle = paintColor(paint, true);
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 6.2832);
  ctx.fill();

  // Highlight
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.beginPath();
  ctx.arc(x - r*0.3, y - r*0.3, r*0.38, 0, 6.2832);
  ctx.fill();

  // Paint indicator pattern on ball
  if (paint === 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath();
    ctx.arc(x, y, 2, 0, 6.2832);
    ctx.fill();
  } else {
    ctx.strokeStyle = 'rgba(255,255,255,0.45)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x-3, y-3); ctx.lineTo(x+3, y+3);
    ctx.moveTo(x+3, y-3); ctx.lineTo(x-3, y+3);
    ctx.stroke();
  }
}

function drawParticles() {
  for (let i = 0; i < particles.length; i++) {
    const p = particles[i];
    const a = Math.max(0, p.life / p.maxLife);
    ctx.globalAlpha = a;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * (0.3 + 0.7*a), 0, 6.2832);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawUI() {
  // Score top-left
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 24px sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText(score, 16, 14);

  // Best top-right
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillStyle = '#999';
  ctx.fillText('BEST ' + best, W - 16, 16);

  // Combo display
  if (combo >= 4) {
    ctx.font = 'bold 13px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = hsl((hueShift+60)%360, 90, 72);
    ctx.fillText('x' + comboMult + '  COMBO ' + combo, W/2, 16);
  }

  // Buffer bar
  const barW = 76, barH = 5;
  const barX = W/2 - barW/2, barY = 38;
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  rRect(barX, barY, barW, barH, 2.5);
  ctx.fill();

  const bPct = Math.max(0, Math.min(1, buffer));
  const bCol = bPct > 0.3 ? hsl(140, 65, 50) : hsl(0, 65, 50);
  if (bPct > 0) {
    ctx.fillStyle = bCol;
    rRect(barX, barY, barW * bPct, barH, 2.5);
    ctx.fill();
  }

  ctx.font = '8px sans-serif';
  ctx.fillStyle = '#777';
  ctx.textAlign = 'center';
  ctx.fillText('BUFFER', W/2, barY + barH + 8);

  // Paint state indicator
  ctx.font = '10px sans-serif';
  ctx.fillStyle = paintColor(paint, true);
  ctx.fillText(paint === 0 ? '\u25CF LIGHT' : '\u2716 DARK', W/2, barY + barH + 20);

  // Hint
  if (showHint) {
    const ha = 0.5 + 0.5 * Math.sin(totalTime * 5);
    ctx.globalAlpha = ha;
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.fillText('Tap to Flip', W/2, runner.y + 38);
    ctx.globalAlpha = 1;
  }
}

function drawStartScreen() {
  ctx.fillStyle = 'rgba(12,12,30,0.72)';
  ctx.fillRect(0, 0, W, H);

  // Animated runner preview
  const t = Date.now() * 0.003;
  const previewPaint = Math.floor(t) % 2;
  const previewColor = paintColor(previewPaint, true);
  const px = W/2, py = H * 0.42;
  const glow = ctx.createRadialGradient(px, py, 5, px, py, 30);
  glow.addColorStop(0, previewPaint === 0 ? 'rgba(255,230,100,0.4)' : 'rgba(100,180,255,0.4)');
  glow.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(px, py, 30, 0, 6.2832);
  ctx.fill();
  ctx.fillStyle = previewColor;
  ctx.beginPath();
  ctx.arc(px, py, 14, 0, 6.2832);
  ctx.fill();

  // Title
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 40px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Color Dash', W/2, H * 0.28);

  ctx.font = '14px sans-serif';
  ctx.fillStyle = '#aaa';
  ctx.fillText('Paint Split', W/2, H * 0.28 + 32);

  // Tap to start
  const alpha = 0.45 + 0.55 * Math.sin(Date.now() * 0.004);
  ctx.globalAlpha = alpha;
  ctx.font = '18px sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText('Tap to Start', W/2, H * 0.57);
  ctx.globalAlpha = 1;

  // Challenge banner
  if (challengeScore !== null) {
    ctx.fillStyle = hsl(45, 90, 62);
    ctx.font = 'bold 14px sans-serif';
    ctx.fillText('Challenge: Beat ' + challengeScore + ' pts!', W/2, H * 0.66);
  }

  // Best score
  if (best > 0) {
    ctx.fillStyle = '#777';
    ctx.font = '13px sans-serif';
    ctx.fillText('Best: ' + best, W/2, H * 0.74);
  }

  // Controls
  ctx.fillStyle = '#555';
  ctx.font = '11px sans-serif';
  ctx.fillText('Space / Enter / Tap', W/2, H * 0.84);
}

function drawGameOverScreen() {
  ctx.fillStyle = 'rgba(12,12,30,0.78)';
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = '#ff6677';
  ctx.font = 'bold 30px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Game Over', W/2, H * 0.26);

  ctx.fillStyle = '#fff';
  ctx.font = 'bold 44px sans-serif';
  ctx.fillText(score, W/2, H * 0.36);

  ctx.fillStyle = '#aaa';
  ctx.font = '14px sans-serif';
  ctx.fillText('Best: ' + best, W/2, H * 0.43);

  // Combo recap
  if (comboMult > 1) {
    ctx.fillStyle = '#cc9';
    ctx.font = '12px sans-serif';
    ctx.fillText('Max Multiplier: x' + comboMult, W/2, H * 0.48);
  }

  // Challenge result
  let shareY = H * 0.56;
  if (challengeScore !== null) {
    if (score >= challengeScore) {
      ctx.fillStyle = '#66ff88';
      ctx.font = 'bold 16px sans-serif';
      ctx.fillText('Challenge Beaten! \u2714', W/2, H * 0.53);
    } else {
      ctx.fillStyle = '#ff8866';
      ctx.font = '14px sans-serif';
      ctx.fillText('Needed ' + challengeScore + ' - Try again!', W/2, H * 0.53);
    }
    shareY = H * 0.60;
  }

  // Share button
  const bw = 110, bh = 32, bx = W/2 - bw/2, by = shareY;
  ctx.fillStyle = hsl(210, 60, 48);
  rRect(bx, by, bw, bh, 10);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 13px sans-serif';
  ctx.fillText('Share', W/2, by + bh/2);

  // Tap to retry
  const alpha = 0.45 + 0.55 * Math.sin(Date.now() * 0.004);
  ctx.globalAlpha = alpha;
  ctx.font = '16px sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText('Tap to Retry', W/2, H * 0.76);
  ctx.globalAlpha = 1;
}

/* ── Share button detection ── */
canvas.addEventListener('pointerdown', function(e) {
  if (state !== 'gameover') return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (W / rect.width);
  const my = (e.clientY - rect.top) * (H / rect.height);
  let shareY = challengeScore !== null ? H * 0.60 : H * 0.56;
  const bw = 110, bh = 32, bx = W/2 - bw/2;
  if (mx >= bx && mx <= bx + bw && my >= shareY && my <= shareY + bh) {
    e.stopPropagation();
    inputLocked = true;
    setTimeout(function(){ inputLocked = false; }, 300);
    const url = window.location.origin + window.location.pathname + '?challenge=' + score;
    const text = 'I scored ' + score + ' in Color Dash! Can you beat it?';
    if (navigator.share) {
      navigator.share({ title: 'Color Dash Challenge', text: text, url: url }).catch(function(){});
    } else {
      try {
        navigator.clipboard.writeText(text + ' ' + url);
      } catch(e2){}
    }
  }
});

/* ── Prevent scroll/zoom ── */
document.addEventListener('touchmove', function(e){ e.preventDefault(); }, { passive: false });
document.addEventListener('gesturestart', function(e){ e.preventDefault(); });

/* ── Main loop ── */
function loop(ts) {
  requestAnimationFrame(loop);
  if (!lastTime) { lastTime = ts; return; }
  let dt = (ts - lastTime) / 1000;
  lastTime = ts;
  if (dt > 0.1) dt = 0.1;
  update(dt);
  draw();
}

requestAnimationFrame(loop);

})();
</script>
</body>
</html>