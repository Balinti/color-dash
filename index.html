<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="theme-color" content="#1a1a2e">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Run through sync gates matching your color and shape. Tap to switch lanes and cycle your badge. How far can you dash?">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<link rel="canonical" href="https://balinti.github.io/color-dash/">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow-x:hidden;background:#0a0a1a;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;touch-action:none;user-select:none;-webkit-user-select:none}
#wrap{display:flex;flex-direction:column;align-items:center;width:100%;min-height:100vh;overflow-y:auto;background:linear-gradient(180deg,#0a0a1a 0%,#16213e 50%,#0f3460 100%)}
#game-container{position:relative;width:100%;max-width:420px;flex-shrink:0}
canvas{display:block;width:100%;height:100%;touch-action:none}
#seo-content{max-width:420px;width:100%;padding:18px 16px 32px;color:#b0b8d0;font-size:13px;line-height:1.6;flex-shrink:0}
#seo-content h2{color:#e0e6f0;font-size:16px;margin:14px 0 6px}
#seo-content h3{color:#c8d0e4;font-size:14px;margin:12px 0 4px}
#seo-content p,#seo-content li{margin-bottom:4px}
#seo-content ul{padding-left:18px}
</style>
</head>
<body>
<div id="wrap">
<div id="game-container">
<canvas id="gc"></canvas>
</div>
<div id="seo-content">
<h2>How to Play Color Dash</h2>
<p>Tap or press Space to shift lanes and cycle your color+shape badge. Match the incoming Sync Gates to score points. Hit the center sweet spot for a Perfect bonus and build your streak multiplier!</p>
<h3>Tips</h3>
<ul>
<li>Watch the telegraph strip at the top to plan ahead for the next gates.</li>
<li>Build up Perfect streaks to increase your multiplier and fill the Sync Meter.</li>
<li>During Overdrive, only shapes matter &mdash; dash through any color!</li>
<li>Speed increases over time, so stay focused and react quickly.</li>
</ul>
<h3>FAQ</h3>
<p><strong>Q: Is Color Dash free?</strong><br>A: Yes! It runs entirely in your browser with no downloads needed.</p>
<p><strong>Q: How do I get a high score?</strong><br>A: Chain Perfect passes to build streak multipliers. The Sync Meter grants Overdrive for even more points.</p>
<p><strong>Q: Does it work on mobile?</strong><br>A: Absolutely. Tap anywhere on the screen to play.</p>
<p><strong>Q: What is Overdrive?</strong><br>A: Fill the Sync Meter with Perfect passes. During Overdrive, color matching is ignored &mdash; only shape matters, making it easier to score big.</p>
</div>
</div>
<script>
(function(){
"use strict";

const canvas = document.getElementById('gc');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');

// --- Constants ---
const MAX_W = 420, MAX_H = 750;
const DPR = Math.min(window.devicePixelRatio || 1, 2);
const TRACK_PAD = 18;
const GATE_H = 74;
const LS_KEY = 'color_dash_highscore';

// Badge cycle: 6 combos of 3 hues x 3 shapes
const HUES = [200, 330, 120];
const BADGE_CYCLE = [
  { hue: 200, shape: 0 }, // blue circle
  { hue: 330, shape: 1 }, // pink triangle
  { hue: 120, shape: 2 }, // green square
  { hue: 200, shape: 1 }, // blue triangle
  { hue: 330, shape: 2 }, // pink square
  { hue: 120, shape: 0 }, // green circle
];

// --- State variables ---
let W, H, laneW;
let state = 'start';
let score, bestScore, badgeIdx, laneIdx;
let gates, particles, sparks;
let speed, spawnTimer, spawnDt;
let perfectWinPx, tier, pSplit;
let streakPerfect, multiplier, syncMeter;
let overdrive, overdriveTTL;
let screenShakeX, screenShakeY, shakeTimer;
let hitStopTimer;
let gameOverLock;
let elapsedTime;
let flashAlpha;
let bgHueShift;
let uiPopScale, uiPopTimer;

// --- Resize ---
function resize() {
  const vw = Math.min(window.innerWidth, MAX_W);
  const vh = Math.min(window.innerHeight, MAX_H);
  W = vw;
  H = vh;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  canvas.width = Math.round(W * DPR);
  canvas.height = Math.round(H * DPR);
  container.style.width = W + 'px';
  container.style.height = H + 'px';
  laneW = (W - TRACK_PAD * 2) / 3;
}
window.addEventListener('resize', resize);
resize();

// --- Helpers ---
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
function rand(a, b) { return a + Math.random() * (b - a); }
function randInt(a, b) { return Math.floor(rand(a, b + 1)); }
function hsl(h, s, l, a) {
  h = ((h % 360) + 360) % 360;
  return a !== undefined
    ? 'hsla(' + (h|0) + ',' + (s|0) + '%,' + (l|0) + '%,' + a + ')'
    : 'hsl(' + (h|0) + ',' + (s|0) + '%,' + (l|0) + '%)';
}

function loadBest() {
  try { return parseInt(localStorage.getItem(LS_KEY)) || 0; } catch(e) { return 0; }
}
function saveBest(s) {
  try { localStorage.setItem(LS_KEY, String(s)); } catch(e) {}
}

// --- Shape drawing ---
function drawShape(cx, cy, shape, size, fill, stroke) {
  ctx.fillStyle = fill;
  ctx.beginPath();
  if (shape === 0) {
    ctx.arc(cx, cy, size, 0, Math.PI * 2);
  } else if (shape === 1) {
    ctx.moveTo(cx, cy - size);
    ctx.lineTo(cx + size * 0.95, cy + size * 0.7);
    ctx.lineTo(cx - size * 0.95, cy + size * 0.7);
    ctx.closePath();
  } else {
    const hs = size * 0.85;
    ctx.rect(cx - hs, cy - hs, hs * 2, hs * 2);
  }
  ctx.fill();
  if (stroke) {
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

function drawShapeOutline(cx, cy, shape, size, color, lw) {
  ctx.strokeStyle = color;
  ctx.lineWidth = lw || 2;
  ctx.beginPath();
  if (shape === 0) {
    ctx.arc(cx, cy, size, 0, Math.PI * 2);
  } else if (shape === 1) {
    ctx.moveTo(cx, cy - size);
    ctx.lineTo(cx + size * 0.95, cy + size * 0.7);
    ctx.lineTo(cx - size * 0.95, cy + size * 0.7);
    ctx.closePath();
  } else {
    const hs = size * 0.85;
    ctx.rect(cx - hs, cy - hs, hs * 2, hs * 2);
  }
  ctx.stroke();
}

// --- Particles ---
function spawnParticles(x, y, color, count, spdMult) {
  spdMult = spdMult || 1;
  for (let i = 0; i < count && particles.length < 300; i++) {
    const angle = rand(0, Math.PI * 2);
    const spd = rand(40, 160) * spdMult;
    particles.push({
      x: x, y: y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd,
      life: 1, decay: rand(1.2, 2.5),
      r: rand(2, 5), color: color, sparkle: false
    });
  }
}

function spawnSparkles(x, y, count) {
  for (let i = 0; i < count && particles.length < 300; i++) {
    const angle = rand(0, Math.PI * 2);
    const spd = rand(30, 120);
    particles.push({
      x: x, y: y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd,
      life: 1, decay: rand(1.5, 3.0),
      r: rand(1.5, 3.5), color: '#fff', sparkle: true
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 80 * dt;
    p.life -= p.decay * dt;
    if (p.life <= 0) { particles[i] = particles[particles.length - 1]; particles.pop(); }
  }
}

function drawParticles() {
  for (let i = 0; i < particles.length; i++) {
    const p = particles[i];
    const a = clamp(p.life, 0, 1);
    ctx.globalAlpha = a;
    if (p.sparkle) {
      ctx.fillStyle = '#fff';
      const sz = p.r * (0.5 + 0.5 * Math.sin(p.life * 12));
      ctx.fillRect(p.x - sz, p.y - sz, sz * 2, sz * 2);
    } else {
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r * a, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

// --- Overdrive sparks ---
function spawnOverdriveSpark(x, y) {
  if (sparks.length > 60) return;
  sparks.push({
    x: x + rand(-10, 10), y: y,
    vx: rand(-25, 25), vy: rand(-70, -20),
    life: 1, decay: rand(2, 4), r: rand(2, 4)
  });
}

function updateSparks(dt) {
  for (let i = sparks.length - 1; i >= 0; i--) {
    const s = sparks[i];
    s.x += s.vx * dt;
    s.y += s.vy * dt;
    s.life -= s.decay * dt;
    if (s.life <= 0) { sparks[i] = sparks[sparks.length - 1]; sparks.pop(); }
  }
}

function drawSparks() {
  for (let i = 0; i < sparks.length; i++) {
    const s = sparks[i];
    const a = clamp(s.life, 0, 1);
    const h = (elapsedTime * 120) % 360;
    ctx.globalAlpha = a * 0.8;
    ctx.fillStyle = hsl(h, 90, 70);
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r * a, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// --- Screen shake ---
function triggerShake(intensity, dur) {
  shakeTimer = dur;
  screenShakeX = rand(-intensity, intensity);
  screenShakeY = rand(-intensity, intensity);
}

function updateShake(dt) {
  if (shakeTimer > 0) {
    shakeTimer -= dt;
    const intensity = shakeTimer * 10;
    screenShakeX = rand(-intensity, intensity);
    screenShakeY = rand(-intensity, intensity);
  } else {
    screenShakeX = 0;
    screenShakeY = 0;
  }
}

// --- Difficulty formulas ---
function calcDifficulty() {
  speed = Math.min(260 + 6.0 * score + 18 * Math.log2(1 + score / 10), 620);
  spawnDt = clamp(0.92 - 0.0045 * score, 0.42, 0.92);
  perfectWinPx = clamp(18 - 0.10 * score, 10, 18);
  tier = Math.floor(score / 15);
  pSplit = clamp(0.10 + 0.08 * tier, 0.10, 0.55);
}

// --- Badge helper ---
function badgeAt(idx) { return BADGE_CYCLE[((idx % 6) + 6) % 6]; }
function getPlayerY() { return H * 0.78; }
function laneX(li) { return TRACK_PAD + laneW * li + laneW / 2; }

// --- Gate logic ---
function getReqForLane(gate, li) {
  return gate.type === 'split' ? gate.reqs[li] : gate.req;
}

function matchGate(gate, li, bi) {
  const req = getReqForLane(gate, li);
  const badge = badgeAt(bi);
  if (overdrive > 0) return badge.shape === req.shape;
  return badge.hue === req.hue && badge.shape === req.shape;
}

function isSolvable(gate) {
  // Check if there exists k in {0,1,2} taps that results in a matching state
  for (let k = 0; k < 3; k++) {
    const testLane = (laneIdx + k) % 3;
    const testBadge = badgeAt(badgeIdx + k);
    const req = getReqForLane(gate, testLane);
    if (overdrive > 0) {
      if (testBadge.shape === req.shape) return true;
    } else {
      if (testBadge.hue === req.hue && testBadge.shape === req.shape) return true;
    }
  }
  return false;
}

function spawnGate() {
  const isSplit = Math.random() < pSplit;
  const gate = { y: -GATE_H, scored: false, missed: false };

  if (isSplit) {
    gate.type = 'split';
    gate.reqs = [];
    for (let i = 0; i < 3; i++) {
      const bi = randInt(0, 5);
      gate.reqs.push({ hue: BADGE_CYCLE[bi].hue, shape: BADGE_CYCLE[bi].shape });
    }
  } else {
    gate.type = 'single';
    const bi = randInt(0, 5);
    gate.req = { hue: BADGE_CYCLE[bi].hue, shape: BADGE_CYCLE[bi].shape };
  }

  // Solvability guarantee
  if (!isSolvable(gate)) {
    // Pick a random k in {0,1,2} and force that lane+badge to match
    const k = randInt(0, 2);
    const forceLane = (laneIdx + k) % 3;
    const forceBadge = badgeAt(badgeIdx + k);
    const forceReq = { hue: forceBadge.hue, shape: forceBadge.shape };
    if (gate.type === 'split') {
      gate.reqs[forceLane] = forceReq;
    } else {
      gate.req = forceReq;
    }
  }

  gates.push(gate);
}

// --- Init ---
function init() {
  score = 0;
  bestScore = loadBest();
  badgeIdx = 0;
  laneIdx = 1;
  gates = [];
  particles = [];
  sparks = [];
  spawnTimer = 0.5;
  streakPerfect = 0;
  multiplier = 1;
  syncMeter = 0;
  overdrive = 0;
  overdriveTTL = 0;
  screenShakeX = 0;
  screenShakeY = 0;
  shakeTimer = 0;
  hitStopTimer = 0;
  gameOverLock = 0;
  elapsedTime = 0;
  flashAlpha = 0;
  bgHueShift = 0;
  uiPopScale = 1;
  uiPopTimer = 0;
  calcDifficulty();
}

// --- Input ---
function handleInput() {
  if (state === 'start') {
    state = 'playing';
    init();
    return;
  }
  if (state === 'gameover') {
    if (gameOverLock > 0) return;
    state = 'playing';
    init();
    return;
  }
  if (state === 'playing') {
    laneIdx = (laneIdx + 1) % 3;
    badgeIdx = (badgeIdx + 1) % BADGE_CYCLE.length;
  }
}

canvas.addEventListener('pointerdown', function(e) {
  e.preventDefault();
  handleInput();
});
document.addEventListener('keydown', function(e) {
  if (e.code === 'Space' || e.code === 'Enter') {
    e.preventDefault();
    handleInput();
  }
});

// --- Game Over ---
function triggerGameOver() {
  state = 'gameover';
  gameOverLock = 0.8;
  if (score > bestScore) {
    bestScore = score;
    saveBest(bestScore);
  }
  triggerShake(7, 0.5);
  flashAlpha = 0.6;
  const px = laneX(laneIdx);
  const py = getPlayerY();
  spawnParticles(px, py, '#f44', 30, 1.5);
}

// --- Update ---
function update(dt) {
  if (state !== 'playing') return;

  // Hit-stop
  if (hitStopTimer > 0) {
    hitStopTimer -= dt;
    return;
  }

  elapsedTime += dt;
  bgHueShift = (elapsedTime * 8 + multiplier * 15) % 360;

  // UI pop timer
  if (uiPopTimer > 0) {
    uiPopTimer -= dt;
    uiPopScale = 1 + 0.35 * clamp(uiPopTimer / 0.3, 0, 1);
  } else {
    uiPopScale = 1;
  }

  // Overdrive countdown
  if (overdrive > 0) {
    overdriveTTL -= dt;
    if (overdriveTTL <= 0) {
      overdrive = 0;
      overdriveTTL = 0;
    }
    const px = laneX(laneIdx);
    const py = getPlayerY();
    if (Math.random() < 0.5) spawnOverdriveSpark(px, py);
  }

  calcDifficulty();

  // Spawn gates
  spawnTimer -= dt;
  if (spawnTimer <= 0) {
    spawnGate();
    spawnTimer = spawnDt;
  }

  // Move and evaluate gates
  const py = getPlayerY();
  for (let i = gates.length - 1; i >= 0; i--) {
    const g = gates[i];
    g.y += speed * dt;
    const gCenter = g.y + GATE_H / 2;

    if (!g.scored && !g.missed) {
      // Gate overlapping player zone
      if (gCenter >= py - GATE_H * 0.5 && gCenter <= py + GATE_H * 0.5) {
        if (matchGate(g, laneIdx, badgeIdx)) {
          g.scored = true;
          const isPerfect = Math.abs(gCenter - py) <= perfectWinPx;
          const basePoints = isPerfect ? 2 : 1;
          score += basePoints * multiplier;

          if (isPerfect) {
            streakPerfect++;
            multiplier = 1 + Math.floor(streakPerfect / 5);
            syncMeter = Math.min(syncMeter + 0.12, 1);
            hitStopTimer = 0.06;
            uiPopTimer = 0.3;
            const px = laneX(laneIdx);
            spawnParticles(px, py, hsl(badgeAt(badgeIdx).hue, 80, 60), 22, 1.2);
            spawnSparkles(px, py, 14);
            triggerShake(3, 0.15);
          } else {
            syncMeter = Math.min(syncMeter + 0.02, 1);
            const px = laneX(laneIdx);
            spawnParticles(px, py, hsl(badgeAt(badgeIdx).hue, 70, 55), 10, 0.8);
            triggerShake(1.5, 0.08);
          }

          // Check overdrive activation
          if (syncMeter >= 1) {
            overdrive = 1;
            overdriveTTL = 3.0;
            syncMeter = 0;
            triggerShake(5, 0.3);
            const px = laneX(laneIdx);
            spawnParticles(px, py, '#fff', 28, 1.5);
            spawnSparkles(px, py, 22);
          }
        } else {
          g.missed = true;
          triggerGameOver();
          return;
        }
      }
    }

    // Miss: gate scrolled past player entirely
    if (!g.scored && !g.missed && g.y > py + GATE_H) {
      g.missed = true;
      streakPerfect = 0;
      multiplier = 1;
      triggerGameOver();
      return;
    }

    // Remove off-screen
    if (g.y > H + 60) {
      gates[i] = gates[gates.length - 1];
      gates.pop();
    }
  }

  updateParticles(dt);
  updateSparks(dt);
  updateShake(dt);
}

// --- Draw functions ---
function drawTrack() {
  // Lane dividers
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 3; i++) {
    const x = TRACK_PAD + laneW * i;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, H);
    ctx.stroke();
  }

  // Active lane highlight
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  const alx = TRACK_PAD + laneW * laneIdx;
  ctx.fillRect(alx, 0, laneW, H);

  // Center dashes
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 1;
  ctx.setLineDash([18, 22]);
  for (let li = 0; li < 2; li++) {
    const dx = TRACK_PAD + laneW * (li + 1);
    ctx.beginPath();
    ctx.moveTo(dx, 0);
    ctx.lineTo(dx, H);
    ctx.stroke();
  }
  ctx.setLineDash([]);
}

function drawGates() {
  const py = getPlayerY();
  for (let gi = 0; gi < gates.length; gi++) {
    const g = gates[gi];
    if (g.y + GATE_H < -10 || g.y > H + 10) continue;
    if (g.scored) continue;

    for (let li = 0; li < 3; li++) {
      const req = getReqForLane(g, li);
      const gx = TRACK_PAD + laneW * li;
      const gy = g.y;

      // Gate background
      const bga = overdrive > 0 ? 0.2 : 0.3;
      ctx.fillStyle = hsl(req.hue, 55, 22, bga);
      ctx.fillRect(gx + 1, gy + 1, laneW - 2, GATE_H - 2);

      // Gate border
      ctx.strokeStyle = hsl(req.hue, 65, 48, 0.55);
      ctx.lineWidth = 2;
      ctx.strokeRect(gx + 2, gy + 2, laneW - 4, GATE_H - 4);

      // Inner glow
      const grad = ctx.createRadialGradient(
        gx + laneW / 2, gy + GATE_H / 2, 0,
        gx + laneW / 2, gy + GATE_H / 2, laneW * 0.45
      );
      grad.addColorStop(0, hsl(req.hue, 75, 50, 0.12));
      grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad;
      ctx.fillRect(gx, gy, laneW, GATE_H);

      // Shape icon in gate
      const scx = gx + laneW / 2;
      const scy = gy + GATE_H / 2;
      if (overdrive > 0) {
        drawShape(scx, scy, req.shape, 14, hsl(0, 0, 80, 0.75));
        drawShapeOutline(scx, scy, req.shape, 14, hsl(req.hue, 40, 45, 0.35), 1);
      } else {
        drawShape(scx, scy, req.shape, 14, hsl(req.hue, 70, 55));
      }
    }

    // Perfect zone pulse near player
    if (!g.scored && !g.missed) {
      const gCenter = g.y + GATE_H / 2;
      const dist = Math.abs(gCenter - py);
      if (dist < GATE_H * 1.2) {
        const pulse = 0.5 + 0.5 * Math.sin(elapsedTime * 10);
        const a = clamp((1 - dist / (GATE_H * 1.2)) * 0.25 * pulse, 0, 0.3);
        ctx.fillStyle = 'rgba(255,255,255,' + a + ')';
        ctx.fillRect(TRACK_PAD, py - perfectWinPx, W - TRACK_PAD * 2, perfectWinPx * 2);
      }
    }
  }
}

function drawPlayer() {
  const px = laneX(laneIdx);
  const py = getPlayerY();
  const badge = badgeAt(badgeIdx);

  // Glow
  const glowR = 30 + 5 * Math.sin(elapsedTime * 4);
  const glow = ctx.createRadialGradient(px, py, 0, px, py, glowR);
  if (overdrive > 0) {
    const oh = (elapsedTime * 200) % 360;
    glow.addColorStop(0, hsl(oh, 90, 65, 0.45));
  } else {
    glow.addColorStop(0, hsl(badge.hue, 80, 58, 0.4));
  }
  glow.addColorStop(1, 'transparent');
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(px, py, glowR, 0, Math.PI * 2);
  ctx.fill();

  // Body
  ctx.beginPath();
  ctx.arc(px, py, 18, 0, Math.PI * 2);
  if (overdrive > 0) {
    const oh = (elapsedTime * 200) % 360;
    ctx.fillStyle = hsl(oh, 90, 65);
    ctx.strokeStyle = '#fff';
  } else {
    ctx.fillStyle = hsl(badge.hue, 72, 52);
    ctx.strokeStyle = hsl(badge.hue, 78, 72);
  }
  ctx.lineWidth = 2.5;
  ctx.fill();
  ctx.stroke();

  // Shape inside player
  drawShape(px, py, badge.shape, 9, 'rgba(255,255,255,0.9)');
}

function drawTelegraph() {
  // Show next 2 upcoming gates as small icons at top
  const py = getPlayerY();
  const upcoming = [];
  for (let i = 0; i < gates.length && upcoming.length < 2; i++) {
    const g = gates[i];
    if (!g.scored && !g.missed && g.y + GATE_H / 2 < py - GATE_H) {
      upcoming.push(g);
    }
  }
  if (upcoming.length === 0) return;

  const ty = 8;
  const tw = 52, th = 28, gap = 8;
  const totalW = upcoming.length * tw + (upcoming.length - 1) * gap;
  const startX = (W - totalW) / 2;

  ctx.globalAlpha = 0.55;
  for (let i = 0; i < upcoming.length; i++) {
    const g = upcoming[i];
    const x = startX + i * (tw + gap);

    if (g.type === 'single') {
      const req = g.req;
      ctx.fillStyle = hsl(req.hue, 45, 18, 0.75);
      roundRect(ctx, x, ty, tw, th, 4);
      ctx.fill();
      ctx.strokeStyle = hsl(req.hue, 55, 42, 0.7);
      ctx.lineWidth = 1;
      roundRect(ctx, x, ty, tw, th, 4);
      ctx.stroke();
      drawShape(x + tw / 2, ty + th / 2, req.shape, 7, hsl(req.hue, 65, 55));
    } else {
      const cw = tw / 3;
      for (let li = 0; li < 3; li++) {
        const req = g.reqs[li];
        ctx.fillStyle = hsl(req.hue, 45, 18, 0.75);
        ctx.fillRect(x + cw * li, ty, cw, th);
        drawShape(x + cw * li + cw / 2, ty + th / 2, req.shape, 5, hsl(req.hue, 65, 55));
      }
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 1;
      roundRect(ctx, x, ty, tw, th, 4);
      ctx.stroke();
    }
  }
  ctx.globalAlpha = 1;
}

function roundRect(c, x, y, w, h, r) {
  c.beginPath();
  c.moveTo(x + r, y);
  c.lineTo(x + w - r, y);
  c.quadraticCurveTo(x + w, y, x + w, y + r);
  c.lineTo(x + w, y + h - r);
  c.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  c.lineTo(x + r, y + h);
  c.quadraticCurveTo(x, y + h, x, y + h - r);
  c.lineTo(x, y + r);
  c.quadraticCurveTo(x, y, x + r, y);
  c.closePath();
}

function drawUI() {
  const badge = badgeAt(badgeIdx);

  // Score
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.font = 'bold 24px sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText(String(score), 14, 44);

  // Best
  ctx.font = '11px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.fillText('BEST ' + bestScore, 14, 72);

  // Multiplier
  if (multiplier > 1) {
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    const fs = Math.round(18 * uiPopScale);
    ctx.font = 'bold ' + fs + 'px sans-serif';
    ctx.fillStyle = hsl(50, 90, 65);
    ctx.fillText('x' + multiplier, W - 14, 50);
  }

  // Streak
  if (streakPerfect > 0) {
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    const fs = Math.round(12 * uiPopScale);
    ctx.font = 'bold ' + fs + 'px sans-serif';
    ctx.fillStyle = hsl(40, 85, 68, 0.9);
    ctx.fillText(streakPerfect + ' PERFECT', W - 14, 65);
  }

  // Sync meter
  const barW = 80, barH = 6;
  const barX = W - 14 - barW, barY = 84;
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  roundRect(ctx, barX, barY, barW, barH, 3);
  ctx.fill();

  const fillW = syncMeter * barW;
  if (fillW > 1) {
    const wobble = syncMeter > 0.1 ? Math.sin(elapsedTime * 6) * 0.8 : 0;
    const mg = ctx.createLinearGradient(barX, 0, barX + fillW, 0);
    mg.addColorStop(0, hsl(180, 80, 55));
    mg.addColorStop(1, hsl(280, 80, 60));
    ctx.fillStyle = mg;
    roundRect(ctx, barX, barY + wobble * 0.3, fillW, barH, 3);
    ctx.fill();
  }

  ctx.font = '9px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  ctx.fillText('SYNC', barX - 4, barY + barH / 2);

  // Overdrive indicator
  if (overdrive > 0) {
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = 'bold 14px sans-serif';
    const pulse = 0.7 + 0.3 * Math.sin(elapsedTime * 10);
    ctx.globalAlpha = pulse;
    const oh = (elapsedTime * 150) % 360;
    ctx.fillStyle = hsl(oh, 90, 70);
    ctx.fillText('OVERDRIVE', W / 2, 44);
    ctx.font = '10px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText(overdriveTTL.toFixed(1) + 's', W / 2, 60);
    ctx.globalAlpha = 1;
  }

  // Current badge indicator at bottom
  ctx.globalAlpha = 0.65;
  const biX = W / 2, biY = H - 22;
  drawShape(biX - 14, biY, badge.shape, 7, hsl(badge.hue, 65, 52));
  ctx.font = '9px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  ctx.fillText('BADGE', biX, biY);
  ctx.globalAlpha = 1;
}

function drawStartScreen() {
  const t = Date.now() * 0.001;

  // Title
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const pulse = 1 + 0.03 * Math.sin(t * 3);
  const fs = Math.round(38 * pulse);
  ctx.font = 'bold ' + fs + 'px sans-serif';

  const tg = ctx.createLinearGradient(W / 2 - 110, 0, W / 2 + 110, 0);
  tg.addColorStop(0, hsl(200, 80, 65));
  tg.addColorStop(0.5, hsl(330, 80, 65));
  tg.addColorStop(1, hsl(120, 80, 65));
  ctx.fillStyle = tg;
  ctx.fillText('COLOR DASH', W / 2, H * 0.20);

  ctx.font = '13px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.fillText('Dash Sync Edition', W / 2, H * 0.20 + 34);

  // Animated shapes
  for (let i = 0; i < 3; i++) {
    const sx = W / 2 + (i - 1) * 52;
    const sy = H * 0.36 + Math.sin(t * 1.5 + i * 2.1) * 10;
    const b = BADGE_CYCLE[i];
    drawShape(sx, sy, b.shape, 18, hsl(b.hue, 70, 55, 0.8));
  }

  // Instructions
  ctx.font = '13px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  const lines = [
    'Tap to shift lane + cycle badge',
    'Match color & shape to pass gates',
    'Perfect timing = bonus points!',
    'Fill Sync Meter for Overdrive'
  ];
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], W / 2, H * 0.48 + i * 24);
  }

  // Best score
  const best = loadBest();
  if (best > 0) {
    ctx.font = 'bold 16px sans-serif';
    ctx.fillStyle = hsl(50, 80, 65);
    ctx.fillText('BEST: ' + best, W / 2, H * 0.67);
  }

  // Tap to start
  const tapPulse = 0.5 + 0.5 * Math.sin(t * 4);
  ctx.globalAlpha = 0.5 + tapPulse * 0.5;
  ctx.font = 'bold 20px sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText('TAP TO START', W / 2, H * 0.80);
  ctx.globalAlpha = 1;

  ctx.font = '11px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fillText('or press Space / Enter', W / 2, H * 0.80 + 26);
}

function drawGameOverScreen() {
  // Dark overlay
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.font = 'bold 32px sans-serif';
  ctx.fillStyle = hsl(0, 65, 58);
  ctx.fillText('GAME OVER', W / 2, H * 0.30);

  ctx.font = '14px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('SCORE', W / 2, H * 0.40);

  ctx.font = 'bold 48px sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText(String(score), W / 2, H * 0.46);

  ctx.font = 'bold 18px sans-serif';
  ctx.fillStyle = hsl(50, 80, 65);
  ctx.fillText('BEST: ' + bestScore, W / 2, H * 0.56);

  if (score === bestScore && score > 0) {
    ctx.font = 'bold 14px sans-serif';
    ctx.fillStyle = hsl(50, 90, 72);
    const np = 0.7 + 0.3 * Math.sin(Date.now() * 0.006);
    ctx.globalAlpha = np;
    ctx.fillText('NEW BEST!', W / 2, H * 0.56 + 24);
    ctx.globalAlpha = 1;
  }

  if (gameOverLock <= 0) {
    const tapPulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.004);
    ctx.globalAlpha = 0.5 + tapPulse * 0.5;
    ctx.font = 'bold 17px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText('TAP TO RETRY', W / 2, H * 0.72);
    ctx.globalAlpha = 1;
  }
}

// --- Main draw ---
function draw() {
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.clearRect(0, 0, W, H);

  ctx.save();
  ctx.translate(screenShakeX, screenShakeY);

  // Background gradient
  const bh = (220 + bgHueShift * 0.3) % 360;
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, hsl(bh, 28, 7));
  bg.addColorStop(0.5, hsl(bh + 20, 32, 11));
  bg.addColorStop(1, hsl(bh + 40, 36, 15));
  ctx.fillStyle = bg;
  ctx.fillRect(-10, -10, W + 20, H + 20);

  if (state === 'start') {
    drawStartScreen();
    ctx.restore();
    return;
  }

  // Track, gates, player, effects, UI
  drawTrack();
  drawTelegraph();
  drawGates();
  drawPlayer();
  drawParticles();
  drawSparks();
  drawUI();

  // Overdrive color overlay
  if (overdrive > 0) {
    const a = 0.06 + 0.04 * Math.sin(elapsedTime * 8);
    ctx.globalAlpha = a;
    const oh = (elapsedTime * 120) % 360;
    ctx.fillStyle = hsl(oh, 80, 60);
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
  }

  // Game over overlay
  if (state === 'gameover') {
    drawGameOverScreen();
  }

  // Flash effect
  if (flashAlpha > 0) {
    ctx.globalAlpha = clamp(flashAlpha, 0, 1);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

// --- Main Loop ---
let lastTime = 0;

function loop(ts) {
  requestAnimationFrame(loop);

  const rawDt = (ts - lastTime) / 1000;
  lastTime = ts;
  const dt = Math.min(rawDt, 0.05);

  // Update game-over timers even when not playing
  if (state === 'gameover') {
    gameOverLock -= dt;
    if (flashAlpha > 0) flashAlpha -= dt * 2;
    updateParticles(dt);
    updateSparks(dt);
    updateShake(dt);
  }

  update(dt);
  draw();
}

// --- Boot ---
init();
bestScore = loadBest();
requestAnimationFrame(function(ts) {
  lastTime = ts;
  loop(ts);
});

})();
</script>
</body>
</html>
