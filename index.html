<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="theme-color" content="#1a1a2e">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og.png">
<link rel="canonical" href="https://balinti.github.io/color-dash/">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow-x:hidden;background:#0a0a1a;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#fff;touch-action:manipulation;-webkit-tap-highlight-color:transparent;user-select:none}
body{display:flex;flex-direction:column;align-items:center;min-height:100svh;background:linear-gradient(170deg,#0a0a1a 0%,#16213e 40%,#0f3460 100%)}
#game-container{position:relative;width:100%;max-width:420px;height:100svh;max-height:750px;overflow:hidden;margin:0 auto}
canvas{display:block;width:100%;height:100%;position:absolute;top:0;left:0}
#hud{position:absolute;top:0;left:0;right:0;padding:12px 16px;display:flex;justify-content:space-between;align-items:center;pointer-events:none;z-index:10}
#score-display{font-size:28px;font-weight:800;text-shadow:0 2px 8px rgba(0,0,0,0.5);letter-spacing:1px}
#multiplier{font-size:14px;font-weight:700;color:#ffd700;margin-left:6px;opacity:0;transition:opacity 0.2s}
#hearts{font-size:22px;letter-spacing:2px;text-shadow:0 2px 8px rgba(0,0,0,0.5)}
#combo-display{position:absolute;top:48px;left:16px;font-size:13px;font-weight:600;color:#aaa;pointer-events:none;z-index:10;opacity:0;transition:opacity 0.3s}
#center-overlay{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:none;z-index:20}
#overlay-title{font-size:42px;font-weight:900;letter-spacing:3px;text-shadow:0 4px 20px rgba(0,0,0,0.6);margin-bottom:8px}
#overlay-subtitle{font-size:16px;font-weight:400;color:#bbb;margin-bottom:24px}
#overlay-prompt{font-size:18px;font-weight:600;color:#fff;opacity:0.8;animation:pulse 1.5s ease-in-out infinite}
#challenge-banner{font-size:15px;font-weight:700;color:#ffd700;margin-bottom:12px;display:none;text-shadow:0 2px 8px rgba(255,215,0,0.3)}
#gameover-stats{text-align:center;margin-bottom:16px;display:none}
#gameover-stats div{font-size:14px;color:#aaa;margin:4px 0}
#gameover-stats span{color:#fff;font-weight:700}
#share-section{display:none;flex-direction:column;gap:8px;align-items:center;margin-top:12px;pointer-events:auto}
#share-section button{padding:10px 24px;border:none;border-radius:24px;font-size:14px;font-weight:700;cursor:pointer;transition:transform 0.15s,opacity 0.15s}
#share-section button:active{transform:scale(0.95)}
#btn-share{background:linear-gradient(135deg,#667eea,#764ba2);color:#fff}
#btn-challenge{background:linear-gradient(135deg,#f093fb,#f5576c);color:#fff}
#perfect-text{position:absolute;font-size:22px;font-weight:900;color:#ffd700;text-shadow:0 0 12px rgba(255,215,0,0.6);pointer-events:none;z-index:15;opacity:0}
@keyframes pulse{0%,100%{opacity:0.5}50%{opacity:1}}

.seo-content{max-width:420px;margin:20px auto;padding:20px 16px;color:#8899aa}
.seo-content h2{font-size:20px;color:#ccd;margin-bottom:10px}
.seo-content p{font-size:14px;line-height:1.6;margin-bottom:12px}
.seo-content ul{padding-left:20px;margin-bottom:12px}
.seo-content li{font-size:13px;line-height:1.5;margin-bottom:4px}
</style>
</head>
<body>
<div id="game-container">
  <canvas id="gc"></canvas>
  <div id="hud">
    <div><span id="score-display">0</span><span id="multiplier">x1</span></div>
    <div id="hearts">&#10084;&#10084;&#10084;</div>
  </div>
  <div id="combo-display">COMBO <span id="combo-val">0</span></div>
  <div id="center-overlay">
    <div id="challenge-banner"></div>
    <div id="overlay-title">COLOR DASH</div>
    <div id="overlay-subtitle">Split Decision</div>
    <div id="gameover-stats">
      <div>Score: <span id="stat-score">0</span></div>
      <div>Best: <span id="stat-best">0</span></div>
      <div>Perfects: <span id="stat-perfects">0</span></div>
      <div>Max Combo: <span id="stat-maxcombo">0</span></div>
    </div>
    <div id="overlay-prompt">Tap to Start</div>
    <div id="share-section">
      <button id="btn-share">Share Score</button>
      <button id="btn-challenge">Challenge a Friend</button>
    </div>
  </div>
  <div id="perfect-text">PERFECT</div>
</div>

<section class="seo-content">
  <h2>How to Play Color Dash</h2>
  <p>Color Dash: Split Decision is a free hyper-casual HTML5 game that tests your reflexes and timing. Your runner automatically cycles through three colors &mdash; each with a unique shape for colorblind accessibility. Tap or press Space to switch lanes and match the incoming gate&rsquo;s color.</p>
  <h2>Game Features</h2>
  <ul>
    <li>Simple one-tap controls &mdash; switch between left and right lanes</li>
    <li>Auto-cycling colors with icon shapes (circle, square, triangle)</li>
    <li>Combo system with score multiplier up to x4</li>
    <li>Perfect hits through center boost strips for bonus points</li>
    <li>Increasing difficulty with faster speeds and complex patterns</li>
    <li>3-heart health system &mdash; survive mistakes and keep going</li>
    <li>High score saved locally &mdash; challenge yourself to beat your best</li>
    <li>Share scores and challenge friends with a link</li>
  </ul>
  <h2>Tips for High Scores</h2>
  <p>Watch the color ring around your runner to anticipate which lane to be in. Aim for the center boost strip when passing through correct gates to build your combo multiplier. Plan ahead by watching the next gate&rsquo;s colors. The game speeds up over time, so stay focused and react quickly!</p>
</section>

<script>
'use strict';
(() => {

// === DOM refs ===
const canvas = document.getElementById('gc');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');
const scoreDisplay = document.getElementById('score-display');
const multiplierDisplay = document.getElementById('multiplier');
const heartsDisplay = document.getElementById('hearts');
const comboDisplay = document.getElementById('combo-display');
const comboVal = document.getElementById('combo-val');
const centerOverlay = document.getElementById('center-overlay');
const overlayTitle = document.getElementById('overlay-title');
const overlaySub = document.getElementById('overlay-subtitle');
const overlayPrompt = document.getElementById('overlay-prompt');
const challengeBanner = document.getElementById('challenge-banner');
const gameoverStats = document.getElementById('gameover-stats');
const shareSection = document.getElementById('share-section');
const btnShare = document.getElementById('btn-share');
const btnChallenge = document.getElementById('btn-challenge');
const perfectTextEl = document.getElementById('perfect-text');

const statScore = document.getElementById('stat-score');
const statBest = document.getElementById('stat-best');
const statPerfects = document.getElementById('stat-perfects');
const statMaxCombo = document.getElementById('stat-maxcombo');

// === Constants ===
const TEAMS = [
  { h: 0,   s: 75, l: 55, icon: 'circle',   label: '\u25CF' },
  { h: 130, s: 65, l: 45, icon: 'square',   label: '\u25A0' },
  { h: 220, s: 75, l: 55, icon: 'triangle', label: '\u25B2' },
];
const LS_KEY = 'colorDash_splitDecision_best';
const HEART_FULL = '\u2764';
const HEART_EMPTY = '\u2661';
const MAX_MULT = 4;
const COMBO_FOR_MULT = [0, 3, 8, 15];
const COLOR_CYCLE_BASE = 0.7;
const BASE_SPEED = 2.8;
const GATE_SPACING_BASE = 240;
const PERFECT_STRIP_FRAC = 0.14;

// === Game state ===
let W, H, dpr;
let state = 'start';
let score, bestScore, hp, combo, maxCombo, perfects, multiplier;
let lane;
let laneX, targetLaneX, laneSwapT;
let playerY;
let playerColor;
let colorTimer, colorCycleSpeed;
let speed;
let gates, particles, trailParticles;
let shakeX, shakeY, shakeDur, shakeIntensity;
let invulnTimer;
let slowmoTimer, slowmoFactor;
let perfectAnim;
let distanceTraveled;
let lastTime;
let vignetteAlpha;
let challengeScore = null;
let nextGateId;
let startAnimTime = 0;

// === Resize ===
function resize() {
  const rect = container.getBoundingClientRect();
  dpr = Math.min(window.devicePixelRatio || 1, 2.5);
  W = rect.width;
  H = rect.height;
  canvas.width = Math.round(W * dpr);
  canvas.height = Math.round(H * dpr);
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  playerY = H * 0.75;
}
window.addEventListener('resize', resize);
resize();

// === Helpers ===
function hsl(team, a) {
  const t = TEAMS[team];
  if (a !== undefined) return 'hsla(' + t.h + ',' + t.s + '%,' + t.l + '%,' + a + ')';
  return 'hsl(' + t.h + ',' + t.s + '%,' + t.l + '%)';
}
function hslBright(team) {
  const t = TEAMS[team];
  return 'hsl(' + t.h + ',' + t.s + '%,' + Math.min(t.l + 20, 85) + '%)';
}
function hslDark(team) {
  const t = TEAMS[team];
  return 'hsl(' + t.h + ',' + t.s + '%,' + Math.max(t.l - 15, 10) + '%)';
}
function laneCenter(l) { return W * (l === 0 ? 0.27 : 0.73); }
function getLaneWidth() { return W * 0.40; }
function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function easeOutBack(t) {
  const c1 = 1.70158, c3 = c1 + 1;
  return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
}
function easeOutQuad(t) { return 1 - (1 - t) * (1 - t); }
function rand(a, b) { return a + Math.random() * (b - a); }
function randInt(a, b) { return Math.floor(rand(a, b + 1)); }

// === Draw icon ===
function drawIcon(cx, cy, r, team, alpha) {
  ctx.globalAlpha = alpha !== undefined ? alpha : 1;
  const icon = TEAMS[team].icon;
  ctx.fillStyle = '#fff';
  if (icon === 'circle') {
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fill();
  } else if (icon === 'square') {
    const s = r * 1.6;
    ctx.fillRect(cx - s / 2, cy - s / 2, s, s);
  } else {
    ctx.beginPath();
    ctx.moveTo(cx, cy - r * 1.1);
    ctx.lineTo(cx + r, cy + r * 0.7);
    ctx.lineTo(cx - r, cy + r * 0.7);
    ctx.closePath();
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// === Particles ===
function spawnParticles(x, y, color, count, spd, life) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const v = rand(1, spd);
    particles.push({
      x, y,
      vx: Math.cos(angle) * v,
      vy: Math.sin(angle) * v - rand(0.5, 2),
      life: rand(life * 0.5, life),
      maxLife: life,
      color,
      r: rand(2, 5),
    });
  }
}

function spawnTrail(x, y, color) {
  trailParticles.push({
    x, y, life: 0.35, maxLife: 0.35, color, r: rand(3, 7),
  });
}

// === Gate generation ===
function createGate(y) {
  let leftTeam = randInt(0, 2);
  let rightTeam;
  do { rightTeam = randInt(0, 2); } while (rightTeam === leftTeam);
  return {
    id: nextGateId++,
    y,
    leftTeam,
    rightTeam,
    passed: false,
    squash: 0,
    height: 54,
  };
}

function refillGates() {
  const topBound = -H;
  let topY = gates.length > 0 ? gates[gates.length - 1].y : playerY - 200;

  const spacing = Math.max(GATE_SPACING_BASE - distanceTraveled * 0.015, 130);

  while (topY > topBound) {
    topY -= spacing;
    gates.push(createGate(topY));
  }
}

// === Shake ===
function triggerShake(intensity, duration) {
  shakeIntensity = Math.max(shakeIntensity, intensity);
  shakeDur = Math.max(shakeDur, duration);
}

// === Perfect anim ===
function showPerfect(x, y) {
  perfectAnim = { x, y, t: 0, dur: 0.9 };
}

// === Init ===
function initGame() {
  score = 0;
  hp = 3;
  combo = 0;
  maxCombo = 0;
  perfects = 0;
  multiplier = 1;
  lane = 0;
  laneX = laneCenter(0);
  targetLaneX = laneX;
  laneSwapT = 1;
  playerColor = 0;
  colorTimer = 0;
  colorCycleSpeed = COLOR_CYCLE_BASE;
  speed = BASE_SPEED;
  gates = [];
  particles = [];
  trailParticles = [];
  shakeX = 0; shakeY = 0; shakeDur = 0; shakeIntensity = 0;
  invulnTimer = 0;
  slowmoTimer = 0;
  slowmoFactor = 1;
  perfectAnim = null;
  distanceTraveled = 0;
  vignetteAlpha = 0;
  nextGateId = 0;
  refillGates();
  updateHUD();
}

// === HUD ===
function updateHUD() {
  scoreDisplay.textContent = score;
  multiplierDisplay.textContent = 'x' + multiplier;
  multiplierDisplay.style.opacity = multiplier > 1 ? '1' : '0';

  let h = '';
  for (let i = 0; i < 3; i++) h += i < hp ? HEART_FULL : HEART_EMPTY;
  heartsDisplay.textContent = h;

  if (combo > 1) {
    comboDisplay.style.opacity = '1';
    comboVal.textContent = combo;
  } else {
    comboDisplay.style.opacity = '0';
  }
}

function updateMultiplier() {
  let m = 1;
  for (let i = COMBO_FOR_MULT.length - 1; i >= 0; i--) {
    if (combo >= COMBO_FOR_MULT[i]) { m = i + 1; break; }
  }
  multiplier = Math.min(m, MAX_MULT);
}

// === State ===
function setState(s) {
  state = s;
  if (s === 'start') {
    centerOverlay.style.display = 'flex';
    overlayTitle.textContent = 'COLOR DASH';
    overlaySub.textContent = 'Split Decision';
    overlayPrompt.textContent = 'Tap to Start';
    overlayPrompt.style.display = 'block';
    gameoverStats.style.display = 'none';
    shareSection.style.display = 'none';

    const params = new URLSearchParams(window.location.search);
    const ch = params.get('challenge');
    if (ch && !isNaN(parseInt(ch))) {
      challengeScore = parseInt(ch);
      challengeBanner.textContent = '\uD83C\uDFAF Beat ' + challengeScore + ' points!';
      challengeBanner.style.display = 'block';
    } else {
      challengeBanner.style.display = 'none';
    }
  } else if (s === 'playing') {
    centerOverlay.style.display = 'none';
    perfectTextEl.style.opacity = '0';
    initGame();
  } else if (s === 'gameover') {
    bestScore = Math.max(score, bestScore);
    try { localStorage.setItem(LS_KEY, String(bestScore)); } catch(e) {}

    centerOverlay.style.display = 'flex';
    overlayTitle.textContent = 'GAME OVER';
    overlaySub.textContent = '';
    overlayPrompt.textContent = 'Tap to Retry';
    overlayPrompt.style.display = 'block';

    statScore.textContent = score;
    statBest.textContent = bestScore;
    statPerfects.textContent = perfects;
    statMaxCombo.textContent = maxCombo;
    gameoverStats.style.display = 'block';
    shareSection.style.display = 'flex';

    triggerShake(10, 0.5);
    spawnParticles(laneX, playerY, hsl(playerColor), 35, 7, 1.2);
  }
}

// === Input ===
function handleInput(e) {
  if (e) e.preventDefault();
  if (state === 'start') {
    setState('playing');
  } else if (state === 'playing') {
    lane = lane === 0 ? 1 : 0;
    targetLaneX = laneCenter(lane);
    laneSwapT = 0;
  } else if (state === 'gameover') {
    setState('playing');
  }
}

container.addEventListener('pointerdown', handleInput);
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') handleInput(e);
});

// === Share ===
btnShare.addEventListener('pointerdown', (e) => {
  e.stopPropagation();
  const text = 'I scored ' + score + ' in Color Dash! Can you beat me?\n' +
    window.location.origin + window.location.pathname + '?challenge=' + score;
  if (navigator.share) {
    navigator.share({ title: 'Color Dash', text }).catch(() => {});
  } else {
    navigator.clipboard.writeText(text).then(() => {
      btnShare.textContent = 'Copied!';
      setTimeout(() => { btnShare.textContent = 'Share Score'; }, 1500);
    }).catch(() => {});
  }
});

btnChallenge.addEventListener('pointerdown', (e) => {
  e.stopPropagation();
  const url = window.location.origin + window.location.pathname + '?challenge=' + score;
  if (navigator.share) {
    navigator.share({ title: 'Beat my Color Dash score!', text: 'Can you beat ' + score + ' points?', url }).catch(() => {});
  } else {
    navigator.clipboard.writeText(url).then(() => {
      btnChallenge.textContent = 'Link Copied!';
      setTimeout(() => { btnChallenge.textContent = 'Challenge a Friend'; }, 1500);
    }).catch(() => {});
  }
});

// === Damage ===
function takeDamage() {
  if (invulnTimer > 0) return;
  hp--;
  combo = 0;
  multiplier = 1;
  invulnTimer = 1.5;
  vignetteAlpha = 0.6;
  triggerShake(5, 0.3);
  spawnParticles(laneX, playerY, '#ff4444', 18, 5, 0.7);
  updateHUD();
  if (hp <= 0) setState('gameover');
}

// === Gate check ===
function checkGatePass(gate) {
  if (gate.passed) return;
  const gTop = gate.y;
  const gBot = gate.y + gate.height;
  const pTop = playerY - 14;
  const pBot = playerY + 14;

  if (gBot >= pTop && gTop <= pBot) {
    gate.passed = true;
    const myTeam = lane === 0 ? gate.leftTeam : gate.rightTeam;

    if (myTeam === playerColor) {
      // Check perfect
      const lc = laneCenter(lane);
      const lw = getLaneWidth();
      const stripHalf = lw * PERFECT_STRIP_FRAC / 2;
      const isPerfect = Math.abs(laneX - lc) < stripHalf;

      combo++;
      if (combo > maxCombo) maxCombo = combo;
      updateMultiplier();

      let pts = multiplier;
      if (isPerfect) {
        pts += 2;
        perfects++;
        slowmoTimer = 0.18;
        slowmoFactor = 0.25;
        showPerfect(laneX, playerY - 45);
        triggerShake(2.5, 0.12);
        spawnParticles(laneX, playerY, '#ffd700', 14, 5, 0.8);
      }

      score += pts;
      gate.squash = 1;
      spawnParticles(laneX, playerY - 5, hsl(playerColor), 10, 3.5, 0.5);

      // Difficulty ramp every 10 points
      speed = BASE_SPEED + Math.floor(score / 10) * 0.35;
      speed = Math.min(speed, 10);
      colorCycleSpeed = Math.max(COLOR_CYCLE_BASE - Math.floor(score / 10) * 0.04, 0.32);
    } else {
      takeDamage();
    }
    updateHUD();
  }
}

// === Update ===
function update(dt) {
  if (state !== 'playing') {
    startAnimTime += dt;
    // Idle particles on start screen
    if (state === 'start' && Math.random() < 0.05) {
      const sx = rand(20, W - 20);
      const sy = rand(H * 0.3, H * 0.5);
      spawnParticles(sx, sy, hsl(randInt(0, 2), 0.4), 2, 1.5, 0.8);
    }
    // Update particles even when not playing
    updateParticles(dt);
    return;
  }

  // Slowmo
  let effDt = dt;
  if (slowmoTimer > 0) {
    slowmoTimer -= dt;
    effDt = dt * slowmoFactor;
  }

  // Color cycling
  colorTimer += effDt;
  if (colorTimer >= colorCycleSpeed) {
    colorTimer -= colorCycleSpeed;
    playerColor = (playerColor + 1) % 3;
  }

  // Lane easing
  if (laneSwapT < 1) {
    laneSwapT = Math.min(laneSwapT + effDt * 8, 1);
  }
  const easedT = easeOutBack(clamp(laneSwapT, 0, 1));
  laneX = lerp(laneX, targetLaneX, easedT * 0.35);
  if (Math.abs(laneX - targetLaneX) < 0.3) laneX = targetLaneX;

  // Move gates
  const moveAmt = speed * 60 * effDt;
  distanceTraveled += moveAmt;

  for (let i = gates.length - 1; i >= 0; i--) {
    const g = gates[i];
    g.y += moveAmt;
    if (g.squash > 0) g.squash = Math.max(g.squash - effDt * 5, 0);
    checkGatePass(g);
    if (g.y > H + 120) gates.splice(i, 1);
  }

  refillGates();

  // Invuln
  if (invulnTimer > 0) invulnTimer -= dt;

  // Vignette
  if (vignetteAlpha > 0) vignetteAlpha = Math.max(vignetteAlpha - dt * 1.5, 0);

  // Shake
  if (shakeDur > 0) {
    shakeDur -= dt;
    shakeX = (Math.random() - 0.5) * shakeIntensity * 2;
    shakeY = (Math.random() - 0.5) * shakeIntensity * 2;
    shakeIntensity *= 0.9;
  } else {
    shakeX = 0; shakeY = 0;
  }

  // Trail
  if (Math.random() < 0.6) {
    spawnTrail(laneX + rand(-5, 5), playerY + 14, hsl(playerColor, 0.25));
  }

  updateParticles(dt);

  // Perfect text
  if (perfectAnim) {
    perfectAnim.t += dt;
    if (perfectAnim.t >= perfectAnim.dur) {
      perfectAnim = null;
      perfectTextEl.style.opacity = '0';
    } else {
      const prog = perfectAnim.t / perfectAnim.dur;
      perfectTextEl.style.left = (perfectAnim.x - 44) + 'px';
      perfectTextEl.style.top = (perfectAnim.y - prog * 55) + 'px';
      perfectTextEl.style.opacity = String(Math.max(1 - prog * 1.3, 0));
      perfectTextEl.style.transform = 'scale(' + (1 + prog * 0.3) + ')';
    }
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 2.5 * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
  for (let i = trailParticles.length - 1; i >= 0; i--) {
    const p = trailParticles[i];
    p.life -= dt;
    if (p.life <= 0) trailParticles.splice(i, 1);
  }
}

// === Render ===
function render() {
  ctx.save();
  ctx.translate(shakeX, shakeY);

  // Background
  const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
  bgGrad.addColorStop(0, '#080818');
  bgGrad.addColorStop(0.5, '#0e0e2a');
  bgGrad.addColorStop(1, '#080818');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(-20, -20, W + 40, H + 40);

  // Lane backgrounds
  for (let l = 0; l < 2; l++) {
    const lc = laneCenter(l);
    const lw = getLaneWidth();
    ctx.fillStyle = 'rgba(255,255,255,0.015)';
    ctx.fillRect(lc - lw / 2, 0, lw, H);
  }

  // Center divider
  ctx.strokeStyle = 'rgba(255,255,255,0.07)';
  ctx.lineWidth = 2;
  ctx.setLineDash([10, 14]);
  ctx.beginPath();
  ctx.moveTo(W / 2, 0);
  ctx.lineTo(W / 2, H);
  ctx.stroke();
  ctx.setLineDash([]);

  // Road tick marks
  if (state === 'playing') {
    ctx.fillStyle = 'rgba(255,255,255,0.035)';
    const tickSpacing = 45;
    const offset = distanceTraveled % tickSpacing;
    for (let y = -tickSpacing + offset; y < H + tickSpacing; y += tickSpacing) {
      for (let l = 0; l < 2; l++) {
        const lc = laneCenter(l);
        ctx.fillRect(lc - 8, y, 16, 2);
      }
    }
  }

  // Trail particles
  for (const p of trailParticles) {
    const a = p.life / p.maxLife;
    ctx.globalAlpha = a * 0.35;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * a, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Gates
  for (const g of gates) {
    if (g.y > H + 60 || g.y + g.height < -60) continue;
    const gh = g.height;
    const squashScaleY = g.squash > 0 ? 1 - g.squash * 0.35 : 1;
    const squashScaleX = g.squash > 0 ? 1 + g.squash * 0.12 : 1;

    for (let l = 0; l < 2; l++) {
      const team = l === 0 ? g.leftTeam : g.rightTeam;
      const lc = laneCenter(l);
      const lw = getLaneWidth();

      ctx.save();
      ctx.translate(lc, g.y + gh / 2);
      ctx.scale(squashScaleX, squashScaleY);

      const halfW = lw / 2 - 6;
      const halfH = gh / 2 - 2;

      // Gate fill
      ctx.fillStyle = hsl(team, 0.18);
      ctx.beginPath();
      ctx.roundRect(-halfW, -halfH, halfW * 2, halfH * 2, 10);
      ctx.fill();

      // Gate border
      ctx.strokeStyle = hsl(team, 0.65);
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.roundRect(-halfW, -halfH, halfW * 2, halfH * 2, 10);
      ctx.stroke();

      // Perfect strip glow
      const stripW = lw * PERFECT_STRIP_FRAC;
      ctx.fillStyle = 'rgba(255,215,0,0.1)';
      ctx.fillRect(-stripW / 2, -halfH, stripW, halfH * 2);

      // Side color bars
      ctx.fillStyle = hsl(team, 0.55);
      ctx.fillRect(-halfW, -halfH, 5, halfH * 2);
      ctx.fillRect(halfW - 5, -halfH, 5, halfH * 2);

      // Icon
      drawIcon(0, 0, 10, team, 0.75);

      ctx.restore();
    }
  }

  // Particles
  for (const p of particles) {
    const a = p.life / p.maxLife;
    ctx.globalAlpha = a;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * a, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Player
  if (state === 'playing' || state === 'gameover') {
    const flash = invulnTimer > 0 && Math.sin(invulnTimer * 22) > 0;
    if (!flash) {
      const px = laneX;
      const py = playerY;

      // Outer ring - current color
      ctx.strokeStyle = hsl(playerColor);
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(px, py, 26, 0, Math.PI * 2);
      ctx.stroke();

      // Progress arc - next color preview
      const prog = colorTimer / colorCycleSpeed;
      const nextC = (playerColor + 1) % 3;
      ctx.strokeStyle = hsl(nextC, 0.45);
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(px, py, 26, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * prog);
      ctx.stroke();

      // Body glow
      ctx.shadowColor = hsl(playerColor);
      ctx.shadowBlur = 20;

      // Body gradient
      const grad = ctx.createRadialGradient(px, py - 2, 0, px, py, 16);
      grad.addColorStop(0, hslBright(playerColor));
      grad.addColorStop(1, hslDark(playerColor));
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(px, py, 15, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;

      // Icon
      drawIcon(px, py, 6, playerColor, 0.95);
    }
  }

  // Start screen runner preview
  if (state === 'start') {
    const t = startAnimTime;
    const previewY = H * 0.55;
    for (let i = 0; i < 3; i++) {
      const px = W * 0.22 + i * W * 0.28;
      const py = previewY + Math.sin(t * 2.5 + i * 2.1) * 8;
      const a = 0.35 + Math.sin(t * 1.5 + i) * 0.15;

      ctx.strokeStyle = hsl(i, a);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(px, py, 18, 0, Math.PI * 2);
      ctx.stroke();

      ctx.fillStyle = hsl(i, a);
      ctx.beginPath();
      ctx.arc(px, py, 12, 0, Math.PI * 2);
      ctx.fill();

      drawIcon(px, py, 5, i, a);
    }
  }

  // Vignette
  if (vignetteAlpha > 0.01) {
    const vGrad = ctx.createRadialGradient(W / 2, H / 2, W * 0.15, W / 2, H / 2, W * 0.9);
    vGrad.addColorStop(0, 'rgba(255,0,0,0)');
    vGrad.addColorStop(1, 'rgba(255,0,0,' + vignetteAlpha + ')');
    ctx.fillStyle = vGrad;
    ctx.fillRect(-20, -20, W + 40, H + 40);
  }

  ctx.restore();
}

// === Game Loop ===
function loop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  let dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  dt = Math.min(dt, 0.06);

  update(dt);
  render();
  requestAnimationFrame(loop);
}

// === Init ===
try { bestScore = parseInt(localStorage.getItem(LS_KEY)) || 0; } catch(e) { bestScore = 0; }

// Init arrays for start-screen particle rendering
particles = [];
trailParticles = [];
shakeX = 0; shakeY = 0; shakeDur = 0; shakeIntensity = 0;

setState('start');
requestAnimationFrame(loop);

})();
</script>
</body>
</html>