<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0a1a">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{
  width:100%;height:100%;
  overflow:hidden;
  background:#0a0a1a;
  font-family:system-ui,-apple-system,sans-serif;
  touch-action:none;
  overscroll-behavior:none;
  -webkit-tap-highlight-color:transparent;
  user-select:none;
  -webkit-user-select:none;
}
#app{
  width:100%;height:100%;
  display:flex;flex-direction:column;
  align-items:center;justify-content:center;
}
#shell{
  position:relative;
  width:100%;max-width:420px;
  height:100%;max-height:750px;
  overflow:hidden;
  border-radius:8px;
  background:#0a0a1a;
}
canvas#c{
  display:block;
  width:100%;height:100%;
}
#hud{
  position:absolute;top:0;left:0;right:0;
  display:flex;justify-content:space-between;
  padding:12px 16px;
  pointer-events:none;
  font-size:18px;font-weight:700;
  color:#fff;text-shadow:0 1px 4px rgba(0,0,0,.5);
  z-index:2;
}
#hud span{opacity:0;transition:opacity .2s}
#hud.visible span{opacity:1}
#overlay{
  position:absolute;top:0;left:0;right:0;bottom:0;
  display:flex;flex-direction:column;
  align-items:center;justify-content:center;
  z-index:3;pointer-events:none;
  opacity:0;transition:opacity .3s;
}
#overlay.visible{opacity:1;pointer-events:auto}
#overlay h1{
  font-size:42px;font-weight:900;
  background:linear-gradient(135deg,#ff6b6b,#ffd93d,#6bcb77,#4d96ff);
  -webkit-background-clip:text;-webkit-text-fill-color:transparent;
  background-clip:text;
  margin-bottom:8px;
}
#overlay .sub{
  color:rgba(255,255,255,.7);font-size:14px;margin-bottom:24px;
}
#overlay .score-display{
  color:#fff;font-size:28px;font-weight:700;margin-bottom:6px;
}
#overlay .best-display{
  color:rgba(255,255,255,.5);font-size:16px;margin-bottom:24px;
}
#overlay .tap-msg{
  color:rgba(255,255,255,.6);font-size:16px;
  animation:pulse 1.5s ease-in-out infinite;
}
@keyframes pulse{0%,100%{opacity:.4}50%{opacity:1}}
#content{
  display:none;
  max-width:420px;width:100%;
  padding:24px 16px;color:rgba(255,255,255,.55);
  font-size:13px;line-height:1.6;
}
#content h2{font-size:16px;color:rgba(255,255,255,.7);margin-bottom:8px}
#content p{margin-bottom:12px}
@media(min-height:800px){
  #content{display:block}
}
</style>
</head>
<body>
<div id="app">
  <div id="shell">
    <canvas id="c"></canvas>
    <div id="hud"><span id="hudScore">0</span><span id="hudStreak"></span></div>
    <div id="overlay" class="visible">
      <h1>Color Dash</h1>
      <div class="sub">Signal Split</div>
      <div class="tap-msg">Tap to Start</div>
    </div>
  </div>
</div>
<div id="content">
  <h2>How to Play</h2>
  <p>Tap or press Space to switch lanes. Your runner automatically matches the color of the gate in your current lane. Pass through gates to score points. Build streaks for multiplier bonuses!</p>
  <p>Watch for special gates: Boost gates (&#9733;) give a temporary score multiplier, while Crack gates (&#9888;) are risky but reward +3 points. Blocked lanes are telegraphed with a countdown &mdash; switch lanes before they close!</p>
  <p>Speed increases every 10 points. How far can you dash?</p>
  <h2>Accessibility</h2>
  <p>Color Dash uses distinct patterns and icons on each gate in addition to color, helping players who may have difficulty distinguishing colors.</p>
</div>

<script>
'use strict';

/* ===================================================================
   Color Dash — Signal Split
   Single-file HTML5 Canvas hyper-casual game
   =================================================================== */

// ==================== CONSTANTS ====================
const STORAGE_KEY   = 'colorDashBest';
const LEGACY_KEY    = 'signalSplitBest';
const LANE_COUNT    = 2;
const PLAYER_SIZE   = 22;
const GATE_HEIGHT   = 50;
const GATE_GAP_MIN  = 170;
const GATE_GAP_MAX  = 270;
const BASE_SPEED    = 2.6;
const SPEED_INC     = 0.2;
const SPEED_CAP     = 7.5;
const PERFECT_WIN   = 14;
const BOOST_BASE    = 0.12;
const CRACK_BASE    = 0.08;
const BLOCK_BASE    = 0.06;
const SHAKE_DUR     = 300;
const SHAKE_INT     = 8;
const P_PASS        = 12;
const P_PERF        = 24;
const P_CRACK       = 30;
const P_LIFE        = 40;

// Color palette (HSL)
const COLORS = [
  { h:   0, s: 75, l: 60 },
  { h:  45, s: 90, l: 55 },
  { h: 140, s: 60, l: 50 },
  { h: 210, s: 80, l: 60 },
  { h: 280, s: 70, l: 60 },
];

// Pattern types for accessibility
const PATTERNS = ['stripes', 'dots', 'crosshatch', 'diamonds', 'waves'];

// ==================== DOM REFS ====================
const canvas   = document.getElementById('c');
const ctx      = canvas.getContext('2d');
const shell    = document.getElementById('shell');
const hud      = document.getElementById('hud');
const hudScore = document.getElementById('hudScore');
const hudStrk  = document.getElementById('hudStreak');
const overlay  = document.getElementById('overlay');

// ==================== GAME STATE ====================
let W, H, dpr, laneW, laneX;
let state = 'start';
let score, best, streak, multi;
let speed, gateGap;
let pLane, pY, pVy, pSquash;
let gates, parts, floats;
let skT, skX, skY;
let boostT, boostM;
let blkLane, blkTimer, blkCount;
let hueShift, tColor;
let lastTs;

// ==================== HELPERS ====================
function hsl(h, s, l, a) {
  const hh = ((h + hueShift) % 360 + 360) % 360;
  return a != null ? `hsla(${hh},${s}%,${l}%,${a})` : `hsl(${hh},${s}%,${l}%)`;
}
function cStr(c, a) { return hsl(c.h, c.s, c.l, a); }
function rnd(a, b) { return a + Math.random() * (b - a); }
function rndI(a, b) { return Math.floor(rnd(a, b + 1)); }
function pick(a) { return a[rndI(0, a.length - 1)]; }
function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

function loadBest() {
  let b = parseInt(localStorage.getItem(STORAGE_KEY), 10);
  if (isNaN(b)) {
    b = parseInt(localStorage.getItem(LEGACY_KEY), 10);
    if (isNaN(b)) b = 0;
  }
  return b;
}
function saveBest(v) { localStorage.setItem(STORAGE_KEY, v); }

// ==================== RESIZE / DPR ====================
function resize() {
  const r = shell.getBoundingClientRect();
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = r.width;
  H = r.height;
  canvas.width  = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  laneW = W / LANE_COUNT;
  laneX = [laneW * 0.5, laneW * 1.5];
}
window.addEventListener('resize', resize);

// ==================== INIT ====================
function init() {
  score    = 0;
  streak   = 0;
  multi    = 1;
  speed    = BASE_SPEED;
  gateGap  = GATE_GAP_MAX;
  pLane    = 0;
  pY       = H * 0.78;
  pVy      = 0;
  pSquash  = 1;
  gates    = [];
  parts    = [];
  floats   = [];
  skT = skX = skY = 0;
  boostT   = 0;
  boostM   = 1;
  blkLane  = -1;
  blkTimer = 0;
  blkCount = 0;
  hueShift = 0;
  tColor   = null;
  best     = loadBest();

  // Pre-spawn two gate pairs so the first is visible quickly
  spawnPair(H * 0.25);
  spawnPair(H * 0.25 - gateGap);
  updateHUD();
}

// ==================== GATE SPAWNING ====================
function pickTwo() {
  const a = rndI(0, COLORS.length - 1);
  let b = a;
  while (b === a) b = rndI(0, COLORS.length - 1);
  return [a, b];
}

function spawnPair(yy) {
  const [i0, i1] = pickTwo();
  const y = yy !== undefined ? yy : -GATE_HEIGHT;

  let t0 = 'normal', t1 = 'normal';

  // Boost gate
  if (score > 5 && Math.random() < BOOST_BASE + score * 0.002) {
    if (rndI(0,1) === 0) t0 = 'boost'; else t1 = 'boost';
  }
  // Crack gate
  if (score > 10 && Math.random() < CRACK_BASE + score * 0.002) {
    const cl = rndI(0,1);
    if (cl === 0 && t0 === 'normal') t0 = 'crack';
    else if (t1 === 'normal') t1 = 'crack';
  }
  // Block mechanic
  if (score > 15 && blkLane === -1 && Math.random() < BLOCK_BASE + score * 0.001) {
    blkLane  = rndI(0,1);
    blkCount = 3;
    blkTimer = 0;
  }

  gates.push(
    { lane:0, y, c:COLORS[i0], ci:i0, pat:PATTERNS[i0 % PATTERNS.length], type:t0, passed:false, w:laneW*0.72 },
    { lane:1, y, c:COLORS[i1], ci:i1, pat:PATTERNS[i1 % PATTERNS.length], type:t1, passed:false, w:laneW*0.72 }
  );
}

// ==================== PARTICLES ====================
function emit(x, y, color, n) {
  for (let i = 0; i < n; i++) {
    const a = rnd(0, Math.PI*2), sp = rnd(1.2, 4.5);
    parts.push({
      x, y,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp - rnd(0.5, 2),
      life: P_LIFE, max: P_LIFE,
      c: color, sz: rnd(2, 5.5)
    });
  }
}

function emitText(x, y, txt, col) {
  floats.push({ x, y, txt, col, life: 55, max: 55 });
}

// ==================== SHAKE ====================
function shake(int, dur) {
  skT = dur || SHAKE_DUR;
  skX = int || SHAKE_INT;
  skY = int || SHAKE_INT;
}

// ==================== SWITCH LANE ====================
function switchLane() {
  if (state !== 'playing') return;
  pLane = pLane === 0 ? 1 : 0;
  pVy = -2.2;
  pSquash = 0.68;
}

// ==================== DIFFICULTY ====================
function updateDiff() {
  speed   = Math.min(BASE_SPEED + Math.floor(score / 10) * SPEED_INC, SPEED_CAP);
  gateGap = Math.max(GATE_GAP_MIN, GATE_GAP_MAX - score * 1.4);
}

// ==================== UPDATE ====================
function update() {
  if (state !== 'playing') return;

  hueShift = (hueShift + 0.12) % 360;
  updateDiff();

  // --- Move gates ---
  for (let i = gates.length - 1; i >= 0; i--) {
    const g = gates[i];
    g.y += speed;

    // Gate passes player
    if (!g.passed && g.y > pY + PLAYER_SIZE * 0.5) {
      g.passed = true;

      if (g.lane === pLane) {
        // Check block → game over
        if (blkLane === g.lane && blkCount <= 0) { gameOver(); return; }

        let pts = 1;
        const dist = Math.abs(g.y - pY);
        const perf = dist < PERFECT_WIN + GATE_HEIGHT * 0.5;

        if (g.type === 'crack') {
          pts = 3; streak += 3;
          emit(laneX[g.lane], pY, g.c, P_CRACK);
          emitText(laneX[g.lane], pY - 30, '+3 CRACK!', cStr(g.c));
          shake(5, 160);
        } else if (g.type === 'boost') {
          boostT = 180; boostM = 2;
          streak++;
          emit(laneX[g.lane], pY, g.c, P_PERF);
          emitText(laneX[g.lane], pY - 30, 'BOOST!', '#ffd93d');
          // Narrow upcoming gates
          for (const ng of gates) { if (ng.y < g.y) ng.w = laneW * 0.52; }
        } else {
          streak++;
          if (perf) {
            pts = 2;
            emit(laneX[g.lane], pY, g.c, P_PERF);
            emitText(laneX[g.lane], pY - 30, 'PERFECT!', '#fff');
            shake(2.5, 90);
          } else {
            emit(laneX[g.lane], pY, g.c, P_PASS);
          }
        }

        multi = 1 + Math.floor(streak / 5) * 0.5;
        const fin = Math.round(pts * multi * boostM);
        score += fin;
        if (fin > 1) emitText(laneX[g.lane], pY - 52, '+' + fin, 'rgba(255,255,255,.8)');
        pSquash = 1.3;
        updateHUD();
      }
    }

    // Remove off-screen
    if (g.y > H + GATE_HEIGHT) gates.splice(i, 1);
  }

  // --- Spawn ---
  let topY = Infinity;
  for (const g of gates) if (g.y < topY) topY = g.y;
  if (topY > gateGap - 30) spawnPair();

  // --- Block countdown ---
  if (blkLane >= 0) {
    blkTimer++;
    if (blkTimer > 55) {
      blkTimer = 0;
      blkCount--;
      if (blkCount < -2) blkLane = -1;
    }
  }

  // --- Boost decay ---
  if (boostT > 0) { boostT--; if (boostT <= 0) boostM = 1; }

  // --- Player physics ---
  pSquash = lerp(pSquash, 1, 0.14);
  pVy *= 0.84;

  // --- Particles ---
  for (let i = parts.length - 1; i >= 0; i--) {
    const p = parts[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.06;
    if (--p.life <= 0) parts.splice(i, 1);
  }

  // --- Floating texts ---
  for (let i = floats.length - 1; i >= 0; i--) {
    floats[i].y -= 0.8;
    if (--floats[i].life <= 0) floats.splice(i, 1);
  }

  // --- Shake decay ---
  if (skT > 0) {
    skT -= 16;
    const f = skT / SHAKE_DUR;
    skX = (Math.random() - 0.5) * SHAKE_INT * f;
    skY = (Math.random() - 0.5) * SHAKE_INT * f;
    if (skT <= 0) skX = skY = 0;
  }

  // --- Tether color ---
  tColor = null;
  let clo = Infinity;
  for (const g of gates) {
    if (g.lane === pLane && !g.passed && g.y < clo) { clo = g.y; tColor = g.c; }
  }
}

// ==================== GAME OVER ====================
function gameOver() {
  state = 'gameover';
  shake(SHAKE_INT, SHAKE_DUR);
  emit(laneX[pLane], pY, COLORS[0], 35);
  if (score > best) { best = score; saveBest(best); }

  overlay.innerHTML =
    '<h1>Color Dash</h1>' +
    '<div class="score-display">Score: ' + score + '</div>' +
    '<div class="best-display">Best: ' + best + '</div>' +
    '<div class="tap-msg">Tap to Retry</div>';
  overlay.classList.add('visible');
  hud.classList.remove('visible');
}

function updateHUD() {
  hudScore.textContent = score;
  hudStrk.textContent = streak >= 5 ? 'x' + multi.toFixed(1) : '';
}

// ==================== DRAWING ====================

// --- Background ---
function drawBg() {
  const gr = ctx.createLinearGradient(0, 0, 0, H);
  gr.addColorStop(0, '#0a0a1a');
  gr.addColorStop(0.5, '#0f1428');
  gr.addColorStop(1, '#0a0a1a');
  ctx.fillStyle = gr;
  ctx.fillRect(0, 0, W, H);

  // Lane divider
  ctx.strokeStyle = 'rgba(255,255,255,.06)';
  ctx.lineWidth = 1;
  ctx.setLineDash([8, 16]);
  ctx.beginPath();
  ctx.moveTo(W / 2, 0);
  ctx.lineTo(W / 2, H);
  ctx.stroke();
  ctx.setLineDash([]);
}

// --- Rounded rect helper ---
function rrect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// --- Pattern overlay ---
function drawPat(cx, cy, w, h, pat) {
  ctx.save();
  ctx.globalAlpha = 0.22;
  ctx.strokeStyle = '#fff';
  ctx.fillStyle = '#fff';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.rect(cx - w/2, cy - h/2, w, h);
  ctx.clip();

  const x0 = cx - w/2, y0 = cy - h/2;

  switch (pat) {
    case 'stripes':
      for (let i = -w; i < w*2; i += 8) {
        ctx.beginPath(); ctx.moveTo(x0+i, y0); ctx.lineTo(x0+i+h, y0+h); ctx.stroke();
      }
      break;
    case 'dots':
      for (let dx = 6; dx < w; dx += 12)
        for (let dy = 6; dy < h; dy += 12)
          { ctx.beginPath(); ctx.arc(x0+dx, y0+dy, 2, 0, Math.PI*2); ctx.fill(); }
      break;
    case 'crosshatch':
      for (let i = -w; i < w*2; i += 10) {
        ctx.beginPath(); ctx.moveTo(x0+i, y0); ctx.lineTo(x0+i+h, y0+h); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x0+i+h, y0); ctx.lineTo(x0+i, y0+h); ctx.stroke();
      }
      break;
    case 'diamonds':
      for (let dx = 8; dx < w; dx += 16)
        for (let dy = 8; dy < h; dy += 16) {
          ctx.beginPath();
          ctx.moveTo(x0+dx, y0+dy-5); ctx.lineTo(x0+dx+5, y0+dy);
          ctx.lineTo(x0+dx, y0+dy+5); ctx.lineTo(x0+dx-5, y0+dy);
          ctx.closePath(); ctx.stroke();
        }
      break;
    case 'waves':
      for (let dy = 6; dy < h; dy += 10) {
        ctx.beginPath();
        for (let dx = 0; dx < w; dx += 2) ctx.lineTo(x0+dx, y0+dy+Math.sin(dx*.3)*3);
        ctx.stroke();
      }
      break;
  }
  ctx.restore();
}

// --- Icon drawing ---
function drawIcon(x, y, type, sz) {
  ctx.save();
  ctx.fillStyle = '#fff';
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;

  if (type === 'boost') {
    // 5-point star
    const s = sz * 0.5;
    ctx.beginPath();
    for (let i = 0; i < 10; i++) {
      const a = (i * 36 - 90) * Math.PI / 180;
      const r = i % 2 === 0 ? s : s * 0.4;
      if (i === 0) ctx.moveTo(x + Math.cos(a)*r, y + Math.sin(a)*r);
      else ctx.lineTo(x + Math.cos(a)*r, y + Math.sin(a)*r);
    }
    ctx.closePath();
    ctx.fill();
  } else if (type === 'crack') {
    // Warning triangle with !
    const s = sz * 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - s);
    ctx.lineTo(x + s*0.9, y + s*0.7);
    ctx.lineTo(x - s*0.9, y + s*0.7);
    ctx.closePath();
    ctx.stroke();
    ctx.font = `bold ${s}px system-ui`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('!', x, y + 2);
  }
  ctx.restore();
}

// --- Gate ---
function drawGate(g) {
  const x = laneX[g.lane];
  const gw = g.w, gh = GATE_HEIGHT;
  const c = g.c;

  ctx.save();
  ctx.shadowColor = cStr(c, 0.4);
  ctx.shadowBlur = 14;

  // Body gradient
  const gr = ctx.createLinearGradient(x - gw/2, g.y, x + gw/2, g.y);
  gr.addColorStop(0, cStr(c, 0.15));
  gr.addColorStop(0.5, cStr(c, 0.32));
  gr.addColorStop(1, cStr(c, 0.15));
  ctx.fillStyle = gr;

  rrect(x - gw/2, g.y - gh/2, gw, gh, 6);
  ctx.fill();

  ctx.strokeStyle = cStr(c, 0.6);
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.restore();

  // Pattern
  drawPat(x, g.y, gw, gh, g.pat);

  // Special icon
  if (g.type !== 'normal') drawIcon(x, g.y, g.type, 20);

  // Block countdown ring
  if (blkLane === g.lane && blkCount > 0 && !g.passed) {
    ctx.save();
    ctx.strokeStyle = 'rgba(255,60,60,.6)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(x, g.y, gw/2+10, -Math.PI/2, -Math.PI/2 + Math.PI*2*(blkCount/3));
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,60,60,.8)';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(blkCount.toString(), x + gw/2+16, g.y);
    ctx.restore();
  }

  // Block overlay
  if (blkLane === g.lane && blkCount <= 0 && !g.passed) {
    ctx.save();
    ctx.fillStyle = 'rgba(255,30,30,.18)';
    ctx.fillRect(x - gw/2, g.y - gh/2, gw, gh);
    ctx.strokeStyle = 'rgba(255,60,60,.65)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x-10, g.y-10); ctx.lineTo(x+10, g.y+10);
    ctx.moveTo(x+10, g.y-10); ctx.lineTo(x-10, g.y+10);
    ctx.stroke();
    ctx.restore();
  }
}

// --- Player ---
function drawPlayer() {
  const x = laneX[pLane], y = pY + pVy, sz = PLAYER_SIZE;

  ctx.save();
  ctx.translate(x, y);
  ctx.scale(2 - pSquash, pSquash);

  // Tether shadow/glow
  if (tColor) { ctx.shadowColor = cStr(tColor, 0.7); ctx.shadowBlur = 22; }

  // Body
  const pc = tColor || COLORS[0];
  const rg = ctx.createRadialGradient(0, 0, 0, 0, 0, sz);
  rg.addColorStop(0, cStr(pc, 1));
  rg.addColorStop(1, cStr(pc, 0.55));
  ctx.fillStyle = rg;

  rrect(-sz/2, -sz/2, sz, sz, 5);
  ctx.fill();

  // Highlight
  ctx.fillStyle = 'rgba(255,255,255,.28)';
  ctx.beginPath();
  ctx.arc(0, -3, sz*0.22, 0, Math.PI*2);
  ctx.fill();

  ctx.restore();

  // Tether line
  if (tColor && state === 'playing') {
    let ty = 0, found = false;
    for (const g of gates) {
      if (g.lane === pLane && !g.passed) { ty = g.y; found = true; break; }
    }
    if (found && ty < y) {
      ctx.save();
      ctx.strokeStyle = cStr(tColor, 0.13);
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 8]);
      ctx.beginPath();
      ctx.moveTo(x, y - sz/2);
      ctx.lineTo(x, ty + GATE_HEIGHT/2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }
  }

  // Boost aura
  if (boostT > 0) {
    const pu = 1 + Math.sin(Date.now()*0.01)*0.2;
    ctx.save();
    ctx.strokeStyle = `rgba(255,217,61,${0.3*(boostT/180)})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, pY + pVy, sz*pu, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }
}

// --- Particles ---
function drawParts() {
  for (const p of parts) {
    const a = p.life / p.max;
    ctx.globalAlpha = a;
    ctx.fillStyle = typeof p.c === 'string' ? p.c : cStr(p.c, a);
    ctx.fillRect(p.x - p.sz/2, p.y - p.sz/2, p.sz, p.sz);
  }
  ctx.globalAlpha = 1;
}

// --- Floating texts ---
function drawFloats() {
  for (const f of floats) {
    ctx.save();
    ctx.globalAlpha = f.life / f.max;
    ctx.fillStyle = f.col;
    ctx.font = 'bold 14px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(f.txt, f.x, f.y);
    ctx.restore();
  }
}

// --- Block warning ---
function drawBlockWarn() {
  if (blkLane >= 0 && blkCount <= 0) {
    const bx = blkLane === 0 ? 0 : W/2;
    const fl = 0.04 + Math.sin(Date.now()*0.008)*0.03;
    ctx.fillStyle = `rgba(255,30,30,${fl})`;
    ctx.fillRect(bx, 0, W/2, H);
  }
}

// ==================== RENDER ====================
function render() {
  ctx.save();
  ctx.translate(skX, skY);

  drawBg();
  drawBlockWarn();

  // Gates (render order: back to front)
  for (const g of gates) drawGate(g);

  // Player
  if (state === 'playing') drawPlayer();

  // Effects
  drawParts();
  drawFloats();

  // Vignette
  const vig = ctx.createRadialGradient(W/2, H/2, W*0.3, W/2, H/2, W*0.85);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,.35)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, W, H);

  ctx.restore();
}

// ==================== MAIN LOOP ====================
function loop(ts) {
  if (!lastTs) lastTs = ts;
  lastTs = ts;
  update();
  render();
  requestAnimationFrame(loop);
}

// ==================== INPUT ROUTING ====================
function handleInput() {
  if (state === 'start') {
    state = 'playing';
    overlay.classList.remove('visible');
    hud.classList.add('visible');
    init();
  } else if (state === 'playing') {
    switchLane();
  } else if (state === 'gameover') {
    state = 'playing';
    overlay.classList.remove('visible');
    hud.classList.add('visible');
    init();
  }
}

shell.addEventListener('pointerdown', e => { e.preventDefault(); handleInput(); });
document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); handleInput(); }
});
shell.addEventListener('contextmenu', e => e.preventDefault());

// ==================== BOOT ====================
resize();
best = loadBest();
requestAnimationFrame(loop);
</script>
</body>
</html>
