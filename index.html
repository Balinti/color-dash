<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0d0d1a">

<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Run through color gates matching your current color. Tap to switch colors and dash between lanes. How far can you streak?">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og-image.jpg">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Run through color gates matching your current color. Tap to switch colors and dash between lanes.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og-image.jpg">

<!-- JSON-LD Schema -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "VideoGame",
  "name": "Color Dash: Split Sync",
  "description": "A hyper-casual two-lane auto-runner where you flip between lanes to match color gates. Build combos, dodge jammers, and chase multiplier rings.",
  "url": "https://balinti.github.io/color-dash/",
  "genre": "Casual",
  "gamePlatform": "Web Browser",
  "applicationCategory": "Game",
  "operatingSystem": "Any",
  "playMode": "SinglePlayer",
  "numberOfPlayers": "1",
  "inLanguage": "en"
}
</script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>

<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a14;touch-action:manipulation;-webkit-tap-highlight-color:transparent;user-select:none;-webkit-user-select:none}
#wrap{display:flex;justify-content:center;align-items:center;width:100%;height:100vh;height:100dvh}
canvas{display:block;touch-action:none;image-rendering:auto}
</style>
</head>
<body>
<div id="wrap"><canvas id="gc"></canvas></div>

<script>
'use strict';

// ==================== CANVAS SETUP ====================
const canvas = document.getElementById('gc');
const ctx = canvas.getContext('2d');

const BASE_W = 420, BASE_H = 750;
const MAX_W = 420, MAX_H = 750;

let dpr = Math.min(window.devicePixelRatio || 1, 3);
let cW, cH, scale;

function resize() {
  dpr = Math.min(window.devicePixelRatio || 1, 3);
  const ww = window.innerWidth, wh = window.innerHeight;
  const aspect = BASE_W / BASE_H;
  let w, h;
  if (ww / wh < aspect) {
    w = Math.min(ww, MAX_W);
    h = w / aspect;
  } else {
    h = Math.min(wh, MAX_H);
    w = h * aspect;
  }
  cW = w; cH = h;
  scale = w / BASE_W;
  canvas.width = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  ctx.setTransform(dpr * scale, 0, 0, dpr * scale, 0, 0);
}
resize();
window.addEventListener('resize', resize);

// ==================== CONSTANTS ====================
const TRACK_PAD = 30;
const TRACK_L = TRACK_PAD;
const TRACK_R = BASE_W - TRACK_PAD;
const TRACK_W = TRACK_R - TRACK_L;
const LANE_W = TRACK_W / 2;
const LANE_CL = TRACK_L + LANE_W / 2; // left lane center
const LANE_CR = TRACK_R - LANE_W / 2; // right lane center
const LANE_DIV = TRACK_L + LANE_W;    // center divider x

const PLAYER_Y = BASE_H - 140;
const PLAYER_R = 18;
const TRACK_Y = 0;
const GATE_H = 34;

// Colors
const COOL_H = 210, COOL_S = 85, COOL_L = 55;
const WARM_H = 28, WARM_S = 92, WARM_L = 55;
const COOL_CLR = `hsl(${COOL_H},${COOL_S}%,${COOL_L}%)`;
const WARM_CLR = `hsl(${WARM_H},${WARM_S}%,${WARM_L}%)`;

function laneColor(lane) {
  return lane === 0 ? COOL_CLR : WARM_CLR;
}
function laneHSL(lane) {
  return lane === 0 ? [COOL_H, COOL_S, COOL_L] : [WARM_H, WARM_S, WARM_L];
}
function hsl(h, s, l, a) {
  return a !== undefined ? `hsla(${h},${s}%,${l}%,${a})` : `hsl(${h},${s}%,${l}%)`;
}

// ==================== PERSISTENCE ====================
const LS_KEY = 'colordash_splitsync';
function loadSave() {
  try {
    const d = JSON.parse(localStorage.getItem(LS_KEY));
    return d || { hi: 0, bestCombo: 0 };
  } catch(e) { return { hi: 0, bestCombo: 0 }; }
}
function saveBest(score, combo) {
  const d = loadSave();
  if (score > d.hi) d.hi = score;
  if (combo > d.bestCombo) d.bestCombo = combo;
  localStorage.setItem(LS_KEY, JSON.stringify(d));
}

// ==================== GAME STATE ====================
let state = 'start'; // 'start' | 'playing' | 'gameover'
let score, combo, peakCombo, shield;
let speed, gameTime, nextSpawnDist, distSinceSpawn;
let shakeAmp, timeScale, timeScaleRecoverT;
let gates, particles, pPool;
let playerLane; // 0=left(cool), 1=right(warm)
let playerX, playerTargetX;
let accentHue; // cycling hue for juice
let goScore, goPeakCombo; // frozen at game over

// Particle pool
const MAX_PARTICLES = 600;
pPool = [];

function resetGame() {
  score = 0; combo = 0; peakCombo = 0; shield = 1;
  speed = 260; gameTime = 0;
  nextSpawnDist = 240; distSinceSpawn = 200; // spawn quickly
  shakeAmp = 0; timeScale = 1; timeScaleRecoverT = 0;
  gates = []; particles = []; pPool = [];
  playerLane = 0;
  playerX = LANE_CL;
  playerTargetX = LANE_CL;
  accentHue = 0;
}

function flipLane() {
  playerLane = playerLane === 0 ? 1 : 0;
  playerTargetX = playerLane === 0 ? LANE_CL : LANE_CR;
}

// ==================== SPEED & SPAWN ====================
function getSpeed(s) { return 260 + 18 * Math.sqrt(s); }
function getSpawnDist(s) { return Math.max(150, Math.min(240, 240 - 0.55 * s)); }

// ==================== GATE TYPES ====================
// gate: { y, leftLane (0=cool), rightLane (1=warm), type, scored,
//         jamSwapped, jamTime, jamTelegraph,
//         multValue, multLane, riskyWidth, wobblePhase,
//         flashT }
function spawnGate() {
  const s = score;
  const p = Math.max(0, Math.min(1, s / 120));

  // Probabilities
  const bonusChance = 0.10 + 0.20 * p;  // 10% -> 30%
  const jammerChance = 0.18 * p;          // 0% -> 18%

  let type = 'normal';
  const r = Math.random();
  if (r < jammerChance) {
    type = 'jammer';
  } else if (r < jammerChance + bonusChance) {
    type = 'bonus';
  }

  // Double gate after score ~80
  const doubleChance = s > 80 ? Math.min(0.25, (s - 80) / 200) : 0;

  const g = {
    y: TRACK_Y - GATE_H - 10,
    leftLane: 0,
    rightLane: 1,
    type: type,
    scored: false,
    // Jammer
    jamSwapped: false,
    jamTime: 0.55 - 0.25 * p,
    jamTelegraphStart: 0,
    jamTelegraphing: false,
    lifetime: 0,
    // Bonus
    multValue: Math.random() < 0.75 ? 2 : 3,
    multLane: Math.random() < 0.5 ? 0 : 1,
    riskyWidth: LANE_W * 0.72,
    wobblePhase: 0,
    wobbleActive: s > 20,
    // Visual
    flashT: 0
  };

  gates.push(g);

  // Possibly spawn a quick double
  if (Math.random() < doubleChance) {
    const g2 = Object.assign({}, g);
    g2.y -= GATE_H + 30;
    g2.type = 'normal';
    g2.scored = false;
    g2.lifetime = 0;
    g2.jamSwapped = false;
    gates.push(g2);
  }
}

// ==================== PARTICLES ====================
function spawnParticle(x, y, vx, vy, life, r, g, b, size) {
  const p = pPool.length > 0 ? pPool.pop() : {};
  p.x = x; p.y = y; p.vx = vx; p.vy = vy;
  p.life = life; p.maxLife = life;
  p.r = r; p.g = g; p.b = b;
  p.size = size || 3;
  p.grav = 520;
  if (particles.length < MAX_PARTICLES) particles.push(p);
}

function burstCleanPass(x, y, lane) {
  const [h, s, l] = laneHSL(lane);
  for (let i = 0; i < 14; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = 80 + Math.random() * 200;
    const rgb = hslToRgb(h, s, l);
    spawnParticle(x, y, Math.cos(a) * sp, Math.sin(a) * sp - 60,
      0.3 + Math.random() * 0.3, rgb[0], rgb[1], rgb[2], 2 + Math.random() * 3);
  }
}

function burstMultRing(x, y) {
  for (let i = 0; i < 24; i++) {
    const a = (i / 24) * Math.PI * 2;
    const sp = 180 + Math.random() * 100;
    spawnParticle(x, y, Math.cos(a) * sp, Math.sin(a) * sp,
      0.4 + Math.random() * 0.2, 255, 230, 60, 3 + Math.random() * 3);
  }
}

function burstMultTrail(x, y) {
  for (let i = 0; i < 10; i++) {
    spawnParticle(x + (Math.random() - 0.5) * 20, y + (Math.random() - 0.5) * 10,
      (Math.random() - 0.5) * 40, -40 - Math.random() * 80,
      0.3 + Math.random() * 0.2, 255, 200, 50, 2 + Math.random() * 2);
  }
}

function burstShieldBreak(x, y) {
  for (let i = 0; i < 30; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = 150 + Math.random() * 300;
    spawnParticle(x, y, Math.cos(a) * sp, Math.sin(a) * sp,
      0.4 + Math.random() * 0.3, 255, 100, 60, 3 + Math.random() * 4);
  }
}

function burstGameOver(x, y) {
  for (let i = 0; i < 50; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = 200 + Math.random() * 400;
    spawnParticle(x, y, Math.cos(a) * sp, Math.sin(a) * sp,
      0.5 + Math.random() * 0.5, 255, 50, 50, 3 + Math.random() * 5);
  }
}

// HSL to RGB helper
function hslToRgb(h, s, l) {
  s /= 100; l /= 100;
  const k = n => (n + h / 30) % 12;
  const a = s * Math.min(l, 1 - l);
  const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, 9 - k(n), 1));
  return [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
}

// ==================== COLLISION ====================
function circleRectOverlap(cx, cy, cr, rx, ry, rw, rh) {
  const closestX = Math.max(rx, Math.min(cx, rx + rw));
  const closestY = Math.max(ry, Math.min(cy, ry + rh));
  const dx = cx - closestX, dy = cy - closestY;
  return dx * dx + dy * dy <= cr * cr;
}

// ==================== UPDATE ====================
function update(rawDt) {
  if (state !== 'playing') return;

  // Time scale recovery
  if (timeScaleRecoverT > 0) {
    timeScaleRecoverT -= rawDt;
    if (timeScaleRecoverT <= 0) {
      timeScale = 1;
      timeScaleRecoverT = 0;
    } else {
      timeScale = 0.35 + (1 - 0.35) * (1 - timeScaleRecoverT / 0.4);
    }
  }

  const dt = rawDt * timeScale;
  gameTime += dt;
  accentHue = (accentHue + dt * 60) % 360;

  // Speed
  speed = getSpeed(score);

  // Player movement (instant snap with smooth lerp)
  const lerpSpeed = 28;
  playerX += (playerTargetX - playerX) * Math.min(1, lerpSpeed * dt);

  // Spawn gates by distance
  const moveDist = speed * dt;
  distSinceSpawn += moveDist;
  nextSpawnDist = getSpawnDist(score);
  if (distSinceSpawn >= nextSpawnDist) {
    distSinceSpawn = 0;
    spawnGate();
  }

  // Move gates & check scoring/collision
  for (let i = gates.length - 1; i >= 0; i--) {
    const g = gates[i];
    g.y += speed * dt;
    g.lifetime += dt;
    g.flashT += dt;

    // Jammer logic
    if (g.type === 'jammer' && !g.jamSwapped) {
      const timeToReach = (PLAYER_Y - g.y) / speed;
      if (timeToReach <= g.jamTime) {
        // Swap safe lanes
        g.jamSwapped = true;
        const tmp = g.leftLane;
        g.leftLane = g.rightLane;
        g.rightLane = tmp;
      }
      // Telegraph
      if (timeToReach <= g.jamTime + 0.12 && timeToReach > g.jamTime) {
        g.jamTelegraphing = true;
      }
    }

    // Bonus wobble
    if (g.type === 'bonus' && g.wobbleActive) {
      g.wobblePhase += dt * 4;
    }

    // Collision check: gate overlaps player
    if (!g.scored && g.y + GATE_H >= PLAYER_Y - PLAYER_R && g.y <= PLAYER_Y + PLAYER_R) {
      g.scored = true;

      // Determine which lane half the player is in
      const pLane = playerLane;

      // Get the color identity of the half the player is in
      const halfLane = pLane === 0 ? g.leftLane : g.rightLane;

      // For bonus type, check if player hit multiplier lane
      let hitMultiplier = false;
      if (g.type === 'bonus') {
        // Both halves are valid, check if player chose multLane
        if (pLane === g.multLane) {
          // Check risky width
          const laneCenter = pLane === 0 ? LANE_CL : LANE_CR;
          const riskyHalf = g.riskyWidth / 2;
          const wobbleOffset = g.wobbleActive ? Math.sin(g.wobblePhase) * 12 : 0;
          const riskyCenter = laneCenter + wobbleOffset;
          // If player within risky width
          if (Math.abs(playerX - riskyCenter) <= riskyHalf / 2 + PLAYER_R) {
            hitMultiplier = true;
          }
          // Even if missed risky zone, bonus gates are always passable
        }
        // Bonus: always pass
        const comboBonus = Math.floor(combo / 5);
        const pts = hitMultiplier ? (1 + comboBonus) * g.multValue : 1 + comboBonus;
        score += pts;
        combo++;
        if (combo > peakCombo) peakCombo = combo;
        burstCleanPass(playerX, PLAYER_Y, pLane);
        if (hitMultiplier) {
          burstMultRing(playerX, PLAYER_Y);
          shakeAmp += 5;
        }
      } else if (g.type === 'jammer' || g.type === 'normal') {
        // Must match: player lane identity matches the gate half identity
        const match = (pLane === halfLane);
        if (match) {
          // Clean pass
          const comboBonus = Math.floor(combo / 5);
          score += 1 + comboBonus;
          combo++;
          if (combo > peakCombo) peakCombo = combo;
          burstCleanPass(playerX, PLAYER_Y, pLane);
        } else {
          // Wrong!
          if (shield === 1) {
            // Break shield
            shield = 0;
            combo = Math.floor(combo * 0.4);
            timeScale = 0.35;
            timeScaleRecoverT = 0.4;
            shakeAmp += 10;
            burstShieldBreak(playerX, PLAYER_Y);
          } else {
            // Game over
            goScore = Math.floor(score);
            goPeakCombo = peakCombo;
            burstGameOver(playerX, PLAYER_Y);
            shakeAmp = 18;
            state = 'gameover';
            saveBest(goScore, goPeakCombo);
            return;
          }
        }
      }
    }

    // Remove gates that are off screen
    if (g.y > BASE_H + 50) {
      gates.splice(i, 1);
    }
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.life -= rawDt; // particles run on raw time
    if (p.life <= 0) {
      pPool.push(particles[i]);
      particles.splice(i, 1);
      continue;
    }
    p.x += p.vx * rawDt;
    p.y += p.vy * rawDt;
    p.vy += p.grav * rawDt;
  }

  // Shake decay: 18/s
  if (shakeAmp > 0) {
    shakeAmp -= 18 * rawDt;
    if (shakeAmp < 0.2) shakeAmp = 0;
  }
}

// ==================== DRAWING ====================
function drawTriangle(cx, cy, size) {
  ctx.beginPath();
  ctx.moveTo(cx, cy - size);
  ctx.lineTo(cx - size * 0.866, cy + size * 0.5);
  ctx.lineTo(cx + size * 0.866, cy + size * 0.5);
  ctx.closePath();
}

function drawCircleIcon(cx, cy, size) {
  ctx.beginPath();
  ctx.arc(cx, cy, size * 0.7, 0, Math.PI * 2);
}

function drawStripePattern(x, y, w, h) {
  ctx.save();
  ctx.globalAlpha = 0.12;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5;
  for (let i = -2; i < w / 8 + 2; i++) {
    const sx = x + i * 8;
    ctx.beginPath();
    ctx.moveTo(sx, y);
    ctx.lineTo(sx - h * 0.3, y + h);
    ctx.stroke();
  }
  ctx.restore();
}

function drawDotPattern(x, y, w, h) {
  ctx.save();
  ctx.globalAlpha = 0.1;
  ctx.fillStyle = '#fff';
  for (let r = 0; r < h; r += 8) {
    for (let c = 0; c < w; c += 8) {
      ctx.beginPath();
      ctx.arc(x + c + 4, y + r + 4, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.restore();
}

function drawGateHalf(g, side, cx, halfW) {
  const isLeft = side === 0;
  const laneSide = isLeft ? g.leftLane : g.rightLane;
  const [ch, cs, cl] = laneHSL(laneSide);
  const color = hsl(ch, cs, cl, 1);
  const darkColor = hsl(ch, cs, cl - 15, 1);

  let x, w;
  if (g.type === 'bonus' && side === g.multLane) {
    // Risky narrower lane
    const wobbleOffset = g.wobbleActive ? Math.sin(g.wobblePhase) * 12 : 0;
    w = g.riskyWidth;
    x = cx - w / 2 + wobbleOffset;
  } else {
    w = halfW - 4;
    x = isLeft ? TRACK_L + 2 : LANE_DIV + 2;
  }

  // Gate body
  ctx.fillStyle = darkColor;
  ctx.fillRect(x, g.y, w, GATE_H);

  // Inner lighter fill
  ctx.fillStyle = color;
  ctx.fillRect(x + 2, g.y + 2, w - 4, GATE_H - 4);

  // Pattern
  ctx.save();
  ctx.beginPath();
  ctx.rect(x, g.y, w, GATE_H);
  ctx.clip();
  if (laneSide === 0) {
    drawStripePattern(x, g.y, w, GATE_H);
  } else {
    drawDotPattern(x, g.y, w, GATE_H);
  }
  ctx.restore();

  // Icon
  const iconSize = GATE_H * 0.3;
  const iconX = x + w / 2;
  const iconY = g.y + GATE_H / 2;
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.strokeStyle = 'rgba(255,255,255,0.6)';
  ctx.lineWidth = 2;
  if (laneSide === 0) {
    // Triangle for cool
    drawTriangle(iconX, iconY, iconSize);
    ctx.fill();
  } else {
    // Circle for warm
    drawCircleIcon(iconX, iconY, iconSize);
    ctx.fill();
  }

  // Thick outline for accessibility
  ctx.strokeStyle = color;
  ctx.lineWidth = 3;
  ctx.strokeRect(x, g.y, w, GATE_H);

  // Jammer telegraph flash
  if (g.type === 'jammer' && g.jamTelegraphing && !g.jamSwapped) {
    const flash = Math.sin(g.flashT * 30) * 0.5 + 0.5;
    ctx.strokeStyle = `rgba(255, 255, 100, ${0.4 + flash * 0.5})`;
    ctx.lineWidth = 4;
    ctx.strokeRect(x - 2, g.y - 2, w + 4, GATE_H + 4);
  }

  // Jammer indicator
  if (g.type === 'jammer' && !g.jamSwapped) {
    ctx.fillStyle = 'rgba(255,255,0,0.3)';
    ctx.font = 'bold 10px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('!', x + w / 2, g.y - 12);
  }

  // Bonus multiplier ring
  if (g.type === 'bonus' && side === g.multLane) {
    const ringR = GATE_H * 0.45;
    ctx.strokeStyle = `rgba(255, 230, 50, ${0.5 + Math.sin(g.flashT * 6) * 0.3})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(iconX, iconY, ringR, 0, Math.PI * 2);
    ctx.stroke();
    // multiplier label
    ctx.fillStyle = 'rgba(255,230,50,0.85)';
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText('x' + g.multValue, iconX, g.y - 2);
  }
}

function draw(rawT) {
  ctx.save();

  // Screen shake
  let sx = 0, sy = 0;
  if (shakeAmp > 0) {
    sx = (Math.random() - 0.5) * shakeAmp * 2;
    sy = (Math.random() - 0.5) * shakeAmp * 2;
    ctx.translate(sx, sy);
  }

  // Background gradient
  const bgHue = (accentHue || 0);
  const bgGrd = ctx.createLinearGradient(0, 0, 0, BASE_H);
  bgGrd.addColorStop(0, hsl(220 + bgHue * 0.05, 25, 8, 1));
  bgGrd.addColorStop(0.5, hsl(240 + bgHue * 0.03, 20, 6, 1));
  bgGrd.addColorStop(1, hsl(260 + bgHue * 0.04, 22, 4, 1));
  ctx.fillStyle = bgGrd;
  ctx.fillRect(-30, -30, BASE_W + 60, BASE_H + 60);

  // Track background
  ctx.fillStyle = 'rgba(255,255,255,0.025)';
  ctx.fillRect(TRACK_L, 0, TRACK_W, BASE_H);

  // Lane tint
  ctx.fillStyle = `hsla(${COOL_H},${COOL_S}%,${COOL_L}%,0.03)`;
  ctx.fillRect(TRACK_L, 0, LANE_W, BASE_H);
  ctx.fillStyle = `hsla(${WARM_H},${WARM_S}%,${WARM_L}%,0.03)`;
  ctx.fillRect(LANE_DIV, 0, LANE_W, BASE_H);

  // Lane divider
  ctx.setLineDash([10, 14]);
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(LANE_DIV, 0);
  ctx.lineTo(LANE_DIV, BASE_H);
  ctx.stroke();
  ctx.setLineDash([]);

  // Draw gates
  for (const g of gates) {
    drawGateHalf(g, 0, LANE_CL, LANE_W);
    drawGateHalf(g, 1, LANE_CR, LANE_W);
  }

  // Draw player
  if (state === 'playing' || state === 'start') {
    const [ph, ps, pl] = laneHSL(playerLane);
    const pColor = hsl(ph, ps, pl, 1);

    // Glow
    const glowR = PLAYER_R * 2.5;
    const grd = ctx.createRadialGradient(playerX, PLAYER_Y, PLAYER_R * 0.3, playerX, PLAYER_Y, glowR);
    grd.addColorStop(0, hsl(ph, ps, pl, 0.3));
    grd.addColorStop(1, hsl(ph, ps, pl, 0));
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(playerX, PLAYER_Y, glowR, 0, Math.PI * 2);
    ctx.fill();

    // Body
    ctx.fillStyle = pColor;
    ctx.beginPath();
    ctx.arc(playerX, PLAYER_Y, PLAYER_R, 0, Math.PI * 2);
    ctx.fill();

    // Rim
    ctx.strokeStyle = hsl(ph, ps, pl + 20, 0.9);
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.arc(playerX, PLAYER_Y, PLAYER_R - 1, 0, Math.PI * 2);
    ctx.stroke();

    // Icon inside player
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    ctx.strokeStyle = 'rgba(255,255,255,0.75)';
    ctx.lineWidth = 2;
    if (playerLane === 0) {
      drawTriangle(playerX, PLAYER_Y, PLAYER_R * 0.55);
      ctx.fill();
    } else {
      drawCircleIcon(playerX, PLAYER_Y, PLAYER_R * 0.55);
      ctx.fill();
    }

    // Shield indicator
    if (shield === 1 && state === 'playing') {
      ctx.strokeStyle = hsl((accentHue * 2) % 360, 70, 70, 0.5);
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.arc(playerX, PLAYER_Y, PLAYER_R + 6, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  // Draw particles
  for (const p of particles) {
    const alpha = Math.max(0, p.life / p.maxLife) * 0.85;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = `rgb(${p.r},${p.g},${p.b})`;
    const hs = p.size / 2;
    ctx.fillRect(p.x - hs, p.y - hs, p.size, p.size);
  }
  ctx.globalAlpha = 1;

  // ===== HUD =====
  if (state === 'playing') {
    // Score
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 34px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 4;
    ctx.fillText(Math.floor(score), BASE_W / 2, 18);
    ctx.shadowBlur = 0;

    // Combo
    if (combo > 0) {
      const comboBonus = Math.floor(combo / 5);
      ctx.font = 'bold 14px sans-serif';
      ctx.fillStyle = comboBonus > 0 ? 'rgba(255,220,80,0.9)' : 'rgba(255,255,255,0.5)';
      ctx.fillText(`combo ${combo}` + (comboBonus > 0 ? `  +${comboBonus}` : ''), BASE_W / 2, 58);
    }

    // Shield indicator text
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillStyle = shield === 1 ? 'rgba(100,220,255,0.6)' : 'rgba(255,80,80,0.5)';
    ctx.fillText(shield === 1 ? 'SHIELD' : 'NO SHIELD', 10, 18);

    // Lane labels
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = `hsla(${COOL_H},${COOL_S}%,${COOL_L}%,0.25)`;
    ctx.fillText('COOL', LANE_CL, BASE_H - 20);
    ctx.fillStyle = `hsla(${WARM_H},${WARM_S}%,${WARM_L}%,0.25)`;
    ctx.fillText('WARM', LANE_CR, BASE_H - 20);
  }

  // ===== START SCREEN =====
  if (state === 'start') {
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0, 0, BASE_W, BASE_H);

    // Title
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 40px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(80,160,255,0.4)';
    ctx.shadowBlur = 14;
    ctx.fillText('COLOR DASH', BASE_W / 2, 180);
    ctx.shadowBlur = 0;

    ctx.font = '16px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.45)';
    ctx.fillText('Split Sync', BASE_W / 2, 218);

    // Tap prompt
    const tapPulse = 0.65 + 0.35 * Math.sin(rawT * 3.5);
    ctx.globalAlpha = tapPulse;
    ctx.font = '20px sans-serif';
    ctx.fillStyle = 'rgba(255,255,220,0.95)';
    ctx.fillText('Tap to Start', BASE_W / 2, 300);
    ctx.globalAlpha = 1;

    // Instructions
    ctx.font = '13px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.fillText('Tap to flip between lanes', BASE_W / 2, 360);
    ctx.fillText('Left = COOL (blue triangle)', BASE_W / 2, 382);
    ctx.fillText('Right = WARM (orange circle)', BASE_W / 2, 404);
    ctx.fillText('Match your lane to the gate color', BASE_W / 2, 430);

    // Lane preview icons
    ctx.fillStyle = COOL_CLR;
    drawTriangle(BASE_W / 2 - 50, 464, 10);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.font = '11px sans-serif';
    ctx.fillText('COOL', BASE_W / 2 - 50, 484);

    ctx.fillStyle = WARM_CLR;
    drawCircleIcon(BASE_W / 2 + 50, 464, 10);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.fillText('WARM', BASE_W / 2 + 50, 484);

    // Best score
    const sv = loadSave();
    if (sv.hi > 0) {
      ctx.font = '14px sans-serif';
      ctx.fillStyle = 'rgba(255,220,80,0.6)';
      ctx.fillText(`Best: ${sv.hi}`, BASE_W / 2, 530);
    }

    ctx.font = '11px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fillText('Space / Enter / Tap', BASE_W / 2, 580);
  }

  // ===== GAME OVER =====
  if (state === 'gameover') {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, BASE_W, BASE_H);

    ctx.fillStyle = '#f55';
    ctx.font = 'bold 36px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(255,50,50,0.5)';
    ctx.shadowBlur = 10;
    ctx.fillText('GAME OVER', BASE_W / 2, 185);
    ctx.shadowBlur = 0;

    // Score
    ctx.font = 'bold 48px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText(goScore, BASE_W / 2, 260);
    ctx.font = '12px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.fillText('SCORE', BASE_W / 2, 295);

    // Best
    const sv = loadSave();
    ctx.font = '15px sans-serif';
    ctx.fillStyle = 'rgba(255,220,80,0.8)';
    ctx.fillText(`Best: ${sv.hi}`, BASE_W / 2, 330);

    // Peak combo
    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.fillText(`Peak Combo: ${goPeakCombo}`, BASE_W / 2, 358);

    // Retry
    const retryPulse = 0.6 + 0.4 * Math.sin(rawT * 3);
    ctx.globalAlpha = retryPulse;
    ctx.font = '19px sans-serif';
    ctx.fillStyle = 'rgba(255,255,220,0.9)';
    ctx.fillText('Tap to Retry', BASE_W / 2, 430);
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

// ==================== INPUT ====================
function handleInput(e) {
  if (e) e.preventDefault();
  if (state === 'start') {
    resetGame();
    state = 'playing';
    return;
  }
  if (state === 'gameover') {
    resetGame();
    state = 'playing';
    return;
  }
  if (state === 'playing') {
    flipLane();
  }
}

canvas.addEventListener('pointerdown', handleInput, { passive: false });
document.addEventListener('keydown', e => {
  if (e.repeat) return;
  if (e.code === 'Space' || e.code === 'Enter') {
    e.preventDefault();
    handleInput(null);
  }
});

// ==================== MAIN LOOP ====================
let lastTime = 0;
resetGame();
state = 'start';

function loop(ts) {
  const t = ts / 1000;
  const dt = Math.min(t - (lastTime || t), 0.05);
  lastTime = t;

  update(dt);
  draw(t);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
