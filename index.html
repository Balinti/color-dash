<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#1a1a2e">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Run through color gates matching your current color. Tap to flip lane and color. How far can you dash?">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Run through color gates matching your current color. Tap to flip lane and color. How far can you dash?">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og.png">
<link rel="canonical" href="https://balinti.github.io/color-dash/">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#fff;touch-action:none;user-select:none;-webkit-user-select:none}
body{display:flex;flex-direction:column;align-items:center;min-height:100vh;min-height:100svh;min-height:100dvh}
header{width:100%;text-align:center;padding:8px 0 4px;font-size:13px;letter-spacing:2px;text-transform:uppercase;color:rgba(255,255,255,0.35);flex-shrink:0}
footer{width:100%;text-align:center;padding:4px 0 8px;font-size:11px;color:rgba(255,255,255,0.25);flex-shrink:0;line-height:1.4}
#wrap{position:relative;width:100%;max-width:420px;flex:1;max-height:750px;overflow:hidden;border-radius:8px}
canvas#c{display:block;width:100%;height:100%}
#hud{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:flex;flex-direction:column;align-items:center;padding:12px}
#hud .score{font-size:48px;font-weight:700;text-shadow:0 2px 12px rgba(0,0,0,0.5);letter-spacing:-1px;line-height:1}
#hud .combo{font-size:16px;font-weight:600;margin-top:4px;opacity:0.8;text-shadow:0 1px 6px rgba(0,0,0,0.5)}
#hud .hearts{font-size:22px;margin-top:6px;text-shadow:0 1px 6px rgba(0,0,0,0.5)}
#overlay{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:auto;background:rgba(10,10,26,0.88);transition:opacity 0.25s}
#overlay.hidden{opacity:0;pointer-events:none}
#overlay h1{font-size:38px;font-weight:800;letter-spacing:-1px;margin-bottom:4px;text-shadow:0 0 30px rgba(100,200,255,0.3)}
#overlay .sub{font-size:14px;color:rgba(255,255,255,0.5);margin-bottom:24px}
#overlay .tap{font-size:18px;font-weight:600;animation:pulse 1.5s ease-in-out infinite;margin-top:20px}
#overlay .instruction{font-size:12px;color:rgba(255,255,255,0.4);margin-top:8px}
#overlay .challenge{font-size:16px;font-weight:700;color:#ffcc00;margin-bottom:12px;text-shadow:0 0 10px rgba(255,200,0,0.4)}
#overlay .stats{text-align:center;margin-bottom:16px;line-height:2}
#overlay .stats div{font-size:14px;color:rgba(255,255,255,0.6)}
#overlay .stats .big{font-size:42px;font-weight:800;color:#fff}
#overlay .stats .label{font-size:11px;text-transform:uppercase;letter-spacing:1px;color:rgba(255,255,255,0.35)}
#overlay .btn-row{display:flex;gap:10px;margin-top:12px}
#overlay .btn{padding:10px 20px;border-radius:20px;border:1px solid rgba(255,255,255,0.2);background:rgba(255,255,255,0.08);color:#fff;font-size:13px;font-weight:600;cursor:pointer;transition:background 0.2s}
#overlay .btn:hover{background:rgba(255,255,255,0.15)}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.4}}
</style>
</head>
<body>
<header>Color Dash</header>
<div id="wrap">
<canvas id="c"></canvas>
<div id="hud">
<div class="score" id="scoreDisplay">0</div>
<div class="combo" id="comboDisplay"></div>
<div class="hearts" id="heartsDisplay"></div>
</div>
<div id="overlay">
<h1>Color Dash</h1>
<div class="sub">Pulse Split</div>
<div class="tap">Tap to Start</div>
<div class="instruction">Tap flips lane + color.</div>
</div>
</div>
<footer>Tap or press Space to flip your lane and color. Match the gate color to score. Miss twice and it's game over!</footer>

<script>
(function(){
'use strict';

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const wrap = document.getElementById('wrap');
const overlay = document.getElementById('overlay');
const scoreDisplay = document.getElementById('scoreDisplay');
const comboDisplay = document.getElementById('comboDisplay');
const heartsDisplay = document.getElementById('heartsDisplay');

/* ── URL challenge param ── */
const urlParams = new URLSearchParams(window.location.search);
const challengeScore = urlParams.get('challengeScore') ? parseInt(urlParams.get('challengeScore'),10) : null;

/* ── Canvas sizing (High-DPI) ── */
let W, H, dpr;
function resize(){
  const rect = wrap.getBoundingClientRect();
  dpr = Math.min(window.devicePixelRatio || 1, 3);
  W = rect.width;
  H = rect.height;
  canvas.width  = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);
resize();

/* ── Palette ── */
const COL_RED  = '#ff4466';
const COL_BLUE = '#4488ff';
const HSL_RED  = [350,100,64];
const HSL_BLUE = [218,100,64];
function hsl(h,s,l,a){ return a!==undefined ? 'hsla('+h+','+s+'%,'+l+'%,'+a+')' : 'hsl('+h+','+s+'%,'+l+'%)'; }

/* ── State ── */
let state = 'start';
let score = 0, displayScore = 0;
let combo = 0, maxCombo = 0, nearBonusTotal = 0;
let hearts = 1;
let lane = 0;        // 0=left 1=right
let playerColor = 0; // 0=red  1=blue
let gatesCleared = 0;
let gates = [], particles = [];
let spawnTimer = 0, gameTime = 0;
let bgHue = 240;
let shakeX=0, shakeY=0, shakeMag=0, shakeDecay=0;
let slowMo = 0, retryDelay = 0;
let best = parseInt(localStorage.getItem('pulseSplitBest'),10) || 0;

/* ── Player constants ── */
const P_R = 14;
const P_Y_OFF = 100;
function px(){ return lane===0 ? W*0.25 : W*0.75; }
function py(){ return H - P_Y_OFF; }

/* ── Difficulty formulas ── */
function speed(){ return Math.min(520, 260 + 3.2*gatesCleared); }
function interval(){ return Math.max(0.52, 0.95 - 0.0045*gatesCleared); }
function divAmp(){
  const s=gatesCleared;
  if(s<25)return 0; if(s<50)return 10; if(s<80)return 14; return 18;
}
function movAmp(){
  const s=gatesCleared;
  if(s<50)return 0; if(s<80)return 14; return 18;
}
function movFreq(){ return gatesCleared<80?2.6:3.2; }

function pickPattern(){
  const s=gatesCleared, r=Math.random()*100;
  if(s<10) return 'static';
  if(s<25){ if(r<70)return 'static'; if(r<95)return 'narrow'; return 'sameColor'; }
  if(s<50){ if(r<45)return 'static'; if(r<70)return 'narrow'; if(r<90)return 'double'; return 'static'; }
  if(s<80){ if(r<25)return 'static'; if(r<50)return 'narrow'; if(r<75)return 'double'; return 'moving'; }
  if(r<30)return 'narrow'; if(r<60)return 'double'; if(r<90)return 'moving'; return 'sameColor';
}

/* ── Gate factory ── */
function makeGate(yy, pat){
  const flip = Math.random()<0.5;
  const g = {
    y: yy!==undefined ? yy : -40,
    leftColor:  flip?1:0,
    rightColor: flip?0:1,
    divRatio: 0.5,
    pattern: pat||'static',
    mAmp:0, mFreq:0, mPhase: Math.random()*Math.PI*2,
    resolved:false, popScale:0
  };
  if(g.pattern==='narrow') g.divRatio = 0.35 + Math.random()*0.3; // shifted divider
  if(g.pattern==='moving'){ g.mAmp=movAmp(); g.mFreq=movFreq(); }
  if(g.pattern==='sameColor'){ const c=Math.random()<0.5?0:1; g.leftColor=c; g.rightColor=c; }
  return g;
}

function spawnGates(){
  const pat = pickPattern();
  gates.push(makeGate(undefined, pat));
  if(pat==='double'){
    const g2 = makeGate(-40 - speed()*0.42, 'static');
    g2.leftColor  = Math.random()<0.5?1:0;
    g2.rightColor = 1-g2.leftColor;
    gates.push(g2);
  }
}

/* ── Particles ── */
function burst(x,y,col,n,spread,life,sz){
  for(let i=0;i<n&&particles.length<300;i++){
    const a=Math.random()*Math.PI*2, sp=spread*(0.3+Math.random()*0.7);
    particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-30,
      life:life*(0.7+Math.random()*0.3),maxLife:life,
      size:sz[0]+Math.random()*(sz[1]-sz[0]),color:col});
  }
}
function ringPulse(x,y,col){
  particles.push({x,y,vx:0,vy:0,life:0.4,maxLife:0.4,size:0,ring:true,ringMax:60,color:col});
}

/* ── Shake ── */
function addShake(m,d){ shakeMag=Math.max(shakeMag,m); shakeDecay=d; }

/* ── Input ── */
function doInput(){
  if(state==='start') startGame();
  else if(state==='playing'){ lane=1-lane; playerColor=1-playerColor; }
  else if(state==='gameover'&& retryDelay<=0){ startGame(); }
}
wrap.addEventListener('pointerdown',function(e){e.preventDefault();doInput();});
document.addEventListener('keydown',function(e){
  if(e.code==='Space'||e.code==='Enter'){e.preventDefault();doInput();}
});

/* ── Game control ── */
function startGame(){
  state='playing'; score=0; displayScore=0; combo=0; maxCombo=0;
  nearBonusTotal=0; hearts=1; lane=0; playerColor=0; gatesCleared=0;
  gates=[]; particles=[]; spawnTimer=0.3; gameTime=0;
  shakeMag=0; slowMo=0;
  overlay.classList.add('hidden');
  updateHUD();
}

function showGameOver(){
  state='gameover'; retryDelay=0.35;
  const fs = Math.floor(score);
  best = Math.max(best, fs);
  localStorage.setItem('pulseSplitBest', String(best));
  const mult = 1+Math.floor(Math.min(3,maxCombo/6));
  const beat = challengeScore && fs > challengeScore;

  overlay.classList.remove('hidden');
  overlay.innerHTML =
    '<div class="stats">'+
      '<div class="label">Score</div><div class="big">'+fs+'</div>'+
      '<div>Best: '+best+'</div>'+
      '<div>Max Combo: x'+mult+' ('+maxCombo+')</div>'+
      '<div>Near Bonus: +'+nearBonusTotal.toFixed(1)+'</div>'+
      (beat?'<div style="color:#ffcc00;font-weight:700;margin-top:4px">Challenge beaten!</div>':'')+
    '</div>'+
    '<div class="tap">Tap anywhere to Retry</div>'+
    '<div class="btn-row">'+
      '<button class="btn" id="shareBtn">Share</button>'+
      '<button class="btn" id="challengeBtn">Challenge</button>'+
    '</div>';

  setTimeout(function(){
    var sb=document.getElementById('shareBtn'), cb=document.getElementById('challengeBtn');
    if(sb) sb.addEventListener('pointerdown',function(e){e.stopPropagation();shareResult(fs);});
    if(cb) cb.addEventListener('pointerdown',function(e){e.stopPropagation();shareChallenge(fs);});
  },10);

  addShake(12,8); slowMo=0.15;
  burst(px(),py(),'#ff2222',20,200,0.8,[3,8]);
  burst(px(),py(),'#888',15,180,0.7,[2,6]);
}

function shareResult(s){
  const t='I scored '+s+' in Color Dash! Play: https://balinti.github.io/color-dash/';
  if(navigator.share) navigator.share({title:'Color Dash',text:t}).catch(function(){});
  else navigator.clipboard.writeText(t).then(function(){alert('Copied!');}).catch(function(){});
}
function shareChallenge(s){
  const u='https://balinti.github.io/color-dash/?challengeScore='+s;
  const t='I scored '+s+' in Color Dash! Beat my score: '+u;
  if(navigator.share) navigator.share({title:'Color Dash Challenge',text:t,url:u}).catch(function(){});
  else navigator.clipboard.writeText(t).then(function(){alert('Challenge link copied!');}).catch(function(){});
}

/* ── HUD ── */
function updateHUD(){
  scoreDisplay.textContent = Math.floor(displayScore);
  const m = 1+Math.floor(Math.min(3,combo/6));
  comboDisplay.textContent = combo>0 ? 'x'+m+' ('+combo+' combo)' : '';
  comboDisplay.style.color = m>=4?'#ffcc00':m>=3?'#ff8844':m>=2?'#66ccff':'rgba(255,255,255,0.6)';
  heartsDisplay.textContent = hearts>0 ? '\u2764\uFE0F' : '\uD83D\uDDA4';
}

/* ── Gate divider X ── */
function gDivX(g){
  let base = W * g.divRatio;
  const da = divAmp();
  if(da>0) base += Math.sin(gameTime*1.8 + g.mPhase)*da;
  if(g.mAmp>0) base += Math.sin(gameTime*g.mFreq + g.mPhase)*g.mAmp;
  return Math.max(40, Math.min(W-40, base));
}

/* ── Main loop ── */
let lastT = 0;
function loop(ts){
  requestAnimationFrame(loop);
  if(!lastT){lastT=ts;return;}
  let dt=(ts-lastT)/1000; lastT=ts;
  dt=Math.min(dt,0.033);
  if(slowMo>0){slowMo-=dt; dt*=0.25;}
  if(state==='gameover') retryDelay-=dt;
  bgHue=(bgHue+dt*5)%360;

  // Shake
  if(shakeMag>0.1){
    shakeX=(Math.random()-0.5)*2*shakeMag;
    shakeY=(Math.random()-0.5)*2*shakeMag;
    shakeMag*=Math.exp(-shakeDecay*dt*4);
    if(shakeMag<0.1){shakeMag=0;shakeX=0;shakeY=0;}
  }

  /* ── Update (playing) ── */
  if(state==='playing'){
    gameTime+=dt;
    const v = speed();
    spawnTimer-=dt;
    if(spawnTimer<=0){ spawnGates(); spawnTimer=interval(); }

    const _py = py(), _px = px();
    for(let i=gates.length-1;i>=0;i--){
      const g=gates[i];
      g.y += v*dt;
      g.popScale = Math.min(1, g.popScale + dt/0.08);
      if(g.y > H+60){ gates.splice(i,1); continue; }

      // Collision
      const gh=18;
      if(!g.resolved && g.y+gh > _py-P_R && g.y-gh < _py+P_R){
        g.resolved=true;
        const dv = gDivX(g);
        const side = _px < dv ? 0 : 1;
        const gc = side===0 ? g.leftColor : g.rightColor;
        const correct = gc===playerColor;
        const distDiv = Math.abs(_px - dv);

        if(correct){
          gatesCleared++;
          combo++;
          maxCombo=Math.max(maxCombo,combo);
          const mult = 1+Math.floor(Math.min(3,combo/6));
          const prevMult = 1+Math.floor(Math.min(3,(combo-1)/6));
          let nb=0;
          if(distDiv<10) nb = 0.2*Math.max(0, Math.min(1, 1-distDiv/10));
          score += 1*mult + nb;
          nearBonusTotal += nb;

          const pc = playerColor===0 ? COL_RED : COL_BLUE;
          burst(_px,_py,pc,8,120,0.5,[2,5]);
          burst(_px,_py,'#fff',4,80,0.3,[1,3]);
          addShake(2,15);

          if(mult>prevMult){ ringPulse(_px,_py,pc); addShake(5,12); }
        } else {
          combo=0;
          if(hearts>0){
            hearts--;
            addShake(6,10); slowMo=0.15;
            burst(_px,_py,'#888',12,150,0.6,[3,6]);
            burst(_px,_py,'#ff4444',6,100,0.4,[2,4]);
          } else {
            showGameOver();
          }
        }
      }
    }
    displayScore += (score-displayScore)*Math.min(1,dt*10);
    updateHUD();
  }

  /* ── Update particles ── */
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i]; p.life-=dt;
    if(p.life<=0){particles.splice(i,1);continue;}
    if(!p.ring){ p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy+=200*dt; }
  }

  draw();
}

/* ── Render ── */
function draw(){
  ctx.save();
  ctx.translate(shakeX,shakeY);

  // BG gradient
  const g1=ctx.createLinearGradient(0,0,0,H);
  g1.addColorStop(0,hsl((bgHue+20)%360,30,8));
  g1.addColorStop(1,hsl(bgHue,40,5));
  ctx.fillStyle=g1;
  ctx.fillRect(-20,-20,W+40,H+40);

  if(state==='playing'||state==='gameover'){
    // Lane divider
    ctx.save();
    ctx.strokeStyle='rgba(255,255,255,0.06)';
    ctx.lineWidth=1;
    ctx.setLineDash([8,12]);
    ctx.beginPath(); ctx.moveTo(W/2,0); ctx.lineTo(W/2,H); ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  // Gates
  for(let i=0;i<gates.length;i++) drawGate(gates[i]);

  // Player
  if(state==='playing'||state==='gameover') drawPlayer();

  // Particles
  for(let i=0;i<particles.length;i++){
    const p=particles[i];
    const a=p.life/p.maxLife;
    if(p.ring){
      const prog=1-a;
      ctx.strokeStyle=p.color; ctx.globalAlpha=a*0.6;
      ctx.lineWidth=3*(1-prog);
      ctx.beginPath(); ctx.arc(p.x,p.y,prog*p.ringMax,0,Math.PI*2); ctx.stroke();
      ctx.globalAlpha=1;
    } else {
      ctx.globalAlpha=a; ctx.fillStyle=p.color;
      ctx.beginPath(); ctx.arc(p.x,p.y,p.size*a,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;
    }
  }
  ctx.restore();
}

function drawGate(g){
  const gh=18, dv=gDivX(g), sc=g.popScale;
  ctx.save();
  ctx.translate(0,g.y);
  ctx.scale(1,sc);

  // Left
  const lc = g.leftColor===0?COL_RED:COL_BLUE;
  ctx.fillStyle=lc; ctx.globalAlpha=0.5;
  ctx.fillRect(0,-gh,dv,gh*2);
  ctx.globalAlpha=1; ctx.strokeStyle='#fff'; ctx.lineWidth=2;
  ctx.strokeRect(0,-gh,dv,gh*2);
  // Left icon
  ctx.globalAlpha=0.5; ctx.fillStyle='#fff';
  if(g.leftColor===0) drawTri(dv*0.5,0,8);
  else { ctx.beginPath(); ctx.arc(dv*0.5,0,7,0,Math.PI*2); ctx.fill(); }
  ctx.globalAlpha=1;

  // Right
  const rc = g.rightColor===0?COL_RED:COL_BLUE;
  ctx.fillStyle=rc; ctx.globalAlpha=0.5;
  ctx.fillRect(dv,-gh,W-dv,gh*2);
  ctx.globalAlpha=1; ctx.strokeStyle='#fff'; ctx.lineWidth=2;
  ctx.strokeRect(dv,-gh,W-dv,gh*2);
  // Right icon
  ctx.globalAlpha=0.5; ctx.fillStyle='#fff';
  const rx=dv+(W-dv)*0.5;
  if(g.rightColor===0) drawTri(rx,0,8);
  else { ctx.beginPath(); ctx.arc(rx,0,7,0,Math.PI*2); ctx.fill(); }
  ctx.globalAlpha=1;

  // Center divider line
  ctx.strokeStyle='#fff'; ctx.lineWidth=3;
  ctx.beginPath(); ctx.moveTo(dv,-gh); ctx.lineTo(dv,gh); ctx.stroke();

  ctx.restore();
}

function drawTri(x,y,r){
  ctx.beginPath();
  ctx.moveTo(x,y-r);
  ctx.lineTo(x-r*0.866,y+r*0.5);
  ctx.lineTo(x+r*0.866,y+r*0.5);
  ctx.closePath(); ctx.fill();
}

function drawPlayer(){
  const _px=px(), _py=py();
  const col = playerColor===0?COL_RED:COL_BLUE;
  const hl  = playerColor===0?HSL_RED:HSL_BLUE;
  const m = 1+Math.floor(Math.min(3,combo/6));
  const gr = P_R+4+m*3;

  // Glow
  const rg=ctx.createRadialGradient(_px,_py,P_R*0.3,_px,_py,gr);
  rg.addColorStop(0,hsl(hl[0],hl[1],hl[2],0.6));
  rg.addColorStop(0.5,hsl(hl[0],hl[1],hl[2],0.2));
  rg.addColorStop(1,hsl(hl[0],hl[1],hl[2],0));
  ctx.fillStyle=rg;
  ctx.beginPath(); ctx.arc(_px,_py,gr,0,Math.PI*2); ctx.fill();

  // Ball
  ctx.fillStyle=col;
  ctx.beginPath(); ctx.arc(_px,_py,P_R,0,Math.PI*2); ctx.fill();

  // Highlight
  ctx.fillStyle='rgba(255,255,255,0.25)';
  ctx.beginPath(); ctx.arc(_px-3,_py-3,P_R*0.45,0,Math.PI*2); ctx.fill();

  // Icon
  ctx.fillStyle='rgba(255,255,255,0.7)';
  if(playerColor===0) drawTri(_px,_py,7);
  else { ctx.beginPath(); ctx.arc(_px,_py,6,0,Math.PI*2); ctx.fill(); }
}

/* ── Show start overlay (with challenge if present) ── */
function showStart(){
  overlay.classList.remove('hidden');
  overlay.innerHTML =
    '<h1>Color Dash</h1><div class="sub">Pulse Split</div>'+
    (challengeScore?'<div class="challenge">Beat '+challengeScore+'!</div>':'')+
    '<div class="tap">Tap to Start</div><div class="instruction">Tap flips lane + color.</div>';
}

/* ── Boot ── */
updateHUD();
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
