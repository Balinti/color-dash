<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="theme-color" content="#0a0a1a">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Split Lanes">
<meta property="og:description" content="Switch lanes, match colors, pass gates. A fast hyper-casual HTML5 game with color-blind accessible icons.">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Split Lanes">
<meta name="twitter:description" content="Switch lanes, match colors, pass gates. A fast hyper-casual HTML5 game with color-blind accessible icons.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og.png">
<link rel="canonical" href="https://balinti.github.io/color-dash/">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow-x:hidden;background:#05050f;font-family:'Segoe UI',system-ui,sans-serif;color:#fff;touch-action:none;user-select:none;-webkit-user-select:none}
#app{position:relative;width:100%;max-width:420px;height:100dvh;max-height:750px;margin:0 auto;display:flex;flex-direction:column;overflow:hidden}
@media(min-height:751px){#app{top:50%;transform:translateY(-50%)}}
canvas{display:block;width:100%;flex:1;border-radius:8px 8px 0 0}
#seo{max-width:420px;margin:4px auto;padding:6px 12px;font-size:11px;color:#667;line-height:1.4;text-align:center}
#seo summary{cursor:pointer;color:#889;font-size:12px}
#seo p{margin-top:4px}
</style>
</head>
<body>
<div id="app"><canvas id="gc"></canvas></div>
<details id="seo">
<summary>About Color Dash</summary>
<p>Color Dash is a free hyper-casual HTML5 game. Tap or press Space/Enter to switch lanes.
Match your runner's color and icon to pass through gates. Each color is paired with a distinct
pattern (triangle-stripes, dots, chevrons) for color-blind accessibility. Speed increases as you
score. Collect paint chips to change color and chase high combos!</p>
</details>
<script>
'use strict';
(()=>{
/* ===== CANVAS SETUP ===== */
const cv=document.getElementById('gc');
const cx=cv.getContext('2d');
const app=document.getElementById('app');
let W,H,dpr,safeBottom=80;

function resize(){
  const r=app.getBoundingClientRect();
  dpr=Math.min(window.devicePixelRatio||1,2);
  W=r.width; H=r.height-safeBottom;
  cv.width=W*dpr; cv.height=H*dpr;
  cv.style.width=W+'px'; cv.style.height=H+'px';
  cx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize',resize);
resize();

/* ===== CONSTANTS ===== */
const LANE_W=()=>W*0.38;
const LANE_X=(i)=>W/2+(i===0?-1:1)*(W*0.145);
const RUNNER_R=18;
const RUNNER_Y=()=>H-60;
const GATE_W=()=>W*0.3;
const GATE_H=36;
const PICKUP_R=14;
const MAX_PARTICLES=220;
const INV_TIME=850;
const SLOWMO_TIME=180;

/* ===== PAINT TYPES ===== */
// 3 distinct colors with patterns: triangleStripes, dots, chevrons
const PAINTS=[
  {h:0,  s:75,l:55, name:'Red',    pattern:'triangles'}, // red - triangle stripes
  {h:210,s:80,l:55, name:'Blue',   pattern:'dots'},      // blue - dots
  {h:130,s:70,l:48, name:'Green',  pattern:'chevrons'},  // green - chevrons
];

/* ===== GAME STATE ===== */
let state='start';
let score,best,hearts,combo,comboTimer;
let lane; // 0=left, 1=right
let paintIdx; // index into PAINTS
let speed,baseSpeed,distTraveled,nextSpawnDist;
let gates,pickups,particles;
let invTimer,invFlash;
let shakeX,shakeY,shakeMag,shakeDecay;
let slowMoTimer,slowMoFactor;
let flashAlpha; // red damage flash
let sparkleTrail; // array of sparkle positions
let wildAvailable;
let hueShift; // background hue cycle

best=parseInt(localStorage.getItem('cd_best'))||0;

function initGame(){
  score=0; hearts=2; combo=0; comboTimer=0;
  lane=0; paintIdx=0;
  baseSpeed=2.2; speed=baseSpeed;
  distTraveled=0; nextSpawnDist=200;
  gates=[]; pickups=[]; particles=[];
  invTimer=0; invFlash=0;
  shakeX=0; shakeY=0; shakeMag=0; shakeDecay=0.9;
  slowMoTimer=0; slowMoFactor=1;
  flashAlpha=0;
  sparkleTrail=[];
  wildAvailable=false;
  hueShift=0;
  state='playing';
}

/* ===== DRAWING HELPERS ===== */
function hsl(h,s,l,a){return a!==undefined?`hsla(${h},${s}%,${l}%,${a})`:`hsl(${h},${s}%,${l}%)`}

function drawPattern(x,y,r,paint,ctx){
  ctx=ctx||cx;
  const p=paint.pattern;
  ctx.save();
  ctx.translate(x,y);
  ctx.strokeStyle='#fff';
  ctx.fillStyle='#fff';
  ctx.lineWidth=2;
  if(p==='triangles'){
    // three small triangles
    for(let i=0;i<3;i++){
      const a=(i/3)*Math.PI*2-Math.PI/2;
      const d=r*0.45;
      const tx=Math.cos(a)*d, ty=Math.sin(a)*d;
      const s=r*0.28;
      ctx.beginPath();
      ctx.moveTo(tx,ty-s);
      ctx.lineTo(tx-s*0.85,ty+s*0.6);
      ctx.lineTo(tx+s*0.85,ty+s*0.6);
      ctx.closePath();
      ctx.fill();
    }
  }else if(p==='dots'){
    // ring of dots
    for(let i=0;i<5;i++){
      const a=(i/5)*Math.PI*2-Math.PI/2;
      const d=r*0.48;
      ctx.beginPath();
      ctx.arc(Math.cos(a)*d,Math.sin(a)*d,r*0.15,0,Math.PI*2);
      ctx.fill();
    }
  }else if(p==='chevrons'){
    // two chevrons
    ctx.lineWidth=2.5;
    for(let i=-1;i<=1;i+=2){
      const oy=i*r*0.22;
      ctx.beginPath();
      ctx.moveTo(-r*0.4,oy-r*0.2);
      ctx.lineTo(0,oy+r*0.15);
      ctx.lineTo(r*0.4,oy-r*0.2);
      ctx.stroke();
    }
  }
  ctx.restore();
}

function drawRunner(x,y,r,paint,ghost){
  cx.save();
  cx.globalAlpha=ghost?0.35:1;
  // outer white ring
  cx.beginPath();
  cx.arc(x,y,r+3,0,Math.PI*2);
  cx.fillStyle='#fff';
  cx.fill();
  // colored circle
  cx.beginPath();
  cx.arc(x,y,r,0,Math.PI*2);
  cx.fillStyle=hsl(paint.h,paint.s,paint.l);
  cx.fill();
  // pattern icon
  drawPattern(x,y,r,paint);
  cx.restore();
}

function drawGate(g){
  const gw=GATE_W(), gh=GATE_H;
  const x=LANE_X(g.lane)-gw/2;
  const paint=PAINTS[g.paintIdx];
  cx.save();
  // white outline
  cx.fillStyle='#fff';
  cx.beginPath();
  roundRect(cx,x-3,g.y-3,gw+6,gh+6,8);
  cx.fill();
  // colored gate body
  cx.fillStyle=hsl(paint.h,paint.s,paint.l,0.85);
  cx.beginPath();
  roundRect(cx,x,g.y,gw,gh,6);
  cx.fill();
  // pattern on gate center
  drawPattern(LANE_X(g.lane),g.y+gh/2,gh*0.38,paint);
  // label
  cx.fillStyle='#fff';
  cx.font='bold 11px system-ui';
  cx.textAlign='center';
  cx.textBaseline='middle';
  cx.fillText(paint.name.toUpperCase(),LANE_X(g.lane),g.y+gh/2+gh*0.01);
  cx.restore();
}

function drawPickup(p){
  const paint=p.wild?{h:(Date.now()/8)%360,s:80,l:60,pattern:'dots',name:'WILD'}:PAINTS[p.paintIdx];
  cx.save();
  // white outline
  cx.beginPath();
  cx.arc(p.x,p.y,PICKUP_R+3,0,Math.PI*2);
  cx.fillStyle='#fff';
  cx.fill();
  // paint chip
  cx.beginPath();
  cx.arc(p.x,p.y,PICKUP_R,0,Math.PI*2);
  if(p.wild){
    const grad=cx.createRadialGradient(p.x,p.y,0,p.x,p.y,PICKUP_R);
    grad.addColorStop(0,hsl((Date.now()/8)%360,90,70));
    grad.addColorStop(1,hsl(((Date.now()/8)+60)%360,80,50));
    cx.fillStyle=grad;
  }else{
    cx.fillStyle=hsl(paint.h,paint.s,paint.l);
  }
  cx.fill();
  // pattern
  drawPattern(p.x,p.y,PICKUP_R*0.85,paint);
  // pulsing glow
  cx.beginPath();
  cx.arc(p.x,p.y,PICKUP_R+5+Math.sin(Date.now()/200)*3,0,Math.PI*2);
  cx.strokeStyle=hsl(paint.h,paint.s,paint.l,0.3);
  cx.lineWidth=2;
  cx.stroke();
  cx.restore();
}

function roundRect(ctx,x,y,w,h,r){
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
}

/* ===== PARTICLES ===== */
function spawnParticles(x,y,count,paintH,icon){
  for(let i=0;i<count&&particles.length<MAX_PARTICLES;i++){
    const a=Math.random()*Math.PI*2;
    const v=1.5+Math.random()*3;
    particles.push({
      x,y,
      vx:Math.cos(a)*v,
      vy:Math.sin(a)*v-1,
      life:1,
      decay:0.015+Math.random()*0.02,
      size:2+Math.random()*4,
      h:paintH+Math.random()*30-15,
      icon:icon||null
    });
  }
}

function spawnSparkle(x,y){
  sparkleTrail.push({x:x+Math.random()*10-5,y,life:1,size:2+Math.random()*3,h:60+Math.random()*40});
}

function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx*dt;
    p.y+=p.vy*dt;
    p.vy+=0.05*dt;
    p.life-=p.decay*dt;
    if(p.life<=0) particles.splice(i,1);
  }
  for(let i=sparkleTrail.length-1;i>=0;i--){
    sparkleTrail[i].life-=0.03*dt;
    sparkleTrail[i].y+=0.5*dt;
    if(sparkleTrail[i].life<=0) sparkleTrail.splice(i,1);
  }
}

function drawParticles(){
  for(const p of particles){
    cx.save();
    cx.globalAlpha=p.life;
    cx.fillStyle=hsl(p.h,80,60);
    cx.beginPath();
    cx.arc(p.x,p.y,p.size*p.life,0,Math.PI*2);
    cx.fill();
    cx.restore();
  }
  for(const s of sparkleTrail){
    cx.save();
    cx.globalAlpha=s.life*0.7;
    cx.fillStyle=hsl(s.h,90,80);
    cx.beginPath();
    const sz=s.size*s.life;
    // draw star shape
    cx.translate(s.x,s.y);
    for(let i=0;i<4;i++){
      cx.rotate(Math.PI/4);
      cx.fillRect(-sz*0.15,-sz,sz*0.3,sz*2);
    }
    cx.restore();
  }
}

/* ===== SHAKE ===== */
function triggerShake(mag){
  shakeMag=Math.max(shakeMag,mag);
}

function updateShake(dt){
  if(shakeMag>0.5){
    shakeX=(Math.random()-0.5)*shakeMag*2;
    shakeY=(Math.random()-0.5)*shakeMag*2;
    shakeMag*=Math.pow(shakeDecay,dt);
  }else{
    shakeX=shakeY=shakeMag=0;
  }
}

/* ===== SPAWNING ===== */
function spawnGate(laneIdx,pIdx){
  gates.push({lane:laneIdx,paintIdx:pIdx,y:-GATE_H,scored:false});
}

function spawnPickup(laneIdx,pIdx,wild){
  const x=LANE_X(laneIdx);
  pickups.push({x,y:-PICKUP_R*2,lane:laneIdx,paintIdx:pIdx,wild:!!wild});
}

function spawnWave(){
  const diff=Math.min(score,120)/120; // 0..1 difficulty
  const r=Math.random();

  if(r<0.35){
    // single gate in random lane
    const l=Math.random()<0.5?0:1;
    const p=Math.floor(Math.random()*3);
    spawnGate(l,p);
    // sometimes put a pickup in the other lane
    if(Math.random()<0.5){
      const otherPaints=[0,1,2].filter(x=>x!==paintIdx);
      spawnPickup(1-l,otherPaints[Math.floor(Math.random()*otherPaints.length)],false);
    }
  }else if(r<0.55+diff*0.15){
    // paired gates: one in each lane, only one matches
    const match=Math.random()<0.5?0:1;
    spawnGate(match,paintIdx);
    const wrong=[0,1,2].filter(x=>x!==paintIdx);
    spawnGate(1-match,wrong[Math.floor(Math.random()*wrong.length)]);
  }else if(r<0.75){
    // pickup only
    const l=Math.random()<0.5?0:1;
    const newP=Math.floor(Math.random()*3);
    const isWild=wildAvailable&&Math.random()<0.12;
    spawnPickup(l,newP,isWild);
  }else{
    // gate + pickup in same or different lane
    const gl=Math.random()<0.5?0:1;
    const gp=Math.floor(Math.random()*3);
    spawnGate(gl,gp);
    const pl=Math.random()<0.5?gl:1-gl;
    const pp=Math.floor(Math.random()*3);
    spawnPickup(pl,pp,false);
  }
}

/* ===== COLLISION ===== */
function circleRect(cx2,cy,cr,rx,ry,rw,rh){
  const nx=Math.max(rx,Math.min(cx2,rx+rw));
  const ny=Math.max(ry,Math.min(cy,ry+rh));
  const dx=cx2-nx,dy=cy-ny;
  return dx*dx+dy*dy<cr*cr;
}

function circleCircle(x1,y1,r1,x2,y2,r2){
  const dx=x1-x2,dy=y1-y2;
  return dx*dx+dy*dy<(r1+r2)*(r1+r2);
}

/* ===== INPUT ===== */
function switchLane(){
  if(state==='start'){initGame();return}
  if(state==='gameover'){state='start';return}
  lane=1-lane;
}

window.addEventListener('pointerdown',e=>{
  e.preventDefault();
  switchLane();
});
window.addEventListener('keydown',e=>{
  if(e.code==='Space'||e.code==='Enter'){
    e.preventDefault();
    switchLane();
  }
});

/* ===== HUD ===== */
function drawHUD(){
  cx.save();
  // Score
  cx.fillStyle='#fff';
  cx.font='bold 22px system-ui';
  cx.textAlign='center';
  cx.fillText(score,W/2,32);
  // Best
  cx.font='11px system-ui';
  cx.fillStyle='rgba(255,255,255,0.5)';
  cx.fillText('BEST: '+best,W/2,48);
  // Hearts
  cx.textAlign='left';
  for(let i=0;i<2;i++){
    const hx=12+i*26, hy=14;
    cx.fillStyle=i<hearts?'#ff4466':'rgba(255,255,255,0.15)';
    cx.font='18px system-ui';
    cx.fillText('\u2665',hx,hy+16);
  }
  // Combo
  if(combo>1){
    cx.textAlign='right';
    cx.fillStyle=hsl(45,90,65);
    cx.font='bold 14px system-ui';
    cx.fillText('x'+combo+' COMBO',W-12,28);
  }
  // Combo bar
  if(combo>0){
    const bw=60, bh=4;
    const bx=W-12-bw, by=34;
    cx.fillStyle='rgba(255,255,255,0.1)';
    cx.fillRect(bx,by,bw,bh);
    const fill=Math.min(comboTimer/3000,1);
    cx.fillStyle=hsl(45,80,55);
    cx.fillRect(bx,by,bw*fill,bh);
  }
  cx.restore();
}

/* ===== SCREENS ===== */
function drawStart(){
  // Background
  const grad=cx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,'#0a0a2e');
  grad.addColorStop(1,'#050518');
  cx.fillStyle=grad;
  cx.fillRect(0,0,W,H);

  // Decorative lanes
  drawLanes(0.3);

  // Title
  cx.save();
  cx.textAlign='center';
  cx.fillStyle='#fff';
  cx.font='bold 34px system-ui';
  cx.fillText('COLOR DASH',W/2,H*0.22);
  cx.font='14px system-ui';
  cx.fillStyle='rgba(255,255,255,0.5)';
  cx.fillText('SPLIT LANES',W/2,H*0.22+26);

  // Color swatches preview
  const sw=36;
  for(let i=0;i<3;i++){
    const px=W/2+(i-1)*(sw+16);
    const py=H*0.4;
    cx.beginPath();
    cx.arc(px,py,sw/2+2,0,Math.PI*2);
    cx.fillStyle='#fff';
    cx.fill();
    cx.beginPath();
    cx.arc(px,py,sw/2,0,Math.PI*2);
    cx.fillStyle=hsl(PAINTS[i].h,PAINTS[i].s,PAINTS[i].l);
    cx.fill();
    drawPattern(px,py,sw/2*0.85,PAINTS[i]);
  }

  // Instructions
  cx.fillStyle='rgba(255,255,255,0.6)';
  cx.font='13px system-ui';
  cx.fillText('Tap / Space / Enter to switch lanes',W/2,H*0.54);
  cx.fillText('Match your color to pass through gates',W/2,H*0.54+22);
  cx.fillText('Collect paint chips to change color',W/2,H*0.54+44);

  cx.font='bold 16px system-ui';
  cx.fillStyle='#fff';
  cx.fillText('TAP TO START',W/2,H*0.76);

  if(best>0){
    cx.font='13px system-ui';
    cx.fillStyle='rgba(255,255,255,0.4)';
    cx.fillText('Best: '+best,W/2,H*0.76+28);
  }
  cx.restore();
}

function drawGameOver(){
  cx.save();
  cx.fillStyle='rgba(0,0,0,0.7)';
  cx.fillRect(0,0,W,H);
  cx.textAlign='center';
  cx.fillStyle='#ff4466';
  cx.font='bold 30px system-ui';
  cx.fillText('GAME OVER',W/2,H*0.32);
  cx.fillStyle='#fff';
  cx.font='bold 48px system-ui';
  cx.fillText(score,W/2,H*0.45);
  cx.font='14px system-ui';
  cx.fillStyle='rgba(255,255,255,0.5)';
  cx.fillText('SCORE',W/2,H*0.45+22);
  if(score>=best){
    cx.fillStyle=hsl(45,90,65);
    cx.font='bold 15px system-ui';
    cx.fillText('\u2605 NEW BEST! \u2605',W/2,H*0.45+48);
  }else{
    cx.fillStyle='rgba(255,255,255,0.4)';
    cx.font='13px system-ui';
    cx.fillText('Best: '+best,W/2,H*0.45+48);
  }
  cx.fillStyle='#fff';
  cx.font='bold 15px system-ui';
  cx.fillText('TAP TO CONTINUE',W/2,H*0.72);
  cx.restore();
}

/* ===== LANE DRAWING ===== */
function drawLanes(alpha){
  cx.save();
  cx.globalAlpha=alpha||1;
  // Lane divider
  cx.setLineDash([12,12]);
  cx.strokeStyle='rgba(255,255,255,0.15)';
  cx.lineWidth=2;
  cx.beginPath();
  cx.moveTo(W/2,-10);
  cx.lineTo(W/2,H+10);
  cx.stroke();
  cx.setLineDash([]);
  // Lane edges
  const lx=W/2-W*0.32, rx=W/2+W*0.32;
  cx.strokeStyle='rgba(255,255,255,0.08)';
  cx.lineWidth=2;
  cx.beginPath(); cx.moveTo(lx,0); cx.lineTo(lx,H); cx.stroke();
  cx.beginPath(); cx.moveTo(rx,0); cx.lineTo(rx,H); cx.stroke();
  // Scrolling road markers
  const markerSpacing=60;
  const offset=(distTraveled*15)%markerSpacing;
  cx.fillStyle='rgba(255,255,255,0.06)';
  for(let y=-markerSpacing+offset;y<H;y+=markerSpacing){
    cx.fillRect(lx+4,y,6,20);
    cx.fillRect(rx-10,y,6,20);
  }
  cx.restore();
}

/* ===== MAIN UPDATE ===== */
let lastTime=0;
function update(ts){
  const rawDt=lastTime?Math.min(ts-lastTime,50):16;
  lastTime=ts;
  const dt=(rawDt/16.67)*(state==='playing'?slowMoFactor:1);

  if(state==='playing'){
    hueShift=(hueShift+0.15*dt)%360;

    // Speed ramp
    speed=baseSpeed+score*0.025;
    speed=Math.min(speed,6.5);
    wildAvailable=score>=80;

    // Distance tracking for spawning
    distTraveled+=speed*dt;

    // Spawn
    nextSpawnDist-=speed*dt;
    if(nextSpawnDist<=0){
      spawnWave();
      // Distance between spawns decreases slightly with difficulty but stays readable
      const minGap=Math.max(120,200-score*0.5);
      nextSpawnDist=minGap+Math.random()*80;
    }

    // Invulnerability
    if(invTimer>0){
      invTimer-=rawDt;
      invFlash+=dt*0.3;
    }

    // Slow-mo
    if(slowMoTimer>0){
      slowMoTimer-=rawDt;
      slowMoFactor=0.35;
    }else{
      slowMoFactor=1;
    }

    // Flash decay
    if(flashAlpha>0) flashAlpha=Math.max(0,flashAlpha-0.03*dt);

    // Combo timer
    if(combo>0){
      comboTimer+=rawDt;
      if(comboTimer>4000){combo=0;comboTimer=0;}
    }

    const ry=RUNNER_Y();
    const rx=LANE_X(lane);

    // Update gates
    for(let i=gates.length-1;i>=0;i--){
      const g=gates[i];
      g.y+=speed*dt;
      const gw=GATE_W();
      const gx=LANE_X(g.lane)-gw/2;

      // Check collision with runner
      if(!g.scored && g.lane===lane && circleRect(rx,ry,RUNNER_R,gx,g.y,gw,GATE_H)){
        g.scored=true;
        if(g.paintIdx===paintIdx){
          // Correct gate
          const comboMult=1+Math.floor(combo/3)*0.5;
          const baseScore=1;
          // Perfect pass bonus: check if runner is well-centered
          const centerDist=Math.abs(rx-LANE_X(g.lane));
          const perfect=centerDist<8;
          const bonus=perfect?1:0;
          score+=Math.floor(baseScore*comboMult)+bonus;
          combo++;
          comboTimer=0;
          spawnParticles(rx,ry,perfect?25:12,PAINTS[paintIdx].h);
          if(perfect){
            triggerShake(3);
            for(let s=0;s<6;s++) spawnSparkle(rx,ry);
          }else{
            triggerShake(1.5);
          }
        }else{
          // Wrong gate
          if(invTimer<=0){
            hearts--;
            combo=0; comboTimer=0;
            invTimer=INV_TIME;
            invFlash=0;
            flashAlpha=0.6;
            triggerShake(10);
            slowMoTimer=SLOWMO_TIME;
            spawnParticles(rx,ry,18,0);
            if(hearts<=0){
              gameOver();
            }
          }
        }
      }
      // Also mark scored if gate passes below without collision (different lane)
      if(!g.scored && g.y>ry+RUNNER_R+GATE_H){
        g.scored=true;
      }
      // Remove off-screen
      if(g.y>H+50) gates.splice(i,1);
    }

    // Update pickups
    for(let i=pickups.length-1;i>=0;i--){
      const p=pickups[i];
      p.y+=speed*dt;
      if(p.lane===lane && circleCircle(rx,ry,RUNNER_R,p.x,p.y,PICKUP_R)){
        if(p.wild){
          // Wild: cycle to next color
          paintIdx=(paintIdx+1)%3;
          spawnParticles(rx,ry,20,(Date.now()/3)%360);
        }else{
          paintIdx=p.paintIdx;
          spawnParticles(rx,ry,10,PAINTS[p.paintIdx].h);
        }
        triggerShake(2);
        pickups.splice(i,1);
        continue;
      }
      if(p.y>H+50) pickups.splice(i,1);
    }

    updateParticles(dt);
    updateShake(dt);
  }

  draw();
  requestAnimationFrame(update);
}

function gameOver(){
  state='gameover';
  if(score>best){
    best=score;
    localStorage.setItem('cd_best',best);
  }
  triggerShake(18);
  const rx=LANE_X(lane);
  spawnParticles(rx,RUNNER_Y(),40,0);
}

/* ===== MAIN DRAW ===== */
function draw(){
  cx.save();

  if(state==='start'){
    drawStart();
    cx.restore();
    return;
  }

  // Apply shake
  cx.translate(shakeX,shakeY);

  // Background
  const bgGrad=cx.createLinearGradient(0,0,0,H);
  bgGrad.addColorStop(0,hsl(230+hueShift*0.05,40,8));
  bgGrad.addColorStop(1,hsl(250+hueShift*0.05,30,4));
  cx.fillStyle=bgGrad;
  cx.fillRect(-20,-20,W+40,H+40);

  // Draw lanes
  drawLanes(1);

  // Draw gates
  for(const g of gates) drawGate(g);

  // Draw pickups
  for(const p of pickups) drawPickup(p);

  // Draw sparkle trail
  drawParticles();

  // Draw runner
  const rx=LANE_X(lane);
  const ry=RUNNER_Y();
  const paint=PAINTS[paintIdx];

  // Runner shadow
  cx.save();
  cx.globalAlpha=0.2;
  cx.beginPath();
  cx.ellipse(rx,ry+RUNNER_R+4,RUNNER_R*1.1,4,0,0,Math.PI*2);
  cx.fillStyle='#000';
  cx.fill();
  cx.restore();

  // Runner (flash during invulnerability)
  const showRunner=invTimer<=0||Math.sin(invFlash*10)>0;
  if(showRunner){
    drawRunner(rx,ry,RUNNER_R,paint,false);
  }

  // Ghost in other lane (faint)
  drawRunner(LANE_X(1-lane),ry,RUNNER_R*0.6,paint,true);

  // Damage flash vignette
  if(flashAlpha>0){
    cx.save();
    const vg=cx.createRadialGradient(W/2,H/2,H*0.2,W/2,H/2,H*0.7);
    vg.addColorStop(0,'rgba(255,0,0,0)');
    vg.addColorStop(1,`rgba(255,30,30,${flashAlpha})`);
    cx.fillStyle=vg;
    cx.fillRect(-20,-20,W+40,H+40);
    cx.restore();
  }

  // HUD
  drawHUD();

  // Lane indicator arrows at bottom
  cx.save();
  cx.globalAlpha=0.25;
  cx.fillStyle='#fff';
  cx.font='18px system-ui';
  cx.textAlign='center';
  cx.fillText('\u25C0',LANE_X(0),H-12);
  cx.fillText('\u25B6',LANE_X(1),H-12);
  cx.restore();

  // Game over overlay
  if(state==='gameover') drawGameOver();

  cx.restore();
}

/* ===== KICK OFF ===== */
requestAnimationFrame(update);
})();
</script>
</body>
</html>
