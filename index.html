<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="theme-color" content="#1a1a2e">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og-image.png">
<meta name="twitter:card" content="summary">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@type":"VideoGame",
  "name":"Color Dash",
  "description":"Hyper-casual HTML5 game. Swap lanes and cycle signals to pass through gates. Tap to sync!",
  "genre":"Casual",
  "gamePlatform":"Web Browser",
  "applicationCategory":"Game",
  "operatingSystem":"Any",
  "playMode":"SinglePlayer",
  "url":"https://balinti.github.io/color-dash/",
  "author":{"@type":"Person","name":"Balinti"}
}
</script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow-x:hidden;background:#0f0f1a;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#ccc}
body{display:flex;flex-direction:column;align-items:center;min-height:100vh;min-height:100dvh}
#wrap{width:100%;max-width:420px;flex:0 0 auto}
canvas{display:block;width:100%;touch-action:none;cursor:pointer}
#seo{max-width:420px;width:100%;padding:12px 16px;font-size:12px;line-height:1.6;color:#777;text-align:center}
#seo h2{font-size:14px;color:#999;margin-bottom:4px}
</style>
</head>
<body>
<div id="wrap"><canvas id="c"></canvas></div>
<section id="seo">
<h2>Color Dash: Dash Sync</h2>
<p>A hyper-casual HTML5 browser game. Tap to swap lanes and cycle your signal shape. Match the gate&rsquo;s lane and signal to score. Perfect timing earns bonus points and streak multipliers. Three hearts &mdash; three mistakes allowed. How far can you dash?</p>
</section>
<script>
'use strict';
(()=>{

/* ====== CANVAS SETUP ====== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, dpr;

function resize() {
  dpr = window.devicePixelRatio || 1;
  const maxW = 420, maxH = 750;
  const w = Math.min(window.innerWidth, maxW);
  const h = Math.min(window.innerHeight, maxH);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  W = canvas.width = Math.round(w * dpr);
  H = canvas.height = Math.round(h * dpr);
}
window.addEventListener('resize', resize);
resize();

/* ====== CONSTANTS ====== */
const LS_KEY = 'cdash_sync_hs_v3';
const MAX_HEARTS = 3;
const SIGNAL_COUNT = 3;
const SIG_NAMES = ['Circle', 'Triangle', 'Square'];
const PLAYER_X_FRAC = 0.17;

// Colors
const BG_TOP   = '#1a1a2e';
const BG_BOT   = '#16162a';
const LANE_DIV = '#2e2e48';
const SIG_COL  = ['#4fc3f7', '#ce93d8', '#81c784'];
const HIT_COL  = '#ef5350';
const PERF_COL = '#ffd54f';
const HEART_ON = '#ef5350';
const HEART_OFF= '#333346';
const TXT      = '#e8e8e8';
const DIM      = '#888';

/* ====== STATE ====== */
let state = 'start';
let score, highScore, hearts;
let lane, signal;
let speed, gates, particles, trails;
let streak, multi;
let shakeX, shakeY, shakeDur, shakeAmt;
let hue;
let frame, lastSpawn, spawnInt;
let perfWin, hitWin;
let tutDone;
let playerY, playerTgtY, playerVY;
let toastTxt, toastT;
let shareBounds;
let justTapped;

function loadHS() { try { highScore = parseInt(localStorage.getItem(LS_KEY)) || 0; } catch(e) { highScore = 0; } }
function saveHS() { try { localStorage.setItem(LS_KEY, String(highScore)); } catch(e) {} }
loadHS();

function initGame() {
  score = 0; hearts = MAX_HEARTS;
  lane = 0; signal = 0;
  speed = 2.2;
  gates = []; particles = []; trails = [];
  streak = 0; multi = 1;
  shakeX = 0; shakeY = 0; shakeDur = 0; shakeAmt = 0;
  hue = 200; frame = 0; lastSpawn = -60;
  spawnInt = 110; perfWin = 26; hitWin = 38;
  tutDone = 0;
  playerTgtY = laneY(0); playerY = playerTgtY; playerVY = 0;
  toastTxt = ''; toastT = 0;
  shareBounds = null;
  justTapped = false;
}

function laneY(l) {
  return l === 0 ? H * 0.38 : H * 0.62;
}

function diffTier() {
  if (score < 10) return 0;
  if (score < 25) return 1;
  if (score < 50) return 2;
  if (score < 80) return 3;
  return 4;
}

/* ====== INPUT ====== */
function doTap() {
  if (state === 'start') { state = 'playing'; initGame(); return; }
  if (state === 'gameover') { state = 'start'; return; }
  lane = 1 - lane;
  signal = (signal + 1) % SIGNAL_COUNT;
  playerTgtY = laneY(lane);
  justTapped = true;
}

canvas.addEventListener('pointerdown', e => {
  e.preventDefault();
  if (state === 'gameover' && shareBounds) {
    const r = canvas.getBoundingClientRect();
    const mx = e.clientX - r.left, my = e.clientY - r.top;
    const b = shareBounds;
    if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {
      doShare();
      return;
    }
  }
  doTap();
});
document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); doTap(); }
});

function doShare() {
  const txt = `I scored ${score} in Color Dash: Dash Sync! \u{1F3AE}\nhttps://balinti.github.io/color-dash/`;
  if (navigator.share) {
    navigator.share({ title: 'Color Dash', text: txt }).catch(() => {});
  } else if (navigator.clipboard) {
    navigator.clipboard.writeText(txt).then(() => toast('Copied!')).catch(() => {});
  }
}

function toast(m) { toastTxt = m; toastT = 100; }

/* ====== SPAWN ====== */
function spawnGate() {
  const tier = diffTier();
  let gl, gs, partial = false;

  if (tutDone < 3) {
    if (tutDone === 0) { gl = lane; gs = signal; partial = true; }
    else { gl = 1 - lane; gs = (signal + 1) % SIGNAL_COUNT; }
    tutDone++;
  } else {
    gl = Math.random() < 0.5 ? 0 : 1;
    gs = Math.floor(Math.random() * SIGNAL_COUNT);
    if (tier === 0 && Math.random() < 0.45) {
      partial = true;
      if (Math.random() < 0.5) gs = -1; else gl = -1;
    }
  }

  const g = {
    x: W + 60 * dpr,
    lane: gl,
    signal: gs,
    partial,
    passed: false,
    hit: false,
    minDx: Infinity,
    tele: true,
    locked: false,
    lockDist: 0
  };

  if (tier >= 3 && Math.random() < 0.22 && !partial) {
    g.tele = false;
    g.lockDist = W * 0.38;
  }

  gates.push(g);
  lastSpawn = frame;
}

/* ====== PARTICLES ====== */
function emit(x, y, col, n, spd, burst) {
  for (let i = 0; i < n; i++) {
    const a = Math.random() * Math.PI * 2;
    const s = spd * (0.4 + Math.random() * 0.6);
    particles.push({
      x, y,
      vx: Math.cos(a) * s * dpr,
      vy: Math.sin(a) * s * dpr,
      life: 1,
      dec: 0.016 + Math.random() * 0.02,
      col,
      r: (2 + Math.random() * 2.5) * dpr,
      burst: !!burst
    });
  }
}

function emitTrail(x, y) {
  trails.push({
    x, y: y + (Math.random() - 0.5) * 6 * dpr,
    life: 1, dec: 0.045,
    col: SIG_COL[signal],
    r: (1.2 + Math.random() * 1.8) * dpr,
    sig: signal
  });
}

/* ====== SHAKE ====== */
function shake(amt, dur) { shakeAmt = amt * dpr; shakeDur = dur; }

/* ====== DRAW HELPERS ====== */
function drawSigIcon(x, y, s, sz, col, al) {
  ctx.save();
  ctx.globalAlpha = al != null ? al : 1;
  ctx.strokeStyle = col;
  ctx.fillStyle = col;
  ctx.lineWidth = 2 * dpr;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  if (s === 0) {
    ctx.beginPath(); ctx.arc(x, y, sz, 0, Math.PI * 2); ctx.stroke();
    ctx.fillStyle = col;
    for (let i = 0; i < 3; i++) {
      const a = i * Math.PI * 2 / 3 - Math.PI / 2;
      ctx.beginPath(); ctx.arc(x + Math.cos(a) * sz * 0.42, y + Math.sin(a) * sz * 0.42, sz * 0.13, 0, Math.PI * 2); ctx.fill();
    }
  } else if (s === 1) {
    ctx.beginPath();
    ctx.moveTo(x, y - sz); ctx.lineTo(x + sz * 0.87, y + sz * 0.5); ctx.lineTo(x - sz * 0.87, y + sz * 0.5);
    ctx.closePath(); ctx.stroke();
    ctx.lineWidth = 1.5 * dpr;
    for (let i = -1; i <= 1; i++) {
      const ly = y + i * sz * 0.22 + sz * 0.08;
      const hw = sz * 0.32 * (1.1 - i * 0.2);
      ctx.beginPath(); ctx.moveTo(x - hw, ly); ctx.lineTo(x + hw, ly); ctx.stroke();
    }
  } else {
    const hs = sz * 0.78;
    ctx.strokeRect(x - hs, y - hs, hs * 2, hs * 2);
    ctx.lineWidth = 1.5 * dpr;
    ctx.beginPath();
    ctx.moveTo(x, y - hs); ctx.lineTo(x, y + hs);
    ctx.moveTo(x - hs, y); ctx.lineTo(x + hs, y);
    ctx.stroke();
  }
  ctx.restore();
}

function drawHeart(x, y, sz, on) {
  ctx.fillStyle = on ? HEART_ON : HEART_OFF;
  ctx.beginPath();
  ctx.moveTo(x, y + sz * 0.35);
  ctx.bezierCurveTo(x, y, x - sz, y, x - sz, y + sz * 0.35);
  ctx.bezierCurveTo(x - sz, y + sz * 0.75, x, y + sz * 1.05, x, y + sz * 1.15);
  ctx.bezierCurveTo(x, y + sz * 1.05, x + sz, y + sz * 0.75, x + sz, y + sz * 0.35);
  ctx.bezierCurveTo(x + sz, y, x, y, x, y + sz * 0.35);
  ctx.fill();
}

function rrect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

/* ====== UPDATE ====== */
function update() {
  hue = (hue + 0.25) % 360;

  if (shakeDur > 0) {
    shakeDur--;
    const f = shakeDur / 12;
    shakeX = (Math.random() - 0.5) * shakeAmt * f;
    shakeY = (Math.random() - 0.5) * shakeAmt * f;
  } else { shakeX = 0; shakeY = 0; }

  // toast
  if (toastT > 0) toastT--;

  if (state !== 'playing') return;

  const tier = diffTier();

  // difficulty ramp
  speed = Math.min(5.5, 2.2 + tier * 0.55 + score * 0.009);
  spawnInt = Math.max(52, 110 - tier * 10 - score * 0.3);
  perfWin = Math.max(12, 26 - tier * 2.2);
  hitWin = Math.max(22, 38 - tier * 2.8);

  // player smooth move
  const dy = playerTgtY - playerY;
  playerY += dy * 0.22;
  if (Math.abs(dy) < 0.5) playerY = playerTgtY;

  // spawn
  if (frame - lastSpawn >= spawnInt) {
    spawnGate();
    // double-beat at high score
    if (score >= 80 && Math.random() < 0.28) {
      const gap = Math.max(25, spawnInt * 0.45);
      setTimeout(() => { if (state === 'playing') spawnGate(); }, gap * 16);
    }
  }

  // trail
  const px = W * PLAYER_X_FRAC;
  if (frame % 2 === 0) emitTrail(px, playerY);

  const spx = speed * dpr;

  // gates
  for (let i = gates.length - 1; i >= 0; i--) {
    const g = gates[i];
    g.x -= spx;

    // juke lock-in
    if (!g.tele && !g.locked && g.x < W - g.lockDist) {
      g.tele = true; g.locked = true;
    }

    const dx = g.x - px;
    const adx = Math.abs(dx);
    if (adx < g.minDx) g.minDx = adx;

    // passed the player
    if (!g.passed && !g.hit && dx < -hitWin * dpr) {
      const lOk = g.lane === -1 || lane === g.lane;
      const sOk = g.signal === -1 || signal === g.signal;
      if (lOk && sOk) {
        g.passed = true;
        const perf = g.minDx < perfWin * dpr;
        if (perf) {
          streak++;
          multi = Math.min(5, 1 + Math.floor(streak / 3));
          score += 2 * multi;
          emit(px, playerY, PERF_COL, 22, 4.5, true);
          shake(2.5, 7);
        } else {
          streak = 0; multi = 1;
          score += 1;
          emit(px, playerY, SIG_COL[signal], 8, 2.5, false);
        }
        if (score > highScore) { highScore = score; saveHS(); }
      } else {
        g.hit = true;
        hearts--;
        streak = 0; multi = 1;
        const gy = laneY(g.lane >= 0 ? g.lane : lane);
        emit(g.x, gy, HIT_COL, 16, 3.5, false);
        shake(5, 14);
        if (hearts <= 0) {
          state = 'gameover';
          shake(9, 22);
          emit(px, playerY, HIT_COL, 35, 5.5, true);
        }
      }
    }

    if (g.x < -80 * dpr) gates.splice(i, 1);
  }

  // particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vy += 0.06 * dpr; // slight gravity
    p.life -= p.dec;
    if (p.life <= 0) particles.splice(i, 1);
  }
  for (let i = trails.length - 1; i >= 0; i--) {
    const t = trails[i];
    t.x -= spx * 0.5;
    t.life -= t.dec;
    if (t.life <= 0) trails.splice(i, 1);
  }

  justTapped = false;
}

/* ====== DRAW ====== */
function draw() {
  ctx.save();
  ctx.translate(shakeX, shakeY);

  // background gradient
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, BG_TOP); bg.addColorStop(1, BG_BOT);
  ctx.fillStyle = bg;
  ctx.fillRect(-20, -20, W + 40, H + 40);

  if (state === 'start') drawStart();
  else {
    drawField();
    drawTrails();
    drawGates();
    drawPlayer();
    drawHUD();
    if (state === 'gameover') drawGO();
  }

  drawParts();
  drawToast();

  ctx.restore();
}

/* -- start screen -- */
function drawStart() {
  const cx = W / 2, cy = H / 2;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

  ctx.fillStyle = TXT;
  ctx.font = `bold ${34 * dpr}px 'Segoe UI',system-ui,sans-serif`;
  ctx.fillText('Color Dash', cx, cy - 85 * dpr);

  ctx.fillStyle = `hsl(${hue},65%,68%)`;
  ctx.font = `${15 * dpr}px 'Segoe UI',system-ui,sans-serif`;
  ctx.fillText('Dash Sync', cx, cy - 52 * dpr);

  // icons
  for (let i = 0; i < 3; i++) {
    drawSigIcon(cx + (i - 1) * 50 * dpr, cy - 10 * dpr, i, 14 * dpr, SIG_COL[i], 0.85);
  }

  ctx.fillStyle = DIM;
  ctx.font = `${12 * dpr}px 'Segoe UI',system-ui,sans-serif`;
  ctx.fillText('Tap / Space / Enter', cx, cy + 40 * dpr);
  ctx.fillText('Swap lane + cycle signal', cx, cy + 58 * dpr);
  ctx.fillText('Match the gate to pass!', cx, cy + 76 * dpr);

  if (highScore > 0) {
    ctx.fillStyle = PERF_COL;
    ctx.font = `bold ${14 * dpr}px sans-serif`;
    ctx.fillText('Best: ' + highScore, cx, cy + 108 * dpr);
  }

  const pulse = 0.5 + 0.5 * Math.sin(frame * 0.06);
  ctx.globalAlpha = pulse;
  ctx.fillStyle = TXT;
  ctx.font = `bold ${17 * dpr}px 'Segoe UI',system-ui,sans-serif`;
  ctx.fillText('TAP TO START', cx, cy + 148 * dpr);
  ctx.globalAlpha = 1;
}

/* -- field -- */
function drawField() {
  const mid = (H * 0.38 + H * 0.62) / 2;
  // lane divider
  ctx.strokeStyle = LANE_DIV;
  ctx.lineWidth = 1.5 * dpr;
  ctx.setLineDash([10 * dpr, 10 * dpr]);
  ctx.beginPath(); ctx.moveTo(0, mid); ctx.lineTo(W, mid); ctx.stroke();
  ctx.setLineDash([]);

  // lane edges
  ctx.strokeStyle = 'rgba(50,50,70,0.25)';
  ctx.lineWidth = 1 * dpr;
  const edgeOff = 48 * dpr;
  ctx.beginPath();
  ctx.moveTo(0, H * 0.38 - edgeOff); ctx.lineTo(W, H * 0.38 - edgeOff);
  ctx.moveTo(0, H * 0.62 + edgeOff); ctx.lineTo(W, H * 0.62 + edgeOff);
  ctx.stroke();
}

/* -- trails -- */
function drawTrails() {
  for (const t of trails) {
    ctx.globalAlpha = t.life * 0.45;
    ctx.fillStyle = t.col;
    if (t.sig === 0) {
      ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI * 2); ctx.fill();
    } else if (t.sig === 1) {
      ctx.strokeStyle = t.col; ctx.lineWidth = 1.5 * dpr;
      ctx.beginPath();
      ctx.moveTo(t.x - t.r, t.y - t.r); ctx.lineTo(t.x + t.r * 0.3, t.y); ctx.lineTo(t.x - t.r, t.y + t.r);
      ctx.stroke();
    } else {
      ctx.fillRect(t.x - t.r * 0.5, t.y - t.r * 0.5, t.r, t.r);
    }
  }
  ctx.globalAlpha = 1;
}

/* -- gates -- */
function drawGates() {
  for (const g of gates) {
    if (g.x > W + 50 * dpr || g.x < -60 * dpr) continue;
    const gateH = 52 * dpr;
    const gy = g.lane >= 0 ? laneY(g.lane) : H / 2;

    if (!g.tele) {
      // mystery gate
      ctx.globalAlpha = 0.4;
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 3 * dpr;
      ctx.strokeRect(g.x - 5 * dpr, gy - gateH / 2, 10 * dpr, gateH);
      ctx.fillStyle = '#555';
      ctx.font = `bold ${18 * dpr}px sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('?', g.x, gy);
      ctx.globalAlpha = 1;
      continue;
    }

    const col = g.signal >= 0 ? SIG_COL[g.signal] : '#888';
    const alpha = g.passed ? 0.15 : g.hit ? 0.12 : 0.88;
    ctx.globalAlpha = alpha;

    // vertical bar
    ctx.strokeStyle = col;
    ctx.lineWidth = 3.5 * dpr;
    if (g.lane >= 0) {
      ctx.beginPath(); ctx.moveTo(g.x, gy - gateH / 2); ctx.lineTo(g.x, gy + gateH / 2); ctx.stroke();
      // caps
      ctx.lineWidth = 2.5 * dpr;
      ctx.beginPath();
      ctx.moveTo(g.x - 12 * dpr, gy - gateH / 2); ctx.lineTo(g.x + 12 * dpr, gy - gateH / 2);
      ctx.moveTo(g.x - 12 * dpr, gy + gateH / 2); ctx.lineTo(g.x + 12 * dpr, gy + gateH / 2);
      ctx.stroke();
    } else {
      ctx.beginPath(); ctx.moveTo(g.x, H * 0.22); ctx.lineTo(g.x, H * 0.78); ctx.stroke();
    }

    // icon
    if (g.signal >= 0) {
      drawSigIcon(g.x, gy - gateH / 2 - 17 * dpr, g.signal, 9 * dpr, col, alpha);
    }

    // partial label
    if (g.partial) {
      ctx.fillStyle = 'rgba(255,255,255,0.28)';
      ctx.font = `${8 * dpr}px sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(g.signal === -1 ? 'LANE' : 'SIG', g.x, gy + gateH / 2 + 13 * dpr);
    }

    // glow
    if (!g.passed && !g.hit) {
      const dist = g.x - W * PLAYER_X_FRAC;
      if (dist > 0 && dist < 140 * dpr) {
        const ga = 0.12 * (1 - dist / (140 * dpr));
        ctx.globalAlpha = ga;
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.arc(g.x, gy, 28 * dpr, 0, Math.PI * 2); ctx.fill();
      }
    }
    ctx.globalAlpha = 1;
  }
}

/* -- player -- */
function drawPlayer() {
  const px = W * PLAYER_X_FRAC;
  const py = playerY;
  const r = 14 * dpr;
  const col = SIG_COL[signal];

  // outer glow
  ctx.globalAlpha = 0.18;
  ctx.fillStyle = col;
  ctx.beginPath(); ctx.arc(px, py, r * 2, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1;

  ctx.fillStyle = col;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2.2 * dpr;
  ctx.lineJoin = 'round';

  if (signal === 0) {
    ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.65)';
    for (let i = 0; i < 3; i++) {
      const a = i * Math.PI * 2 / 3 - Math.PI / 2 + frame * 0.025;
      ctx.beginPath(); ctx.arc(px + Math.cos(a) * r * 0.42, py + Math.sin(a) * r * 0.42, r * 0.14, 0, Math.PI * 2); ctx.fill();
    }
  } else if (signal === 1) {
    ctx.beginPath();
    ctx.moveTo(px, py - r); ctx.lineTo(px + r * 0.87, py + r * 0.5); ctx.lineTo(px - r * 0.87, py + r * 0.5);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.strokeStyle = 'rgba(255,255,255,0.45)';
    ctx.lineWidth = 1.5 * dpr;
    for (let i = -1; i <= 1; i++) {
      const sy = py + i * r * 0.23 + r * 0.08;
      ctx.beginPath(); ctx.moveTo(px - r * 0.28, sy); ctx.lineTo(px + r * 0.28, sy); ctx.stroke();
    }
  } else {
    const hs = r * 0.78;
    ctx.fillRect(px - hs, py - hs, hs * 2, hs * 2);
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2.2 * dpr;
    ctx.strokeRect(px - hs, py - hs, hs * 2, hs * 2);
    ctx.strokeStyle = 'rgba(255,255,255,0.45)';
    ctx.lineWidth = 1.5 * dpr;
    ctx.beginPath();
    ctx.moveTo(px, py - hs); ctx.lineTo(px, py + hs);
    ctx.moveTo(px - hs, py); ctx.lineTo(px + hs, py);
    ctx.stroke();
  }
}

/* -- HUD -- */
function drawHUD() {
  ctx.textAlign = 'center'; ctx.textBaseline = 'top';
  ctx.fillStyle = TXT;
  ctx.font = `bold ${24 * dpr}px 'Segoe UI',system-ui,sans-serif`;
  ctx.fillText(String(score), W / 2, 14 * dpr);

  if (multi > 1) {
    ctx.fillStyle = PERF_COL;
    ctx.font = `bold ${13 * dpr}px sans-serif`;
    ctx.fillText('x' + multi, W / 2, 42 * dpr);
  }

  // streak indicator
  if (streak > 0 && streak >= 3) {
    ctx.fillStyle = `hsl(${hue},70%,65%)`;
    ctx.font = `${11 * dpr}px sans-serif`;
    ctx.fillText(streak + ' streak', W / 2, multi > 1 ? 58 * dpr : 42 * dpr);
  }

  // hearts
  for (let i = 0; i < MAX_HEARTS; i++) {
    drawHeart(W - 28 * dpr - i * 24 * dpr, 12 * dpr, 8 * dpr, i < hearts);
  }

  // current state
  drawSigIcon(28 * dpr, 26 * dpr, signal, 9 * dpr, SIG_COL[signal], 0.85);
  ctx.fillStyle = DIM;
  ctx.font = `${9 * dpr}px sans-serif`;
  ctx.textAlign = 'left'; ctx.textBaseline = 'top';
  ctx.fillText(SIG_NAMES[signal], 42 * dpr, 20 * dpr);
  ctx.fillText(lane === 0 ? 'Top' : 'Bot', 42 * dpr, 32 * dpr);
}

/* -- game over -- */
function drawGO() {
  ctx.fillStyle = 'rgba(12,12,22,0.78)';
  ctx.fillRect(-20, -20, W + 40, H + 40);

  const cx = W / 2, cy = H / 2;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

  ctx.fillStyle = HIT_COL;
  ctx.font = `bold ${30 * dpr}px 'Segoe UI',system-ui,sans-serif`;
  ctx.fillText('GAME OVER', cx, cy - 72 * dpr);

  ctx.fillStyle = TXT;
  ctx.font = `bold ${22 * dpr}px sans-serif`;
  ctx.fillText('Score: ' + score, cx, cy - 28 * dpr);

  if (score > 0 && score >= highScore) {
    ctx.fillStyle = PERF_COL;
    ctx.font = `bold ${15 * dpr}px sans-serif`;
    ctx.fillText('NEW BEST!', cx, cy + 2 * dpr);
  }

  ctx.fillStyle = DIM;
  ctx.font = `${13 * dpr}px sans-serif`;
  ctx.fillText('Best: ' + highScore, cx, cy + 28 * dpr);

  // share btn
  const bw = 110 * dpr, bh = 34 * dpr;
  const bx = cx - bw / 2, by = cy + 50 * dpr;
  ctx.fillStyle = `hsl(${hue},55%,48%)`;
  rrect(bx, by, bw, bh, 6 * dpr); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${13 * dpr}px sans-serif`;
  ctx.fillText('SHARE', cx, cy + 67 * dpr);
  shareBounds = { x: bx / dpr, y: by / dpr, w: bw / dpr, h: bh / dpr };

  const pulse = 0.45 + 0.55 * Math.sin(frame * 0.06);
  ctx.globalAlpha = pulse;
  ctx.fillStyle = TXT;
  ctx.font = `${14 * dpr}px sans-serif`;
  ctx.fillText('TAP TO RESTART', cx, cy + 115 * dpr);
  ctx.globalAlpha = 1;
}

/* -- particles -- */
function drawParts() {
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.col;
    const sz = p.r * p.life;
    ctx.beginPath(); ctx.arc(p.x, p.y, sz, 0, Math.PI * 2); ctx.fill();
    if (p.burst) {
      ctx.globalAlpha = p.life * 0.4;
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(p.x, p.y, sz * 0.4, 0, Math.PI * 2); ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

function drawToast() {
  if (toastT <= 0) return;
  ctx.globalAlpha = Math.min(1, toastT / 18);
  ctx.fillStyle = 'rgba(255,255,255,0.92)';
  ctx.font = `bold ${13 * dpr}px sans-serif`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(toastTxt, W / 2, H * 0.84);
  ctx.globalAlpha = 1;
}

/* ====== MAIN LOOP ====== */
frame = 0;
function loop() {
  frame++;
  update();
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

})();
</script>
</body>
</html>