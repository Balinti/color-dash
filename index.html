<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="robots" content="index, follow">
<link rel="canonical" href="https://balinti.github.io/color-dash/">
<meta name="theme-color" content="#1a1a2e">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og.jpg">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#fff;touch-action:none;user-select:none;-webkit-user-select:none}
#game-container{position:relative;max-width:420px;max-height:750px;width:100%;height:100vh;margin:0 auto;padding-bottom:70px;overflow:hidden}
canvas{display:block;width:100%;height:100%}
#hud{position:absolute;top:0;left:0;right:0;display:flex;justify-content:space-between;align-items:flex-start;padding:20px 18px 0;pointer-events:none;z-index:2}
#hud .score{font-size:30px;font-weight:800;text-shadow:0 2px 10px rgba(0,0,0,.6)}
#hud .combo{font-size:13px;font-weight:600;opacity:.85;margin-top:2px;text-shadow:0 1px 4px rgba(0,0,0,.5)}
#hud .right-col{text-align:right}
#hud .shield-indicator{font-size:16px;text-shadow:0 1px 4px rgba(0,0,0,.5)}
#hud .high-score{font-size:12px;opacity:.5;margin-top:2px}
.overlay{position:absolute;top:0;left:0;right:0;bottom:70px;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:10;pointer-events:auto;background:rgba(10,10,26,.88);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px)}
.overlay.hidden{display:none;pointer-events:none}
.overlay h1{font-size:38px;font-weight:800;letter-spacing:-1.5px;background:linear-gradient(135deg,#6366f1,#ec4899,#f59e0b);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
.overlay h2{font-size:24px;font-weight:700;margin-bottom:4px}
.overlay .subtitle{font-size:15px;opacity:.6;margin-top:4px;margin-bottom:28px;font-weight:400}
.overlay .score-display{font-size:52px;font-weight:800;margin:8px 0 4px}
.overlay .stats{font-size:13px;opacity:.55;margin-bottom:22px}
.overlay .new-best{color:#fbbf24;font-size:14px;font-weight:700;margin-bottom:8px}
.overlay .btn{padding:14px 40px;font-size:16px;font-weight:700;border:none;border-radius:14px;cursor:pointer;background:linear-gradient(135deg,#6366f1,#8b5cf6);color:#fff;margin:5px;transition:transform .1s,box-shadow .1s;box-shadow:0 4px 20px rgba(99,102,241,.35);letter-spacing:.3px}
.overlay .btn:hover{box-shadow:0 6px 25px rgba(99,102,241,.5)}
.overlay .btn:active{transform:scale(.96)}
.overlay .btn.secondary{background:rgba(255,255,255,.1);box-shadow:none;font-size:13px;padding:10px 26px;border-radius:10px}
.overlay .btn.secondary:hover{background:rgba(255,255,255,.15)}
.overlay .hint{font-size:11px;opacity:.35;margin-top:18px;line-height:1.4;max-width:260px;text-align:center}
.overlay .new-best.hidden{display:none}
#seo-block{max-width:420px;margin:20px auto;padding:18px 22px;color:#777;font-size:13px;line-height:1.7;background:#0f0f1a;border-radius:10px;display:none}
#seo-block strong{color:#aaa}
@media(min-height:820px){#seo-block{display:block}}
</style>
</head>
<body>
<div id="game-container">
  <canvas id="gc"></canvas>
  <div id="hud">
    <div>
      <div class="score" id="hud-score">0</div>
      <div class="combo" id="hud-combo"></div>
    </div>
    <div class="right-col">
      <div class="shield-indicator" id="hud-shield"></div>
      <div class="high-score" id="hud-high"></div>
    </div>
  </div>

  <div class="overlay" id="start-screen">
    <h1>Color Dash</h1>
    <div class="subtitle">Split Decision</div>
    <button class="btn" id="btn-start">Play</button>
    <div class="hint">
      Tap or press Space to switch lanes<br>
      Match your color to the gate<br>
      Your color changes to whatever you pass
    </div>
    <div style="font-size:11px;opacity:.3;margin-top:14px" id="start-high"></div>
  </div>

  <div class="overlay hidden" id="gameover-screen">
    <h2>Game Over</h2>
    <div class="score-display" id="go-score">0</div>
    <div class="new-best hidden" id="go-newbest">New Best!</div>
    <div class="stats" id="go-stats"></div>
    <button class="btn" id="btn-retry">Play Again</button>
    <button class="btn secondary" id="btn-share">Challenge a Friend</button>
  </div>
</div>

<div id="seo-block">
  <strong>How to Play Color Dash</strong><br>
  Tap or press Space/Enter to switch between left and right lanes. Match your runner&rsquo;s color and symbol to the incoming gate. Your color changes to whatever gate you pass through, so plan ahead! Build combos by staying in one lane, and aim for perfect near-miss switches for bonus points.<br><br>
  <strong>Tips</strong><br>
  &bull; Start slow: learn the color&ndash;symbol pairs (Red = Triangle, Blue = Circle, Yellow = Stripe).<br>
  &bull; Watch upcoming gate colors to plan your lane switches.<br>
  &bull; You get one shield per run &mdash; save it for tricky double-pair bursts!<br>
  &bull; Speed increases every 10 points; stay focused.<br><br>
  <strong>Accessibility</strong><br>
  Each color has a unique shape symbol for colorblind-friendly play. The game supports both touch and keyboard input (Space or Enter).
</div>

<script>
'use strict';
(()=>{

/* ── DOM refs ── */
const canvas = document.getElementById('gc');
const ctx    = canvas.getContext('2d');
const container    = document.getElementById('game-container');
const hudScore     = document.getElementById('hud-score');
const hudCombo     = document.getElementById('hud-combo');
const hudShield    = document.getElementById('hud-shield');
const hudHigh      = document.getElementById('hud-high');
const startScreen  = document.getElementById('start-screen');
const gameoverScreen = document.getElementById('gameover-screen');
const goScore      = document.getElementById('go-score');
const goNewBest    = document.getElementById('go-newbest');
const goStats      = document.getElementById('go-stats');
const btnStart     = document.getElementById('btn-start');
const btnRetry     = document.getElementById('btn-retry');
const btnShare     = document.getElementById('btn-share');
const startHighEl  = document.getElementById('start-high');

/* ── Color definitions (colorblind-friendly symbols) ── */
const COLORS = [
  { name:'Red',    h:0,   s:72, l:58, symbol:'triangle' },
  { name:'Blue',   h:220, s:72, l:58, symbol:'circle'   },
  { name:'Yellow', h:48,  s:90, l:58, symbol:'stripe'   }
];

/* ── State ── */
let W, H, dpr;
let state = 'start';
let score, combo, maxCombo, shields, lean;
let runnerColor;
let gates       = [];
let particles   = [];
let trailSparks = [];
let ringPulses  = [];
let screenShake = { x:0, y:0, t:0, mag:0, dur:0 };
let flashAlpha  = 0;
let perfectActive = false;
let perfectTimer  = 0;
let hueShift    = 0;
let gameTime    = 0;
let speed, baseSpeed;
let gateTimer   = 0;
let highScore   = parseInt(localStorage.getItem('cd_sd_hi')) || 0;
let lastTime    = 0;
let animId      = 0;
let leanSwitchTime = 0; // time since last lean switch (for perfect detection)

/* ── Constants ── */
const RUNNER_Y   = 0.78;
const LANE_OFF   = 0.22;
const GATE_W     = 0.36;
const GATE_H     = 52;
const RUNNER_R   = 22;
const MAX_PARTS  = 180;
const MAX_TRAIL  = 50;
const MAX_RINGS  = 8;

/* ── Resize ── */
function resize() {
  const r = container.getBoundingClientRect();
  dpr = window.devicePixelRatio || 1;
  W = r.width;
  H = r.height - 70;
  canvas.width  = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resize);
resize();

/* ── Helpers ── */
function hsl(ci, a) {
  const c = COLORS[ci];
  const h = (c.h + hueShift) % 360;
  return a !== undefined
    ? `hsla(${h},${c.s}%,${c.l}%,${a})`
    : `hsl(${h},${c.s}%,${c.l}%)`;
}

function rr(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+r);
  ctx.lineTo(x+w, y+h-r);
  ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  ctx.lineTo(x+r, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-r);
  ctx.lineTo(x, y+r);
  ctx.quadraticCurveTo(x, y, x+r, y);
  ctx.closePath();
}

function laneX(side) {
  return W / 2 + (side === 0 ? -1 : 1) * W * LANE_OFF;
}

function runnerY() { return H * RUNNER_Y; }

/* ── Draw symbols ── */
function drawSym(cx, cy, sz, ci, style) {
  const c = COLORS[ci];
  ctx.save();
  if (style === 'white') {
    ctx.strokeStyle = 'rgba(255,255,255,.9)';
    ctx.fillStyle   = 'rgba(255,255,255,.9)';
    ctx.lineWidth   = 2.2;
  } else {
    ctx.fillStyle   = '#fff';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth   = 2;
  }
  if (c.symbol === 'triangle') {
    ctx.beginPath();
    ctx.moveTo(cx, cy - sz * 0.5);
    ctx.lineTo(cx + sz * 0.45, cy + sz * 0.35);
    ctx.lineTo(cx - sz * 0.45, cy + sz * 0.35);
    ctx.closePath();
    style === 'white' ? ctx.stroke() : ctx.fill();
  } else if (c.symbol === 'circle') {
    ctx.beginPath();
    ctx.arc(cx, cy, sz * 0.38, 0, Math.PI * 2);
    style === 'white' ? ctx.stroke() : ctx.fill();
  } else {
    const w = sz * 0.38;
    const th = style === 'white' ? 2.5 : 4;
    for (let i = -1; i <= 1; i++) {
      ctx.fillRect(cx - w, cy + i * sz * 0.24 - th/2, w * 2, th);
    }
  }
  ctx.restore();
}

/* ── Colored symbol for gates ── */
function drawSymColored(cx, cy, sz, ci, alpha) {
  ctx.save();
  ctx.globalAlpha = alpha || 1;
  ctx.fillStyle   = hsl(ci);
  ctx.strokeStyle = hsl(ci);
  ctx.lineWidth   = 2.5;
  const c = COLORS[ci];
  if (c.symbol === 'triangle') {
    ctx.beginPath();
    ctx.moveTo(cx, cy - sz * 0.5);
    ctx.lineTo(cx + sz * 0.45, cy + sz * 0.35);
    ctx.lineTo(cx - sz * 0.45, cy + sz * 0.35);
    ctx.closePath();
    ctx.fill();
  } else if (c.symbol === 'circle') {
    ctx.beginPath();
    ctx.arc(cx, cy, sz * 0.38, 0, Math.PI * 2);
    ctx.fill();
  } else {
    const w = sz * 0.38;
    for (let i = -1; i <= 1; i++) {
      ctx.fillRect(cx - w, cy + i * sz * 0.24 - 2, w * 2, 4);
    }
  }
  ctx.restore();
}

/* ── Draw runner ── */
function drawRunner() {
  const cx = laneX(lean);
  const cy = runnerY();

  // glow
  const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, RUNNER_R * 2.5);
  g.addColorStop(0, hsl(runnerColor, 0.3));
  g.addColorStop(1, hsl(runnerColor, 0));
  ctx.fillStyle = g;
  ctx.fillRect(cx - RUNNER_R * 3, cy - RUNNER_R * 3, RUNNER_R * 6, RUNNER_R * 6);

  // body
  ctx.fillStyle = hsl(runnerColor);
  ctx.beginPath();
  ctx.arc(cx, cy, RUNNER_R, 0, Math.PI * 2);
  ctx.fill();

  // ring
  ctx.strokeStyle = 'rgba(255,255,255,.45)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(cx, cy, RUNNER_R, 0, Math.PI * 2);
  ctx.stroke();

  // inner symbol
  drawSym(cx, cy, RUNNER_R * 0.85, runnerColor, 'white');

  // trail sparks when perfect
  if (perfectActive) {
    for (let i = 0; i < 2; i++) {
      if (trailSparks.length < MAX_TRAIL) {
        trailSparks.push({
          x: cx + (Math.random() - .5) * RUNNER_R,
          y: cy + RUNNER_R * (.4 + Math.random() * .4),
          vx: (Math.random() - .5) * 1.5,
          vy: 1 + Math.random() * 2,
          life: .35 + Math.random() * .25,
          ml: .35 + Math.random() * .25,
          ci: runnerColor
        });
      }
    }
  }
}

/* ── Draw gate ── */
function drawGate(gate, side) {
  const gw  = W * GATE_W;
  const cx  = laneX(side);
  const x   = cx - gw / 2;
  const y   = gate.y;
  const ci  = gate.colors[side];

  ctx.save();
  ctx.globalAlpha = .88;

  // fill
  const gr = ctx.createLinearGradient(x, y, x + gw, y + GATE_H);
  gr.addColorStop(0, hsl(ci, .85));
  gr.addColorStop(1, hsl(ci, .55));
  ctx.fillStyle = gr;
  rr(ctx, x, y, gw, GATE_H, 10);
  ctx.fill();

  // border
  ctx.strokeStyle = 'rgba(255,255,255,.25)';
  ctx.lineWidth = 1.5;
  rr(ctx, x, y, gw, GATE_H, 10);
  ctx.stroke();
  ctx.globalAlpha = 1;

  // symbol
  drawSymColored(cx, y + GATE_H / 2, GATE_H * 0.55, ci, .85);

  ctx.restore();
}

/* ── Telegraph ── */
function drawTelegraph() {
  if (!gates.length) return;
  const ng = gates[0];
  if (ng.passed) return;
  const ry   = runnerY();
  const dist = ry - (ng.y + GATE_H);
  const ahead = speed * 0.28;
  if (dist > 0 && dist < ahead) {
    for (let s = 0; s < 2; s++) {
      if (ng.colors[s] === runnerColor) {
        const cx = laneX(s);
        const gr = ctx.createLinearGradient(cx, ry - 50, cx, ry + 20);
        gr.addColorStop(0, hsl(runnerColor, 0));
        gr.addColorStop(.5, hsl(runnerColor, .07));
        gr.addColorStop(1, hsl(runnerColor, 0));
        ctx.fillStyle = gr;
        ctx.fillRect(cx - W * GATE_W / 2, ry - 50, W * GATE_W, 70);
      }
    }
  }
}

/* ── Background ── */
function drawBg() {
  const gr = ctx.createLinearGradient(0, 0, 0, H);
  gr.addColorStop(0, '#0d0d20');
  gr.addColorStop(.5, '#1a1a2e');
  gr.addColorStop(1, '#14203a');
  ctx.fillStyle = gr;
  ctx.fillRect(0, 0, W, H);

  // lane separator
  ctx.save();
  ctx.setLineDash([8, 14]);
  ctx.strokeStyle = 'rgba(255,255,255,.05)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(W / 2, 0);
  ctx.lineTo(W / 2, H);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  // lane bg
  for (let s = 0; s < 2; s++) {
    ctx.fillStyle = 'rgba(255,255,255,.015)';
    const cx = laneX(s);
    ctx.fillRect(cx - W * GATE_W / 2 - 4, 0, W * GATE_W + 8, H);
  }
}

/* ── Particles ── */
function spawnParts(x, y, ci, n, type) {
  for (let i = 0; i < n && particles.length < MAX_PARTS; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = type === 'perfect' ? 3 + Math.random() * 5 :
               type === 'shield'  ? 2 + Math.random() * 3 :
               2 + Math.random() * 3.5;
    particles.push({
      x, y,
      vx: Math.cos(a) * sp,
      vy: Math.sin(a) * sp - (type === 'perfect' ? 2 : 0),
      life: .4 + Math.random() * .5,
      ml:   .4 + Math.random() * .5,
      sz: type === 'shield' ? 3 : 2 + Math.random() * 3,
      ci, type: type || 'normal'
    });
  }
}

function spawnRing(x, y, ci) {
  if (ringPulses.length < MAX_RINGS)
    ringPulses.push({ x, y, r: RUNNER_R, mr: RUNNER_R * 5, life: .55, ml: .55, ci });
}

function shake(mag, dur) {
  screenShake.mag = mag;
  screenShake.t   = dur;
  screenShake.dur = dur;
}

function updateParts(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vy += 4 * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
  for (let i = trailSparks.length - 1; i >= 0; i--) {
    const s = trailSparks[i];
    s.x += s.vx; s.y += s.vy;
    s.life -= dt;
    if (s.life <= 0) trailSparks.splice(i, 1);
  }
  for (let i = ringPulses.length - 1; i >= 0; i--) {
    const r = ringPulses[i];
    r.life -= dt;
    r.r += (r.mr - RUNNER_R) * dt / r.ml;
    if (r.life <= 0) ringPulses.splice(i, 1);
  }
}

function drawParts() {
  for (const p of particles) {
    const a = Math.max(0, p.life / p.ml);
    ctx.save();
    ctx.globalAlpha = a;
    if (p.type === 'shield') {
      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold ' + Math.round(p.sz * 4) + 'px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('X', p.x, p.y);
    } else {
      ctx.fillStyle = hsl(p.ci);
      if (p.type === 'perfect') {
        ctx.shadowBlur  = 8;
        ctx.shadowColor = hsl(p.ci);
      }
      ctx.fillRect(p.x - p.sz / 2, p.y - p.sz / 2, p.sz, p.sz);
    }
    ctx.restore();
  }
  for (const s of trailSparks) {
    const a = Math.max(0, s.life / s.ml) * .7;
    ctx.save();
    ctx.globalAlpha = a;
    ctx.fillStyle = hsl(s.ci);
    ctx.beginPath();
    ctx.arc(s.x, s.y, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  for (const r of ringPulses) {
    const a = Math.max(0, r.life / r.ml) * .55;
    ctx.save();
    ctx.globalAlpha = a;
    ctx.strokeStyle = hsl(r.ci);
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }
}

function drawFlash() {
  if (flashAlpha > 0) {
    ctx.save();
    ctx.globalAlpha = flashAlpha;
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, W, H);
    ctx.restore();
  }
}

/* ── Difficulty curve ── */
function diff() {
  if (score < 10)  return { sm: 1,    sp: 230 };
  if (score < 25)  return { sm: 1.18, sp: 200 };
  if (score < 50)  return { sm: 1.4,  sp: 175 };
  return { sm: 1.6 + Math.min((score - 50) * 0.006, 0.55), sp: 150 };
}

/* ── Gate spawning ── */
function spawnGate() {
  let leftC, rightC;
  const other = () => { let o; do { o = (Math.random() * 3) | 0; } while (o === runnerColor); return o; };

  if (score >= 10 && Math.random() < 0.3) {
    // bait: both could match or create interesting choices
    leftC  = (Math.random() * 3) | 0;
    rightC = (Math.random() * 3) | 0;
    // ensure at least one matches
    if (leftC !== runnerColor && rightC !== runnerColor) {
      if (Math.random() < .5) leftC = runnerColor; else rightC = runnerColor;
    }
  } else {
    const ms = Math.random() < .5 ? 0 : 1;
    leftC  = ms === 0 ? runnerColor : other();
    rightC = ms === 1 ? runnerColor : other();
  }

  gates.push({ y: -GATE_H - 12, colors: [leftC, rightC], passed: false, scored: false });

  // double-pair burst 50+
  if (score >= 50 && Math.random() < .22) {
    const d = diff();
    const futureC = gates[gates.length - 1].colors[lean];
    let l2 = (Math.random() * 3) | 0;
    let r2 = (Math.random() * 3) | 0;
    if (l2 !== futureC && r2 !== futureC) {
      if (Math.random() < .5) l2 = futureC; else r2 = futureC;
    }
    gates.push({ y: -GATE_H - 12 - d.sp * .55, colors: [l2, r2], passed: false, scored: false });
  }
}

/* ── Collision ── */
function checkHit(g) {
  const ry = runnerY();
  if (g.y + GATE_H >= ry - RUNNER_R && g.y <= ry + RUNNER_R && !g.passed) {
    g.passed = true;
    const cx = laneX(lean);
    const hitC = g.colors[lean];

    // perfect timing check: switched lean very recently AND gate center close to runner
    const gcY = g.y + GATE_H / 2;
    const closeEnough = Math.abs(gcY - ry) < RUNNER_R * 0.7;
    const recentSwitch = leanSwitchTime < 0.22;
    const isPerfect = closeEnough && recentSwitch;

    if (hitC === runnerColor) {
      score++;
      combo++;
      if (combo > maxCombo) maxCombo = combo;
      runnerColor = hitC;
      spawnParts(cx, ry, hitC, isPerfect ? 28 : 14, isPerfect ? 'perfect' : 'normal');
      if (isPerfect) {
        spawnRing(cx, ry, hitC);
        flashAlpha = .12;
        perfectActive = true;
        perfectTimer  = .5;
        shake(3, .15);
        score++;
      }
      g.scored = true;
      updateHUD();
    } else {
      combo = 0;
      // color changes to whatever we hit
      runnerColor = hitC;
      if (shields > 0) {
        shields--;
        spawnParts(cx, ry, hitC, 18, 'shield');
        shake(7, .3);
        updateHUD();
      } else {
        endGame();
      }
    }
  }
}

/* ── HUD ── */
function updateHUD() {
  hudScore.textContent = score;
  hudCombo.textContent = combo >= 3 ? combo + 'x combo' : '';
  hudShield.textContent = shields > 0 ? '\u{1F6E1}\uFE0F Shield' : '';
  hudHigh.textContent = 'Best: ' + highScore;
}

/* ── Shake ── */
function updateShake(dt) {
  if (screenShake.t > 0) {
    screenShake.t -= dt;
    const i = screenShake.mag * Math.max(0, screenShake.t / screenShake.dur);
    screenShake.x = (Math.random() - .5) * i * 2;
    screenShake.y = (Math.random() - .5) * i * 2;
  } else {
    screenShake.x = 0;
    screenShake.y = 0;
  }
}

/* ── Game flow ── */
function initGame() {
  score = 0; combo = 0; maxCombo = 0; shields = 1; lean = 0;
  runnerColor = (Math.random() * 3) | 0;
  gates = []; particles = []; trailSparks = []; ringPulses = [];
  screenShake = { x:0, y:0, t:0, mag:0, dur:0 };
  flashAlpha = 0; perfectActive = false; perfectTimer = 0;
  gameTime = 0; baseSpeed = 150; speed = baseSpeed;
  gateTimer = 0; hueShift = 0; leanSwitchTime = 10;
}

function startGame() {
  initGame();
  state = 'playing';
  startScreen.classList.add('hidden');
  gameoverScreen.classList.add('hidden');
  updateHUD();
  lastTime = performance.now();
  cancelAnimationFrame(animId);
  animId = requestAnimationFrame(loop);
}

function endGame() {
  state = 'gameover';
  shake(14, .55);
  spawnParts(laneX(lean), runnerY(), runnerColor, 45, 'normal');
  const best = score > highScore;
  if (best) { highScore = score; localStorage.setItem('cd_sd_hi', highScore); }
  goScore.textContent = score;
  goStats.textContent = 'Best combo: ' + maxCombo + 'x \u00B7 High score: ' + highScore;
  if (best) goNewBest.classList.remove('hidden');
  else goNewBest.classList.add('hidden');
  setTimeout(() => { if (state === 'gameover') gameoverScreen.classList.remove('hidden'); }, 650);
}

/* ── Main loop ── */
function loop(now) {
  let dt = (now - lastTime) / 1000;
  lastTime = now;
  if (dt > .05) dt = .05;

  if (state === 'playing') {
    gameTime += dt;
    hueShift += dt * 8;
    leanSwitchTime += dt;
    const d = diff();
    speed = baseSpeed * d.sm;

    gateTimer -= dt;
    if (gateTimer <= 0) {
      spawnGate();
      gateTimer = d.sp / speed;
    }

    for (const g of gates) g.y += speed * dt;
    for (const g of gates) { if (!g.passed) checkHit(g); }
    gates = gates.filter(g => g.y < H + 60);

    if (perfectActive) { perfectTimer -= dt; if (perfectTimer <= 0) perfectActive = false; }
    if (flashAlpha > 0) flashAlpha = Math.max(0, flashAlpha - dt * 1.8);
  }

  updateShake(dt);
  updateParts(dt);

  ctx.save();
  ctx.translate(screenShake.x, screenShake.y);
  drawBg();

  if (state === 'playing') drawTelegraph();
  for (const g of gates) { drawGate(g, 0); drawGate(g, 1); }
  if (state === 'playing') drawRunner();

  drawParts();
  drawFlash();
  ctx.restore();

  // keep loop alive while effects are still running
  if (state === 'playing' || screenShake.t > 0 || particles.length || trailSparks.length || ringPulses.length || flashAlpha > 0) {
    animId = requestAnimationFrame(loop);
  }
}

/* ── Input ── */
function doInput(e) {
  if (e) e.preventDefault();
  if (state === 'playing') { lean = lean === 0 ? 1 : 0; leanSwitchTime = 0; }
}

canvas.addEventListener('pointerdown', doInput);

document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter') {
    e.preventDefault();
    if (state === 'start') startGame();
    else if (state === 'playing') doInput();
    else if (state === 'gameover' && !gameoverScreen.classList.contains('hidden')) startGame();
  }
});

btnStart.addEventListener('click', e => { e.stopPropagation(); startGame(); });
btnRetry.addEventListener('click', e => { e.stopPropagation(); startGame(); });
btnShare.addEventListener('click', e => {
  e.stopPropagation();
  const txt = 'I scored ' + score + ' in Color Dash: Split Decision! Can you beat me?\nhttps://balinti.github.io/color-dash/';
  if (navigator.share) {
    navigator.share({ title: 'Color Dash', text: txt }).catch(() => {});
  } else if (navigator.clipboard) {
    navigator.clipboard.writeText(txt).then(() => {
      btnShare.textContent = 'Copied!';
      setTimeout(() => { btnShare.textContent = 'Challenge a Friend'; }, 2000);
    }).catch(() => {});
  }
});

/* ── Init ── */
function showStart() {
  state = 'start';
  startScreen.classList.remove('hidden');
  gameoverScreen.classList.add('hidden');
  startHighEl.textContent = highScore > 0 ? 'High Score: ' + highScore : '';
  drawBg();
}

showStart();

// idle anim
(function idle(t) {
  if (state !== 'start') return;
  hueShift += .12;
  drawBg();
  requestAnimationFrame(idle);
})(0);

})();
</script>
</body>
</html>
