<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Color Dash - Free HTML5 Game</title>
<meta name="description" content="Play Color Dash - Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#0a0a1a">
<link rel="canonical" href="https://balinti.github.io/color-dash/">
<meta property="og:type" content="website">
<meta property="og:title" content="Color Dash - Free HTML5 Game">
<meta property="og:description" content="Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta property="og:url" content="https://balinti.github.io/color-dash/">
<meta property="og:image" content="https://balinti.github.io/color-dash/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Color Dash - Free HTML5 Game">
<meta name="twitter:description" content="Run through color gates matching your current color. Tap to switch between colors. Speed increases every 10 points.">
<meta name="twitter:image" content="https://balinti.github.io/color-dash/og-image.png">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4099346100621490" crossorigin="anonymous"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;color:#fff;touch-action:none;-webkit-tap-highlight-color:transparent;user-select:none}
#wrap{display:flex;flex-direction:column;align-items:center;width:100%;max-width:420px;height:100vh;height:100dvh;margin:0 auto}
#header{width:100%;height:50px;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.04);border-bottom:1px solid rgba(255,255,255,.06);flex-shrink:0;z-index:10}
#header span{font-size:14px;font-weight:700;letter-spacing:2px;text-transform:uppercase;color:rgba(255,255,255,.7)}
#game-area{flex:1;width:100%;position:relative;overflow:hidden;min-height:0}
canvas{display:block;width:100%;height:100%}
#hud{position:absolute;top:10px;left:0;right:0;display:flex;justify-content:space-between;align-items:flex-start;padding:0 14px;pointer-events:none;z-index:5}
.hud-left{display:flex;flex-direction:column}
.hud-score{font-size:26px;font-weight:800;text-shadow:0 2px 8px rgba(0,0,0,.5)}
.hud-combo{font-size:12px;font-weight:600;color:rgba(255,255,255,.65);margin-top:2px}
.hud-shield{font-size:22px;text-shadow:0 0 8px rgba(255,255,255,.3)}
#footer{width:100%;height:36px;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.04);border-top:1px solid rgba(255,255,255,.06);flex-shrink:0;z-index:10}
#footer a{color:rgba(255,255,255,.35);font-size:11px;text-decoration:none;cursor:pointer}
#footer a:hover{color:rgba(255,255,255,.55)}
#pm{display:none;position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:100;align-items:center;justify-content:center}
#pm.show{display:flex}
#pm .inner{background:#1a1a2e;border-radius:12px;padding:24px;max-width:340px;width:90%;max-height:70vh;overflow-y:auto}
#pm h3{margin-bottom:10px;font-size:16px}
#pm p{font-size:13px;color:rgba(255,255,255,.65);line-height:1.6;margin-bottom:10px}
#pm button{background:rgba(255,255,255,.1);border:none;color:#fff;padding:8px 20px;border-radius:6px;cursor:pointer;font-size:13px}
</style>
</head>
<body>
<div id="wrap">
  <div id="header"><span>Color Dash</span></div>
  <div id="game-area">
    <canvas id="c"></canvas>
    <div id="hud">
      <div class="hud-left">
        <div class="hud-score" id="hs">0</div>
        <div class="hud-combo" id="hc"></div>
      </div>
      <div class="hud-shield" id="hsh"></div>
    </div>
  </div>
  <div id="footer"><a id="plink">Privacy</a></div>
</div>
<div id="pm">
  <div class="inner">
    <h3>Privacy Policy</h3>
    <p>This game stores your high score locally on your device using localStorage. No personal data is collected or transmitted.</p>
    <p>Third-party advertising (Google AdSense) may use cookies. See Google's privacy policy for details.</p>
    <button id="pclose">Close</button>
  </div>
</div>
<script>
'use strict';
(()=>{
/* ── Helpers ── */
const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
const lerp=(a,b,t)=>a+(b-a)*t;
const rand=(lo,hi)=>lo+Math.random()*(hi-lo);
const randInt=(lo,hi)=>Math.floor(rand(lo,hi+1));
const hsl=(h,s,l,a)=>a!=null?`hsla(${h},${s}%,${l}%,${a})`:`hsl(${h},${s}%,${l}%)`;

/* ── Constants ── */
const LS_KEY='cd_best';
const SUN=0,MOON=1;
const LEFT=0,RIGHT=1;
const GUARD_MS=500;
const ORB_R=16;

/* Sun = warm gold + stripes, Moon = cool blue + dots */
const MODE_COLORS=['#FFB347','#7EC8E3'];
const MODE_DARK=['#E8941C','#4A9EC7'];

/* Gate types */
const GT_STATIC=0,GT_OFFSET=1,GT_SLIDING=2,GT_FLICKER=3,GT_COMBO=4,GT_NARROW=5;

/* ── DOM ── */
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
const scoreEl=document.getElementById('hs');
const comboEl=document.getElementById('hc');
const shieldEl=document.getElementById('hsh');
const gameArea=document.getElementById('game-area');

document.getElementById('plink').onclick=()=>document.getElementById('pm').classList.add('show');
document.getElementById('pclose').onclick=()=>document.getElementById('pm').classList.remove('show');

/* ── Canvas sizing ── */
let W,H,dpr;
function resize(){
  const r=gameArea.getBoundingClientRect();
  W=r.width;H=r.height;
  dpr=Math.min(window.devicePixelRatio||1,2);
  canvas.width=W*dpr;canvas.height=H*dpr;
  canvas.style.width=W+'px';canvas.style.height=H+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize',resize);
resize();

/* ── State ── */
let state='start';
let score=0,best=parseInt(localStorage.getItem(LS_KEY))||0;
let mode=SUN,lane=LEFT;
let hasShield=true;
let combo=0,comboMul=1;
let speed=0,baseSpeed=3;
let gates=[],particles=[],bgStars=[];
let shakeX=0,shakeY=0,shakeMag=0;
let hitStopTimer=0;
let gameOverTime=0;
let hueShift=0;
let orbY=0;
let orbTrail=[];
let nearMissTimer=0;
let gateSpawnAccum=0;
let gameTime=0;
let lastGateY=-999;

/* ── Background stars ── */
function initStars(){
  bgStars=[];
  for(let i=0;i<35;i++) bgStars.push({x:rand(0,W),y:rand(0,H),r:rand(0.8,2),a:rand(0.05,0.2),s:rand(0.2,0.8)});
}
initStars();

/* ── Gate helpers ── */
function gateTypes(){
  const t=[GT_STATIC];
  if(score>=10) t.push(GT_OFFSET);
  if(score>=25) t.push(GT_SLIDING);
  if(score>=45) t.push(GT_FLICKER);
  if(score>=70) t.push(GT_COMBO,GT_NARROW);
  return t;
}

function makeGate(y){
  const types=gateTypes();
  const type=types[randInt(0,types.length-1)];
  const sunLane=Math.random()<0.5?LEFT:RIGHT;
  return{
    y:y||-50,
    type,sunLane,
    gateW:type===GT_NARROW?W*0.52:W*0.72,
    divX:type===GT_OFFSET?(0.3+Math.random()*0.4):0.5,
    slideDir:Math.random()<0.5?1:-1,
    slideSpd:0.25+Math.random()*0.3,
    flickTimer:0,flickVis:false,
    passed:false,scored:false,
    narrow:type===GT_NARROW,
    isCombo:type===GT_COMBO
  };
}

/* ── Particles ── */
function spawn(x,y,col,n,spread,life){
  for(let i=0;i<n&&particles.length<400;i++){
    const a=rand(0,Math.PI*2),sp=rand(0.5,spread);
    particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:life*rand(0.5,1),maxLife:life,color:col,r:rand(1.5,4.5)});
  }
}
function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx*dt*60;p.y+=p.vy*dt*60;
    p.vy+=0.03*dt*60;p.vx*=0.98;
    p.life-=dt;p.r*=0.997;
    if(p.life<=0||p.r<0.3) particles.splice(i,1);
  }
}
function drawParticles(){
  for(const p of particles){
    const a=clamp(p.life/p.maxLife,0,1);
    ctx.globalAlpha=a;ctx.fillStyle=p.color;
    ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,Math.PI*2);ctx.fill();
  }
  ctx.globalAlpha=1;
}

/* ── Shake ── */
function triggerShake(mag){shakeMag=Math.max(shakeMag,mag);}
function updateShake(dt){
  if(shakeMag>0.2){
    shakeMag*=0.88;
    shakeX=rand(-shakeMag,shakeMag);shakeY=rand(-shakeMag,shakeMag);
  }else{shakeMag=0;shakeX=shakeY=0;}
}

/* ── Drawing: Sun icon ── */
function drawSunIcon(x,y,r,alpha){
  ctx.save();ctx.globalAlpha=alpha||1;
  ctx.fillStyle=MODE_COLORS[SUN];
  ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.fill();
  /* rays */
  ctx.strokeStyle=MODE_COLORS[SUN];ctx.lineWidth=1.5;
  for(let i=0;i<8;i++){
    const a=(Math.PI*2/8)*i+hueShift*0.015;
    ctx.beginPath();
    ctx.moveTo(x+Math.cos(a)*(r+2),y+Math.sin(a)*(r+2));
    ctx.lineTo(x+Math.cos(a)*(r+5),y+Math.sin(a)*(r+5));
    ctx.stroke();
  }
  /* stripes — accessibility pattern */
  ctx.strokeStyle='rgba(255,255,255,0.45)';ctx.lineWidth=1.2;
  ctx.beginPath();
  ctx.moveTo(x-r*.4,y-r*.3);ctx.lineTo(x+r*.4,y-r*.3);
  ctx.moveTo(x-r*.5,y);ctx.lineTo(x+r*.5,y);
  ctx.moveTo(x-r*.4,y+r*.3);ctx.lineTo(x+r*.4,y+r*.3);
  ctx.stroke();
  ctx.restore();
}

/* ── Drawing: Moon icon ── */
function drawMoonIcon(x,y,r,alpha){
  ctx.save();ctx.globalAlpha=alpha||1;
  ctx.fillStyle=MODE_COLORS[MOON];
  ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.fill();
  /* crescent */
  ctx.fillStyle='rgba(0,0,0,0.22)';
  ctx.beginPath();ctx.arc(x+r*0.32,y-r*0.18,r*0.62,0,Math.PI*2);ctx.fill();
  /* dots — accessibility pattern */
  ctx.fillStyle='rgba(255,255,255,0.5)';
  const dots=[[-.25,-.2],[.12,.22],[-.12,.12],[.22,-.08],[0,.02]];
  for(const d of dots){ctx.beginPath();ctx.arc(x+d[0]*r,y+d[1]*r,1.3,0,Math.PI*2);ctx.fill();}
  ctx.restore();
}

/* ── Drawing: Orb (player) ── */
function getOrbX(){
  const w=W*0.36;
  return lane===LEFT?W/2-w/2:W/2+w/2;
}

function drawOrb(x,y){
  /* trail */
  for(let i=0;i<orbTrail.length;i++){
    const t=orbTrail[i];
    const a=(i/orbTrail.length)*0.25;
    ctx.globalAlpha=a;ctx.fillStyle=MODE_COLORS[mode];
    ctx.beginPath();ctx.arc(t.x,t.y,ORB_R*(0.35+0.65*i/orbTrail.length),0,Math.PI*2);ctx.fill();
  }
  ctx.globalAlpha=1;
  /* glow */
  const g=ctx.createRadialGradient(x,y,ORB_R*0.3,x,y,ORB_R*2.2);
  g.addColorStop(0,mode===SUN?'rgba(255,179,71,0.28)':'rgba(126,200,227,0.28)');
  g.addColorStop(1,'transparent');
  ctx.fillStyle=g;ctx.beginPath();ctx.arc(x,y,ORB_R*2.2,0,Math.PI*2);ctx.fill();
  /* icon */
  if(mode===SUN) drawSunIcon(x,y,ORB_R,1);
  else drawMoonIcon(x,y,ORB_R,1);
  /* shield ring */
  if(hasShield){
    ctx.strokeStyle='rgba(255,255,255,0.55)';ctx.lineWidth=2;
    ctx.setLineDash([4,4]);
    ctx.beginPath();ctx.arc(x,y,ORB_R+7,hueShift*0.06,hueShift*0.06+Math.PI*1.5);ctx.stroke();
    ctx.setLineDash([]);
  }
}

/* ── Drawing: Gate ── */
function drawGate(g){
  const gx=(W-g.gateW)/2;
  const gH=14;
  const divAbs=gx+g.gateW*g.divX;
  const leftW=divAbs-gx;
  const rightW=gx+g.gateW-divAbs;

  /* For flicker type: visual color swaps but icon/pattern stays true */
  const flickSwap=g.type===GT_FLICKER&&g.flickVis;
  const sunIsLeft=flickSwap?(g.sunLane!==LEFT):(g.sunLane===LEFT);

  const leftCol=sunIsLeft?MODE_DARK[SUN]:MODE_DARK[MOON];
  const rightCol=sunIsLeft?MODE_DARK[MOON]:MODE_DARK[SUN];

  /* frame */
  ctx.fillStyle='rgba(255,255,255,0.1)';
  ctx.fillRect(gx-2,g.y-2,g.gateW+4,gH+4);

  /* lanes */
  ctx.fillStyle=leftCol;ctx.fillRect(gx,g.y,leftW,gH);
  ctx.fillStyle=rightCol;ctx.fillRect(divAbs,g.y,rightW,gH);

  /* divider line */
  ctx.fillStyle='rgba(255,255,255,0.85)';
  ctx.fillRect(divAbs-1.5,g.y-5,3,gH+10);

  /* icons — always show TRUE assignment (reliable for color-vision) */
  const iy=g.y+gH/2;
  const lIx=gx+leftW/2;
  const rIx=divAbs+rightW/2;
  if(g.sunLane===LEFT){
    drawSunIcon(lIx,iy,5,0.75);
    drawMoonIcon(rIx,iy,5,0.75);
  }else{
    drawMoonIcon(lIx,iy,5,0.75);
    drawSunIcon(rIx,iy,5,0.75);
  }

  /* narrow bonus label */
  if(g.narrow){
    ctx.fillStyle='rgba(255,215,0,0.65)';ctx.font='bold 9px sans-serif';ctx.textAlign='center';
    ctx.fillText('BONUS',W/2,g.y-7);
  }
}

/* ── Drawing: Background ── */
function drawBG(){
  const h1=(215+hueShift*0.25)%360;
  const h2=(245+hueShift*0.4)%360;
  const gr=ctx.createLinearGradient(0,0,0,H);
  gr.addColorStop(0,hsl(h1,28,7));
  gr.addColorStop(1,hsl(h2,32,4));
  ctx.fillStyle=gr;ctx.fillRect(0,0,W,H);
  /* grid */
  ctx.strokeStyle='rgba(255,255,255,0.025)';ctx.lineWidth=1;
  const off=(hueShift*1.5)%40;
  for(let y=off;y<H;y+=40){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(W,y);ctx.stroke();}
  /* stars */
  for(const s of bgStars){
    ctx.globalAlpha=s.a;ctx.fillStyle='#fff';
    ctx.beginPath();ctx.arc(s.x,s.y,s.r,0,Math.PI*2);ctx.fill();
  }
  ctx.globalAlpha=1;
}
function updateStars(dt){
  const s=state==='playing'?speed*0.3:0.5;
  for(const st of bgStars){st.y+=st.s*s*dt*60;if(st.y>H+5){st.y=-3;st.x=rand(0,W);}}
}

/* ── Input ── */
function handleInput(){
  if(state==='start'){startGame();return;}
  if(state==='playing'){flipMode();return;}
  if(state==='gameover'&&performance.now()-gameOverTime>GUARD_MS) state='start';
}

function flipMode(){
  mode=mode===SUN?MOON:SUN;
  lane=lane===LEFT?RIGHT:LEFT;
  spawn(getOrbX(),orbY,MODE_COLORS[mode],8,2.5,0.3);
}

canvas.addEventListener('pointerdown',e=>{e.preventDefault();handleInput();},{passive:false});
document.addEventListener('keydown',e=>{
  if(e.code==='Space'||e.code==='Enter'){e.preventDefault();handleInput();}
});

/* ── Game lifecycle ── */
function startGame(){
  state='playing';score=0;mode=SUN;lane=LEFT;
  hasShield=true;combo=0;comboMul=1;speed=0;baseSpeed=3;
  gates=[];particles=[];orbTrail=[];
  shakeX=shakeY=0;shakeMag=0;hitStopTimer=0;
  gateSpawnAccum=0;gameTime=0;nearMissTimer=0;
  orbY=H*0.78;lastGateY=-999;
  initStars();
  updateHUD();
}

function getSpeed(){return 3+score*0.035+Math.min(gameTime*0.08,3.5);}

/* spawn interval in pixels traveled */
function spawnInterval(){return clamp(200-score*0.6,100,200);}

/* ── Update ── */
function updateGame(dt){
  if(hitStopTimer>0){hitStopTimer-=dt;return;}
  hueShift+=dt*25;
  gameTime+=dt;
  speed=getSpeed();

  /* spawn gates */
  gateSpawnAccum+=speed*dt*60;
  if(gateSpawnAccum>=spawnInterval()){
    gateSpawnAccum-=spawnInterval();
    const g=makeGate(-50);
    gates.push(g);
    if(g.isCombo){
      const g2=makeGate(-100);
      g2.type=GT_STATIC;g2.isCombo=false;
      gates.push(g2);
    }
  }

  /* move gates */
  for(const g of gates){
    g.y+=speed*dt*60;
    if(g.type===GT_SLIDING){
      g.divX+=g.slideDir*g.slideSpd*dt;
      if(g.divX>0.68){g.divX=0.68;g.slideDir=-1;}
      if(g.divX<0.32){g.divX=0.32;g.slideDir=1;}
    }
    if(g.type===GT_FLICKER){
      g.flickTimer+=dt;
      g.flickVis=Math.sin(g.flickTimer*14)>0.35;
    }
  }

  /* collision */
  const orbX=getOrbX();
  for(let i=gates.length-1;i>=0;i--){
    const g=gates[i];
    if(g.y>H+60){gates.splice(i,1);continue;}
    if(!g.passed&&g.y>=orbY-ORB_R&&g.y<=orbY+ORB_R){
      g.passed=true;
      const gx=(W-g.gateW)/2;
      const divAbs=gx+g.gateW*g.divX;
      const inLeft=orbX<divAbs;

      /* is current mode safe in the lane the orb is in? */
      const safeInLeft=(mode===SUN&&g.sunLane===LEFT)||(mode===MOON&&g.sunLane===RIGHT);
      const safeInRight=(mode===SUN&&g.sunLane===RIGHT)||(mode===MOON&&g.sunLane===LEFT);
      const safe=(inLeft&&safeInLeft)||(!inLeft&&safeInRight);

      if(safe){
        if(!g.scored){
          g.scored=true;
          combo++;
          comboMul=1+Math.floor(combo/5)*0.5;
          const pts=g.narrow?Math.ceil(3*comboMul):Math.ceil(1*comboMul);
          score+=pts;
          if(score>best){best=score;localStorage.setItem(LS_KEY,''+best);}
          /* near-miss */
          const dist=Math.abs(orbX-divAbs);
          if(dist<28){
            nearMissTimer=0.7;
            spawn(orbX,orbY,'#FFD700',14,4,0.45);
            triggerShake(2);
          }
          spawn(orbX,orbY,MODE_COLORS[mode],10,3,0.4);
        }
      }else{
        /* hit */
        if(hasShield){
          hasShield=false;combo=0;comboMul=1;
          triggerShake(7);hitStopTimer=0.12;
          spawn(orbX,orbY,'#fff',22,5,0.55);
          spawn(orbX,orbY,'#FF4444',16,4,0.5);
        }else{
          triggerShake(12);hitStopTimer=0.22;
          spawn(orbX,orbY,'#FF2222',35,6,0.8);
          spawn(orbX,orbY,'#fff',18,4,0.6);
          state='gameover';gameOverTime=performance.now();
          if(score>best){best=score;localStorage.setItem(LS_KEY,''+best);}
        }
      }
    }
  }

  /* orb trail */
  orbTrail.push({x:orbX,y:orbY});
  if(orbTrail.length>14) orbTrail.shift();

  if(nearMissTimer>0) nearMissTimer-=dt;
  updateHUD();
}

function updateHUD(){
  scoreEl.textContent=score;
  comboEl.textContent=combo>2?`x${comboMul.toFixed(1)} (${combo})`:' ';
  shieldEl.textContent=hasShield?'\u{1F6E1}\uFE0F':'';
}

/* ── Draw screens ── */
function drawStartScreen(){
  drawBG();
  ctx.textAlign='center';
  ctx.fillStyle='#fff';ctx.font='bold 34px sans-serif';
  ctx.fillText('Color Dash',W/2,H*0.22);
  ctx.font='15px sans-serif';ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.fillText('Flip & Thread',W/2,H*0.28);

  /* preview icons */
  drawSunIcon(W/2-28,H*0.38,20,0.9);
  drawMoonIcon(W/2+28,H*0.38,20,0.9);

  ctx.fillStyle='rgba(255,255,255,0.75)';ctx.font='13px sans-serif';
  const lines=[
    'Tap to flip between Sun & Moon',
    'Each flip also swaps your lane',
    'Match your mode to the safe lane',
    'Icons always show the truth!',
    'One shield per run — use it wisely',
  ];
  lines.forEach((l,i)=>ctx.fillText(l,W/2,H*0.50+i*20));

  const pulse=0.5+0.5*Math.sin(performance.now()*0.004);
  ctx.globalAlpha=0.4+pulse*0.6;ctx.font='bold 18px sans-serif';ctx.fillStyle='#fff';
  ctx.fillText('Tap to Start',W/2,H*0.78);
  ctx.globalAlpha=1;

  if(best>0){
    ctx.font='13px sans-serif';ctx.fillStyle='rgba(255,255,255,0.4)';
    ctx.fillText('Best: '+best,W/2,H*0.85);
  }
}

function drawGameOverScreen(){
  drawBG();drawParticles();
  ctx.textAlign='center';
  ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(0,0,W,H);
  ctx.fillStyle='#FF4444';ctx.font='bold 30px sans-serif';
  ctx.fillText('Game Over',W/2,H*0.27);
  ctx.fillStyle='#fff';ctx.font='bold 46px sans-serif';
  ctx.fillText(score,W/2,H*0.40);
  ctx.font='13px sans-serif';ctx.fillStyle='rgba(255,255,255,0.5)';
  ctx.fillText('SCORE',W/2,H*0.44);
  ctx.font='bold 18px sans-serif';
  ctx.fillStyle=score>=best&&score>0?'#FFD700':'rgba(255,255,255,0.65)';
  ctx.fillText('Best: '+best,W/2,H*0.52);
  if(score>=best&&score>0){
    ctx.font='11px sans-serif';ctx.fillStyle='#FFD700';
    ctx.fillText('NEW HIGH SCORE!',W/2,H*0.56);
  }
  const canRetry=performance.now()-gameOverTime>GUARD_MS;
  const p=canRetry?0.4+0.6*Math.sin(performance.now()*0.004)*0.5+0.3:0.25;
  ctx.globalAlpha=p;ctx.font='bold 16px sans-serif';ctx.fillStyle='#fff';
  ctx.fillText(canRetry?'Tap to Retry':'...',W/2,H*0.70);
  ctx.globalAlpha=1;
}

function drawPlaying(){
  drawBG();
  ctx.save();ctx.translate(shakeX,shakeY);
  for(const g of gates) drawGate(g);
  drawOrb(getOrbX(),orbY);
  /* near-miss flash */
  if(nearMissTimer>0){
    ctx.globalAlpha=nearMissTimer;ctx.fillStyle='#FFD700';
    ctx.font='bold 14px sans-serif';ctx.textAlign='center';
    ctx.fillText('CLOSE!',getOrbX(),orbY-28);ctx.globalAlpha=1;
  }
  drawParticles();
  ctx.restore();
}

/* ── Main loop ── */
let lastTime=0;
function loop(ts){
  requestAnimationFrame(loop);
  const rawDt=(ts-lastTime)/1000;
  lastTime=ts;
  const dt=Math.min(rawDt,0.05);
  resize();
  ctx.clearRect(0,0,W,H);
  updateStars(dt);
  switch(state){
    case 'start': drawStartScreen();break;
    case 'playing':
      updateGame(dt);updateParticles(dt);updateShake(dt);
      drawPlaying();break;
    case 'gameover':
      updateParticles(dt);updateShake(dt);
      drawGameOverScreen();break;
  }
}
requestAnimationFrame(t=>{lastTime=t;requestAnimationFrame(loop);});
})();
</script>
</body>
</html>
